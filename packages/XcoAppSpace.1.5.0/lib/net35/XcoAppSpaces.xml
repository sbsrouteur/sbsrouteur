<?xml version="1.0"?>
<doc>
  <assembly>
    <name>XcoAppSpaces</name>
  </assembly>
  <members>
    <member name="T:XcoAppSpaces.Core.DispatcherQueueExtensions">
      <summary>
            DispatcherQueue extension methods for simpler installation of port receivers.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.DispatcherQueueExtensions.Receive``1(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Receive messages from the given port. Whenever an element is posted to the port, the given handler is called.
            </summary>
      <typeparam name="TMessage">The mesage type of the port.</typeparam>
      <param name="dpq">The dispatcher queue.</param>
      <param name="port">The port from which the messages should be received.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.DispatcherQueueExtensions.Receive``1(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Handler{``0},XcoAppSpaces.Core.SyncContext)">
      <summary>
            Receive messages from the given port. Whenever an element is posted to the port, the given handler is called.
            </summary>
      <typeparam name="TMessage">The mesage type of the port.</typeparam>
      <param name="dpq">The dispatcher queue.</param>
      <param name="port">The port from which the messages should be received.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
      <param name="syncContext">Specifies the synchronization context that is used for processing the messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.DispatcherQueueExtensions.ReceiveSequentially``1(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Receive messages from the given port. Whenever an element is posted to the port, the given handler is called.
            Messages are received sequentially, meaning that the next message is received only after processing of the
            previous one has been finished.
            </summary>
      <typeparam name="TMessage">The mesage type of the port.</typeparam>
      <param name="dpq">The dispatcher queue.</param>
      <param name="port">The port from which the messages should be received.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.DispatcherQueueExtensions.ReceiveSequentially``1(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Handler{``0},XcoAppSpaces.Core.SyncContext)">
      <summary>
            Receive messages from the given port. Whenever an element is posted to the port, the given handler is called.
            Messages are received sequentially, meaning that the next message is received only after processing of the
            previous one has been finished.
            </summary>
      <typeparam name="TMessage">The mesage type of the port.</typeparam>
      <param name="dpq">The dispatcher queue.</param>
      <param name="port">The port from which the messages should be received.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
      <param name="syncContext">Specifies the synchronization context that is used for processing the messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.DispatcherQueueExtensions.ReceiveWithIterator``1(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.IteratorHandler{``0})">
      <summary>
            Receive messages from the given port. Whenever an element is posted to the port, the given handler is called.
            </summary>
      <typeparam name="TMessage">The mesage type of the port.</typeparam>
      <param name="dpq">The dispatcher queue.</param>
      <param name="port">The port from which the messages should be received.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.DispatcherQueueExtensions.Receive``1(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Creates a port and binds it to the given handler for receiving messages. Whenever an element is posted to 
            the port, the given handler is called.
            </summary>
      <typeparam name="T">The message type of the port.</typeparam>
      <param name="dpq">The dispatcher queue.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
      <returns>The created port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.DispatcherQueueExtensions.ReceiveSequentially``1(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Creates a port and binds it to the given handler for receiving messages. Whenever an element is posted to 
            the port, the given handler is called. Messages are received sequentially, meaning that the next message 
            is received only after processing of the previous one has been finished.
            </summary>
      <typeparam name="T">The message type of the port.</typeparam>
      <param name="dpq">The dispatcher queue.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
      <returns>The created port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.DispatcherQueueExtensions.Receive``1(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.Handler{``0},XcoAppSpaces.Core.SyncContext)">
      <summary>
            Creates a port and binds it to the given handler for receiving messages. Whenever an element is posted to 
            the port, the given handler is called.
            </summary>
      <typeparam name="T">The message type of the port.</typeparam>
      <param name="dpq">The dispatcher queue.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
      <param name="syncContext">Specifies the synchronization context that is used for processing the messages.</param>
      <returns>The created port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.DispatcherQueueExtensions.ReceiveSequentially``1(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.Handler{``0},XcoAppSpaces.Core.SyncContext)">
      <summary>
            Creates a port and binds it to the given handler for receiving messages. Whenever an element is posted to 
            the port, the given handler is called. Messages are received sequentially, meaning that the next message 
            is received only after processing of the previous one has been finished.
            </summary>
      <typeparam name="T">The message type of the port.</typeparam>
      <param name="dpq">The dispatcher queue.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
      <param name="syncContext">Specifies the synchronization context that is used for processing the messages.</param>
      <returns>The created port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.DispatcherQueueExtensions.ReceiveJoined``2(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Port{``1},Microsoft.Ccr.Core.Handler{``0,``1})">
      <summary>
            Receive messages from the given ports. Whenever an element is available in both ports, the given handler is called.
            </summary>
      <typeparam name="T1">The mesage type of port 1.</typeparam>
      <typeparam name="T2">The mesage type of port 2.</typeparam>
      <param name="dpq">The dispatcher queue.</param>
      <param name="port1">First port from which the messages should be received.</param>
      <param name="port2">Second port from which the messages should be received.</param>
      <param name="handler">The method to be called when a message is received from both ports.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.DispatcherQueueExtensions.ReceiveJoined``2(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Port{``1},Microsoft.Ccr.Core.Handler{``0,``1},XcoAppSpaces.Core.SyncContext)">
      <summary>
            Receive messages from the given ports. Whenever an element is available in both ports, the given handler is called.
            </summary>
      <typeparam name="T1">The mesage type of port 1.</typeparam>
      <typeparam name="T2">The mesage type of port 2.</typeparam>
      <param name="dpq">The dispatcher queue.</param>
      <param name="port1">First port from which the messages should be received.</param>
      <param name="port2">Second port from which the messages should be received.</param>
      <param name="handler">The method to be called when a message is received from both ports.</param>
      <param name="syncContext">Specifies the synchronization context that is used for processing the messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.DispatcherQueueExtensions.ReceiveChoice``2(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Port{``1},Microsoft.Ccr.Core.Handler{``0},Microsoft.Ccr.Core.Handler{``1})">
      <summary>
            When a messages is received from one of the given ports, the specific handler is called. The choice is taken only for
            the first element to arrive in one of the two ports.
            </summary>
      <typeparam name="T1">The mesage type of port 1.</typeparam>
      <typeparam name="T2">The mesage type of port 2.</typeparam>
      <param name="dpq">The dispatcher queue.</param>
      <param name="port1">First port for the choice.</param>
      <param name="port2">Second port for the choice.</param>
      <param name="handler1">The method to be called when a message arrives in the first port.</param>
      <param name="handler2">The method to be called when a message arrives in the second port.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.DispatcherQueueExtensions.ReceiveChoice``2(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Port{``1},Microsoft.Ccr.Core.Handler{``0},Microsoft.Ccr.Core.Handler{``1},XcoAppSpaces.Core.SyncContext)">
      <summary>
            When a messages is received from one of the given ports, the specific handler is called. The choice is taken only for
            the first element to arrive in one of the two ports.
            </summary>
      <typeparam name="T1">The mesage type of port 1.</typeparam>
      <typeparam name="T2">The mesage type of port 2.</typeparam>
      <param name="dpq">The dispatcher queue.</param>
      <param name="port1">First port for the choice.</param>
      <param name="port2">Second port for the choice.</param>
      <param name="handler1">The method to be called when a message arrives in the first port.</param>
      <param name="handler2">The method to be called when a message arrives in the second port.</param>
      <param name="syncContext">Specifies the synchronization context that is used for processing the messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.DispatcherQueueExtensions.CreateTimedAction(Microsoft.Ccr.Core.DispatcherQueue,System.TimeSpan,System.Func{XcoAppSpaces.Core.XcoTimedAction.Continuation})">
      <summary>
            Creates a timed action with the given dispatcher queue, interval and action.
            </summary>
      <param name="dpq">The dispatcher queue.</param>
      <param name="interval">Timer interval.</param>
      <param name="action">The action that should be invoked.</param>
      <returns>The created XcoTimedAction object. Call Invoke() or InvokeDelayed() to start the timed action. </returns>
    </member>
    <member name="T:XcoAppSpaces.Core.PortExtensions">
      <summary>
            Extensions for the IPort and Port{T} classes.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.PortExtensions.GetPortInfo(Microsoft.Ccr.Core.IPort)">
      <summary>
            Get information about the port concerning remote communication.
            </summary>
      <param name="port">The port.</param>
      <returns>Remote communication information about the port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.PortExtensions.TestSync``1(Microsoft.Ccr.Core.Port{``0})">
      <summary>
            Get a message from the port. If the port is currently empty wait for the next message.
            </summary>
      <typeparam name="TPortElement">The message type.</typeparam>
      <param name="port">The port.</param>
      <returns>The next message in the port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.PortExtensions.TestSync``1(Microsoft.Ccr.Core.Port{``0},System.Int32)">
      <summary>
            Get a message from the port. If the port is currently empty wait for the next message 
            until the given timeout. An exception is thrown if no message arrives in time.
            </summary>
      <typeparam name="TPortElement">The message type.</typeparam>
      <param name="port">The port.</param>
      <param name="timeout">The maximum time to wait.</param>
      <returns>The next message in the port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.PortExtensions.PostWithCausality``1(Microsoft.Ccr.Core.Port{``0},``0,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="TPortElement">The message type.</typeparam>
      <param name="port">The port.</param>
      <param name="message">The message to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortExtensions.PostWithCausality``1(Microsoft.Ccr.Core.Port{``0},``0,Microsoft.Ccr.Core.Handler{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionHandler register to a causality 
            for returning exceptions.
            </summary>
      <typeparam name="TPortElement">The message type.</typeparam>
      <param name="port">The port.</param>
      <param name="message">The message to be posted.</param>
      <param name="exceptionHandler">The handler where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortExtensions.PostWithCausality``1(Microsoft.Ccr.Core.Port{``0},``0,Microsoft.Ccr.Core.Handler{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionHandler register to a causality 
            for returning exceptions.
            </summary>
      <typeparam name="TPortElement">The message type.</typeparam>
      <param name="port">The port.</param>
      <param name="message">The message to be posted.</param>
      <param name="exceptionHandler">The handler where exceptions should be returned.</param>
      <param name="coordinationPort">The port which should be registered in the causality as coordination port.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortExtensions.PostWithCausality``1(Microsoft.Ccr.Core.Port{``0},``0,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="TPortElement">The message type.</typeparam>
      <param name="port">The port.</param>
      <param name="message">The message to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">The port which should be registered in the causality as coordination port.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortExtensions.Send``1(Microsoft.Ccr.Core.Port{``0},``0)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="TPortElement">The message type.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortExtensions.SendUnknownType(Microsoft.Ccr.Core.IPort,System.Object)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortExtensions.SendWithCausality``1(Microsoft.Ccr.Core.Port{``0},``0,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="TPortElement">The message type.</typeparam>
      <param name="port">The port.</param>
      <param name="message">The message to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortExtensions.SendWithCausality``1(Microsoft.Ccr.Core.Port{``0},``0,Microsoft.Ccr.Core.Handler{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionHandler is used to register to a causality  for returning exceptions.
            </summary>
      <typeparam name="TPortElement">The message type.</typeparam>
      <param name="port">The port.</param>
      <param name="message">The message to be sent.</param>
      <param name="exceptionHandler">The handler where exceptions should be returned.</param>
    </member>
    <member name="T:XcoAppSpaces.Core.PortSetExtensions">
      <summary>
            Extensions for PortSet classes.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``2(Microsoft.Ccr.Core.PortSet{``0,``1},``0,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``2(Microsoft.Ccr.Core.PortSet{``0,``1},``1,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``3(Microsoft.Ccr.Core.PortSet{``0,``1,``2},``0,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``3(Microsoft.Ccr.Core.PortSet{``0,``1,``2},``1,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``3(Microsoft.Ccr.Core.PortSet{``0,``1,``2},``2,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``0,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``1,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``2,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``3,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``0,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``1,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``2,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``3,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``4,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``2(Microsoft.Ccr.Core.PortSet{``0,``1},``0,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">Port that can be used for coordination. If a Port&lt;Ack&gt; is used, an Ack is posted there when the message has been transferred successfully.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``2(Microsoft.Ccr.Core.PortSet{``0,``1},``1,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">Port that can be used for coordination. If a Port&lt;Ack&gt; is used, an Ack is posted there when the message has been transferred successfully.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``3(Microsoft.Ccr.Core.PortSet{``0,``1,``2},``0,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">Port that can be used for coordination. If a Port&lt;Ack&gt; is used, an Ack is posted there when the message has been transferred successfully.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``3(Microsoft.Ccr.Core.PortSet{``0,``1,``2},``1,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">Port that can be used for coordination. If a Port&lt;Ack&gt; is used, an Ack is posted there when the message has been transferred successfully.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``3(Microsoft.Ccr.Core.PortSet{``0,``1,``2},``2,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">Port that can be used for coordination. If a Port&lt;Ack&gt; is used, an Ack is posted there when the message has been transferred successfully.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``0,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">Port that can be used for coordination. If a Port&lt;Ack&gt; is used, an Ack is posted there when the message has been transferred successfully.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``1,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">Port that can be used for coordination. If a Port&lt;Ack&gt; is used, an Ack is posted there when the message has been transferred successfully.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``2,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">Port that can be used for coordination. If a Port&lt;Ack&gt; is used, an Ack is posted there when the message has been transferred successfully.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``3,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">Port that can be used for coordination. If a Port&lt;Ack&gt; is used, an Ack is posted there when the message has been transferred successfully.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``0,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">Port that can be used for coordination. If a Port&lt;Ack&gt; is used, an Ack is posted there when the message has been transferred successfully.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``1,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">Port that can be used for coordination. If a Port&lt;Ack&gt; is used, an Ack is posted there when the message has been transferred successfully.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``2,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">Port that can be used for coordination. If a Port&lt;Ack&gt; is used, an Ack is posted there when the message has been transferred successfully.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``3,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">Port that can be used for coordination. If a Port&lt;Ack&gt; is used, an Ack is posted there when the message has been transferred successfully.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.PostWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``4,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Posts a message to the port while using the given exceptionPort as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be posted.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
      <param name="coordinationPort">Port that can be used for coordination. If a Port&lt;Ack&gt; is used, an Ack is posted there when the message has been transferred successfully.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.Send``2(Microsoft.Ccr.Core.PortSet{``0,``1},``0)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.Send``2(Microsoft.Ccr.Core.PortSet{``0,``1},``1)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.Send``3(Microsoft.Ccr.Core.PortSet{``0,``1,``2},``0)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.Send``3(Microsoft.Ccr.Core.PortSet{``0,``1,``2},``1)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.Send``3(Microsoft.Ccr.Core.PortSet{``0,``1,``2},``2)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.Send``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``0)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.Send``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``1)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.Send``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``2)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.Send``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``3)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.Send``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``0)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.Send``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``1)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.Send``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``2)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.Send``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``3)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.Send``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``4)">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port set.</param>
      <param name="item">The item to be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.SendWithCausality``2(Microsoft.Ccr.Core.PortSet{``0,``1},``0,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.SendWithCausality``2(Microsoft.Ccr.Core.PortSet{``0,``1},``1,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.SendWithCausality``3(Microsoft.Ccr.Core.PortSet{``0,``1,``2},``0,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.SendWithCausality``3(Microsoft.Ccr.Core.PortSet{``0,``1,``2},``1,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.SendWithCausality``3(Microsoft.Ccr.Core.PortSet{``0,``1,``2},``2,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.SendWithCausality``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``0,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.SendWithCausality``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``1,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.SendWithCausality``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``2,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.SendWithCausality``4(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3},``3,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.SendWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``0,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.SendWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``1,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.SendWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``2,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.SendWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``3,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.PortSetExtensions.SendWithCausality``5(Microsoft.Ccr.Core.PortSet{``0,``1,``2,``3,``4},``4,Microsoft.Ccr.Core.Port{System.Exception})">
      <summary>
            If the port is a remote port, this method sends the given item synchronously, meaning the method only 
            returns as soon as the item has been transferred successfully. This allows directly catching communication 
            errors, and by that ensuring that after this method the item has been transferred correctly.
            If the port is a local port, the item will simply be posted as normal.
            The given exceptionPort is used as causality.
            </summary>
      <typeparam name="T1">Message type of the port set.</typeparam>
      <typeparam name="T2">Message type of the port set.</typeparam>
      <typeparam name="T3">Message type of the port set.</typeparam>
      <typeparam name="T4">Message type of the port set.</typeparam>
      <typeparam name="T5">Message type of the port set.</typeparam>
      <param name="port">The port.</param>
      <param name="item">The item to be sent.</param>
      <param name="exceptionPort">The port where exceptions should be returned.</param>
    </member>
    <member name="T:XcoAppSpaces.Core.ServiceRegistryExtensions">
      <summary>
            Extensions fr the IXcoServiceRegistry class.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.ServiceRegistryExtensions.GetSpaceInstance(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Gets the space instance that this service registry belongs to.
            </summary>
      <param name="serviceRegistry">The service registry.</param>
      <returns>The space instance that this service registry belongs to</returns>
    </member>
    <member name="T:XcoAppSpaces.Core.SyncContext">
      <summary>
             Using the causalities in the SynchronizationContext
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Core.SyncContext.NoSyncContext">
      <summary>
            No synchronization context used
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Core.SyncContext.UseCurrentSyncContext">
      <summary>
            SynchronizationContext.Current will be used for task execution
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoAppSpaceExtensions">
      <summary>
            XcoAppSpace extension methods for simplifying usage of the application space.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.Receive``1(XcoAppSpaces.Core.IXcoAppSpace,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Receive messages from the given port. Whenever an element is posted to the port, the given handler is called.
            </summary>
      <typeparam name="TMessage">The mesage type of the port.</typeparam>
      <param name="space">The XcoAppSpace.</param>
      <param name="port">The port from which the messages should be received.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.Receive``1(XcoAppSpaces.Core.IXcoAppSpace,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Handler{``0},XcoAppSpaces.Core.SyncContext)">
      <summary>
            Receive messages from the given port. Whenever an element is posted to the port, the given handler is called.
            </summary>
      <typeparam name="TMessage">The mesage type of the port.</typeparam>
      <param name="space">The XcoAppSpace.</param>
      <param name="port">The port from which the messages should be received.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
      <param name="syncContext">Specifies the synchronization context that is used for processing the messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.ReceiveSequentially``1(XcoAppSpaces.Core.IXcoAppSpace,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Receive messages from the given port. Whenever an element is posted to the port, the given handler is called.
            Messages are received sequentially, meaning that the next message is received only after processing of the
            previous one has been finished.
            </summary>
      <typeparam name="TMessage">The mesage type of the port.</typeparam>
      <param name="space">The XcoAppSpace.</param>
      <param name="port">The port from which the messages should be received.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.ReceiveSequentially``1(XcoAppSpaces.Core.IXcoAppSpace,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Handler{``0},XcoAppSpaces.Core.SyncContext)">
      <summary>
            Receive messages from the given port. Whenever an element is posted to the port, the given handler is called.
            Messages are received sequentially, meaning that the next message is received only after processing of the
            previous one has been finished.
            </summary>
      <typeparam name="TMessage">The mesage type of the port.</typeparam>
      <param name="space">The XcoAppSpace.</param>
      <param name="port">The port from which the messages should be received.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
      <param name="syncContext">Specifies the synchronization context that is used for processing the messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.ReceiveWithIterator``1(XcoAppSpaces.Core.IXcoAppSpace,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.IteratorHandler{``0})">
      <summary>
            Receive messages from the given port. Whenever an element is posted to the port, the given handler is called.
            </summary>
      <typeparam name="TMessage">The mesage type of the port.</typeparam>
      <param name="space">The XcoAppSpace.</param>
      <param name="port">The port from which the messages should be received.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.Receive``1(XcoAppSpaces.Core.IXcoAppSpace,Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Creates a port and binds it to the given handler for receiving messages. Whenever an element is posted to 
            the port, the given handler is called.
            </summary>
      <typeparam name="T">The message type of the port.</typeparam>
      <param name="space">The XcoAppSpace.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
      <returns>The created port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.ReceiveSequentially``1(XcoAppSpaces.Core.IXcoAppSpace,Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Creates a port and binds it to the given handler for receiving messages. Whenever an element is posted to 
            the port, the given handler is called. Messages are received sequentially, meaning that the next message 
            is received only after processing of the previous one has been finished.
            </summary>
      <typeparam name="T">The message type of the port.</typeparam>
      <param name="space">The XcoAppSpace.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
      <returns>The created port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.Receive``1(XcoAppSpaces.Core.IXcoAppSpace,Microsoft.Ccr.Core.Handler{``0},XcoAppSpaces.Core.SyncContext)">
      <summary>
            Creates a port and binds it to the given handler for receiving messages. Whenever an element is posted to 
            the port, the given handler is called.
            </summary>
      <typeparam name="T">The message type of the port.</typeparam>
      <param name="space">The XcoAppSpace.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
      <param name="syncContext">Specifies the synchronization context that is used for processing the messages.</param>
      <returns>The created port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.ReceiveSequentially``1(XcoAppSpaces.Core.IXcoAppSpace,Microsoft.Ccr.Core.Handler{``0},XcoAppSpaces.Core.SyncContext)">
      <summary>
            Creates a port and binds it to the given handler for receiving messages. Whenever an element is posted to 
            the port, the given handler is called. Messages are received sequentially, meaning that the next message 
            is received only after processing of the previous one has been finished.
            </summary>
      <typeparam name="T">The message type of the port.</typeparam>
      <param name="space">The XcoAppSpace.</param>
      <param name="handler">The method to be called when a message is received from the port.</param>
      <param name="syncContext">Specifies the synchronization context that is used for processing the messages.</param>
      <returns>The created port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.ReceiveJoined``2(XcoAppSpaces.Core.IXcoAppSpace,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Port{``1},Microsoft.Ccr.Core.Handler{``0,``1})">
      <summary>
            Receive messages from the given ports. Whenever an element is available in both ports, the given handler is called.
            </summary>
      <typeparam name="T1">The mesage type of port 1.</typeparam>
      <typeparam name="T2">The mesage type of port 2.</typeparam>
      <param name="space">The XcoAppSpace.</param>
      <param name="port1">First port from which the messages should be received.</param>
      <param name="port2">Second port from which the messages should be received.</param>
      <param name="handler">The method to be called when a message is received from both ports.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.ReceiveJoined``2(XcoAppSpaces.Core.IXcoAppSpace,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Port{``1},Microsoft.Ccr.Core.Handler{``0,``1},XcoAppSpaces.Core.SyncContext)">
      <summary>
            Receive messages from the given ports. Whenever an element is available in both ports, the given handler is called.
            </summary>
      <typeparam name="T1">The mesage type of port 1.</typeparam>
      <typeparam name="T2">The mesage type of port 2.</typeparam>
      <param name="space">The XcoAppSpace.</param>
      <param name="port1">First port from which the messages should be received.</param>
      <param name="port2">Second port from which the messages should be received.</param>
      <param name="handler">The method to be called when a message is received from both ports.</param>
      <param name="syncContext">Specifies the synchronization context that is used for processing the messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.ReceiveChoice``2(XcoAppSpaces.Core.IXcoAppSpace,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Port{``1},Microsoft.Ccr.Core.Handler{``0},Microsoft.Ccr.Core.Handler{``1})">
      <summary>
            When a messages is received from one of the given ports, the specific handler is called. The choice is taken only for
            the first element to arrive in one of the two ports.
            </summary>
      <typeparam name="T1">The mesage type of port 1.</typeparam>
      <typeparam name="T2">The mesage type of port 2.</typeparam>
      <param name="space">The XcoAppSpace.</param>
      <param name="port1">First port for the choice.</param>
      <param name="port2">Second port for the choice.</param>
      <param name="handler1">The method to be called when a message arrives in the first port.</param>
      <param name="handler2">The method to be called when a message arrives in the second port.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.ReceiveChoice``2(XcoAppSpaces.Core.IXcoAppSpace,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Port{``1},Microsoft.Ccr.Core.Handler{``0},Microsoft.Ccr.Core.Handler{``1},XcoAppSpaces.Core.SyncContext)">
      <summary>
            When a messages is received from one of the given ports, the specific handler is called. The choice is taken only for
            the first element to arrive in one of the two ports.
            </summary>
      <typeparam name="T1">The mesage type of port 1.</typeparam>
      <typeparam name="T2">The mesage type of port 2.</typeparam>
      <param name="space">The XcoAppSpace.</param>
      <param name="port1">First port for the choice.</param>
      <param name="port2">Second port for the choice.</param>
      <param name="handler1">The method to be called when a message arrives in the first port.</param>
      <param name="handler2">The method to be called when a message arrives in the second port.</param>
      <param name="syncContext">Specifies the synchronization context that is used for processing the messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.Run``1(XcoAppSpaces.Core.IXcoAppSpace,System.String,Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Runs a single port with the given type.
            </summary>
      <typeparam name="T">The type of the port.</typeparam>
      <param name="space">The space.</param>
      <param name="name">The name of the port.</param>
      <param name="handler">The handler that should be executed for incoming items.</param>
      <returns>The port that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.Run``1(XcoAppSpaces.Core.IXcoAppSpace,Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Runs a single port with the given type.
            </summary>
      <typeparam name="T">The type of the port.</typeparam>
      <param name="space">The space.</param>
      <param name="handler">The handler that should be executed for incoming items.</param>
      <returns>The port that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.Connect``1(XcoAppSpaces.Core.IXcoAppSpace,System.String)">
      <summary>
            Connects to a single port with the given type.
            </summary>
      <typeparam name="T">The type of the port.</typeparam>
      <param name="space">The space.</param>
      <param name="address">The address of the port.</param>
      <returns>Proxy for posting messages to the port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpaceExtensions.CreateTimedAction(XcoAppSpaces.Core.IXcoAppSpace,System.TimeSpan,System.Func{XcoAppSpaces.Core.XcoTimedAction.Continuation})">
      <summary>
            Creates a timed action with the given space, interval and action.
            </summary>
      <param name="space">The XcoAppSpace.</param>
      <param name="interval">Timer interval.</param>
      <param name="action">The action that should be invoked.</param>
      <returns>The created XcoTimedAction object. Call Invoke() or InvokeDelayed() to start the timed action. </returns>
    </member>
    <member name="T:XcoAppSpaces.Core.CausalityHelpers">
      <summary>
            Helper methods for getting and setting the current causalities.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.LocalWorkerRegistry">
      <summary>
            Wrapper class for access to the local workers by the Core.Communication components.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.PortReceiveHelpers">
      <summary>
            Helpers for installing different kinds of CCR receivers on ports.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.GeneralFluentConfigExtensions">
      <summary>
            Defines general configuration extensions (which are not specific to a certain service implementation).
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.GeneralFluentConfigExtensions.WithSerializer``1(XcoAppSpaces.Core.XcoFluentServiceConfig{``0},System.String)">
      <summary>
            Defines a certain serializer to be used with the given transport service.
            </summary>
      <typeparam name="T">The type of the transport service.</typeparam>
      <param name="config">The configuration object.</param>
      <param name="serializerName">The name of the serializer to be mapped with the transport service.</param>
      <returns>The configuration object for further configuration with the fluent interface.</returns>
    </member>
    <member name="T:XcoAppSpaces.Core.IXcoFluentConfiguration">
      <summary>
            Fluent interface for creating an XcoAppSpace.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoFluentConfiguration.Create">
      <summary>
            Creates an XcoAppSpace with the given configuration.
            </summary>
      <returns>A new XcoAppSpace instance.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoFluentConfiguration.UsingCcrDispatcher(Microsoft.Ccr.Core.Dispatcher)">
      <summary>
            Defines the CCR dispatcher that the XcoAppSpace should use (if not defined, the XcoAppSpace uses its own CCR dispatcher).
            </summary>
      <param name="ccrDispatcher">The CCR Dispatcher that the XcoAppSpace should use.</param>
      <returns>The given XcoAppSpaceConfiguration instance.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoFluentConfiguration.UsingService``1(``0)">
      <summary>
            Defines a service that the XcoAppSpace should use (if not defined, the default for this type of service is used). An
            exception is thrown if the type of service is unknown.
            </summary>
      <param name="service">The service that the XcoAppSpace should use.</param>
      <returns>An XcoFluentServiceConfiguration instance to configure the service.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoFluentConfiguration.UsingService``1">
      <summary>
            Defines a service that the XcoAppSpace should use (if not defined, the default for this type of service is used). An
            exception is thrown if the type of service is unknown. A new service of the given type is instantiated. The given type
            must have a parameterless constructor.
            </summary>
      <returns>An XcoFluentServiceConfiguration instance to configure the service.</returns>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoFluentAppSpaceConfig">
      <summary>
            Fluent interface for creating an XcoAppSpace.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentAppSpaceConfig.#ctor(System.String)">
      <summary>
            Creates a new XcoAppSpaceConfig using a given config string.
            </summary>
      <param name="configString">The config string that should be used.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentAppSpaceConfig.#ctor">
      <summary>
            Creates a new XcoAppSpaceConfig.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentAppSpaceConfig.Create">
      <summary>
            Creates an XcoAppSpace with the given configuration.
            </summary>
      <returns>A new XcoAppSpace instance.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentAppSpaceConfig.UsingCcrDispatcher(Microsoft.Ccr.Core.Dispatcher)">
      <summary>
            Defines the CCR dispatcher that the XcoAppSpace should use (if not defined, the XcoAppSpace uses its own CCR dispatcher).
            </summary>
      <param name="ccrDispatcher">The CCR Dispatcher that the XcoAppSpace should use.</param>
      <returns>The given XcoAppSpaceConfiguration instance.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentAppSpaceConfig.UsingService``1(``0)">
      <summary>
            Defines a service that the XcoAppSpace should use (if not defined, the default for this type of service is used). An
            exception is thrown if the type of service is unknown.
            </summary>
      <param name="service">The service that the XcoAppSpace should use.</param>
      <returns>An XcoFluentServiceConfiguration instance to configure the service.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentAppSpaceConfig.UsingService``1">
      <summary>
            Defines a certain service instance that should be used by the space. A new service of the given 
            type is instantiated. The given type must have a parameterless constructor.
            </summary>
      <typeparam name="TS">The type of the service.</typeparam>
      <returns>A configuration object that can be used to configure this service instance.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentAppSpaceConfig.op_Implicit(XcoAppSpaces.Core.XcoFluentAppSpaceConfig)~XcoAppSpaces.Core.XcoAppSpace">
      <summary>
            Creates an XcoAppSpace instance from the given configuration object.
            </summary>
      <param name="config">The configuration object.</param>
      <returns>The created XcoAppSpace instance.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentAppSpaceConfig.InitServiceRegistry(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Initializes a service registry instance by adding all services that are configured in 
            this XcoAppSpaceConfig instance.
            </summary>
      <param name="reg">The service registry that should be initialized.</param>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoFluentServiceConfig`1">
      <summary>
            Fluent interface for creating an XcoAppSpace and configuring a communication service.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentServiceConfig`1.WithName(System.String)">
      <summary>
            Defines the name of the service. (The name must be unique among all service
            instances of the same type, e.g. among all transport services.)
            </summary>
      <param name="name">The name of the communication service.</param>
      <returns>The given XcoServiceConfig instance.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentServiceConfig`1.AsDefault">
      <summary>
            Defines the service to be the default for the space.
            </summary>
      <returns>The given XcoServiceConfig instance.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentServiceConfig`1.Create">
      <summary>
            Creates a new XcoAppSpace instance with the given configuration.
            </summary>
      <returns>A new XcoAppSpace instance.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentServiceConfig`1.UsingCcrDispatcher(Microsoft.Ccr.Core.Dispatcher)">
      <summary>
            Defines the ccr dispatcher instance that should be used by the space.
            </summary>
      <param name="ccrDispatcher">The ccr dispatcher instance.</param>
      <returns>The given configuration object for further configuration of the space.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentServiceConfig`1.UsingService``1(``0)">
      <summary>
            Defines a certain service instance that should be used by the space.
            </summary>
      <typeparam name="TS">The type of the service.</typeparam>
      <param name="service">The service instance.</param>
      <returns>A configuration object that can be used to configure this service instance.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentServiceConfig`1.UsingService``1">
      <summary>
            Defines a certain service instance that should be used by the space. A new service of the given 
            type is instantiated. The given type must have a parameterless constructor.
            </summary>
      <typeparam name="TS">The type of the service.</typeparam>
      <returns>A configuration object that can be used to configure this service instance.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoFluentServiceConfig`1.op_Implicit(XcoAppSpaces.Core.XcoFluentServiceConfig{`0})~XcoAppSpaces.Core.XcoAppSpace">
      <summary>
            Operator that creates an XcoAppSpace instance from the given configuration object.
            </summary>
      <param name="config">The configuration object.</param>
      <returns>The created XcoAppSpace instance.</returns>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoFluentServiceConfig`1.Service">
      <summary>
            The service that is getting configured.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoFluentServiceConfig`1.ServiceConfig">
      <summary>
            Additional service configuration information like service name and mappings.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoFluentServiceConfig`1.FluentConfig">
      <summary>
            The configuration itself.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.Unsubscribe">
      <summary>
            Non-generic base class for unsubscribing from events that are published by workers
            using the XcoPublisher class.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.Unsubscribe`1">
      <summary>
            Class for unsubscribing from events that are published by workers
            using the XcoPublisher class.
            </summary>
      <typeparam name="T">The type of event.</typeparam>
    </member>
    <member name="M:XcoAppSpaces.Core.Unsubscribe`1.#ctor(Microsoft.Ccr.Core.Port{`0})">
      <summary>
            Creates a new Unsubscribe message.
            </summary>
      <param name="eventPort">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.Unsubscribe`1.#ctor(Microsoft.Ccr.Core.IPort)">
      <summary>
            Creates a new Unsubscribe message.
            </summary>
      <param name="eventPort">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.Unsubscribe`1.#ctor">
      <summary>
            Creates a new Unsubscribe message.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Unsubscribe`1.EventPort">
      <summary>
            The port that should be unsubscribed.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.Subscribe">
      <summary>
            Non-generic base class for subscribing to events that are published by workers
            using the XcoPublisher class.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.Subscribe`1">
      <summary>
            Class for Subscribing to events that are published by workers
            using the XcoPublisher class.
            </summary>
      <typeparam name="T">The type of event.</typeparam>
    </member>
    <member name="M:XcoAppSpaces.Core.Subscribe`1.#ctor">
      <summary>
            Creates a new Subscribe message.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.Subscribe`1.#ctor(Microsoft.Ccr.Core.Port{`0})">
      <summary>
            Creates a new Subscribe message.
            </summary>
      <param name="eventPort">The port that should be subscribed to receive events.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.Subscribe`1.#ctor(Microsoft.Ccr.Core.IPort)">
      <summary>
            Creates a new Subscribe message.
            </summary>
      <param name="eventPort">The port that should be subscribed to receive events.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.Subscribe`1.#ctor(Microsoft.Ccr.Core.Port{`0},System.Linq.Expressions.Expression{System.Predicate{`0}})">
      <summary>
            Creates a new Subscribe message.
            </summary>
      <param name="eventPort">The port that should be subscribed to receive events.</param>
      <param name="filterExpr">Predicate that can be used for filtering the event messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.Subscribe`1.#ctor(Microsoft.Ccr.Core.IPort,System.Linq.Expressions.Expression{System.Predicate{`0}})">
      <summary>
            Creates a new Subscribe message.
            </summary>
      <param name="eventPort">The port that should be subscribed to receive events.</param>
      <param name="filterExpr">Predicate that can be used for filtering the event messages.</param>
    </member>
    <member name="P:XcoAppSpaces.Core.Subscribe`1.EventPort">
      <summary>
            The port that should be subscribed to to receive events.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Subscribe`1.FilterExpr">
      <summary>
            The expression that is used for filtering published messages.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoSpaceInfo">
      <summary>
            Class that presents meta information about the space.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoSpaceInfo.Workers">
      <summary>
            Information about the workers of this space instance.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoSpaceInfo.ServiceRegistry">
      <summary>
            The service registry of the space, allowing access to all its running services.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoSpaceInfo.TransportServices">
      <summary>
            Information about the communication services of this space instance.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoSpaceInfo.SecurityService">
      <summary>
            The security service that is used by this space instance.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoSpaceInfo.CommunicationEvents">
      <summary>
            Events giving information about incoming and outgoing communication, e.g. for monitoring
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.IXcoAppSpace">
      <summary>
            Interface definition for the XcoAppSpace class, the main class of XcoAppSpaces.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.Resolve``1">
      <summary>
            Resolves an instance of the requested type with the given name from the local appspace.
            </summary>
      <typeparam name="TContract">The type that is requested.</typeparam>
      <returns>The resolved object.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.Resolve``1(System.String)">
      <summary>
            Resolves worker of the requested type with the given name from the local appspace.
            </summary>
      <typeparam name="TContract">The type that is requested.</typeparam>
      <param name="name">The name of the object to retreive.</param>
      <returns>The resolved object.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.RunWorker``2">
      <summary>
            Runs a worker within the appspace. The worker is published so other appspace instances can connect to it.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <typeparam name="TImplementation">The implementation type of the worker (which must inherit from the contract type).</typeparam>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.RunWorker``2(System.String)">
      <summary>
            Runs a worker within the appspace. The worker is published so other appspace instances can connect to it.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <typeparam name="TImplementation">The implementation type of the worker (which must inherit from the contract type).</typeparam>
      <param name="name">The name under which the worker should be registered.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.RunWorker``2(XcoAppSpaces.Contracts.Worker.PublishMode)">
      <summary>
            Runs a worker within the appspace.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <typeparam name="TImplementation">The implementation type of the worker (which must inherit from the contract type).</typeparam>
      <param name="publish">Defines if the worker should be published so other appspace instances can connnect to it.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.RunWorker``2(XcoAppSpaces.Contracts.Worker.PublishMode,System.String)">
      <summary>
            Runs a worker within the appspace.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <typeparam name="TImplementation">The implementation type of the worker (which must inherit from the contract type).</typeparam>
      <param name="publish">Defines if the worker should be published so other appspace instances can connnect to it.</param>
      <param name="name">The name under which the worker should be registered.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.RunWorker``2(XcoAppSpaces.Contracts.Worker.PublishMode,System.String,Microsoft.Ccr.Core.DispatcherQueue)">
      <summary>
            Runs a worker within the appspace.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <typeparam name="TImplementation">The implementation type of the worker (which must inherit from the contract type).</typeparam>
      <param name="publish">Defines if the worker should be published so other appspace instances can connnect to it.</param>
      <param name="name">The name under which the worker should be registered.</param>
      <param name="queue">The CCR dispatcher queue that should be used, or null if the appspace's default dispatcher queue should be used.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.RunWorker``1(``0)">
      <summary>
            Runs a worker within the appspace.  The worker is published so other appspace instances can connect to it.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.RunWorker``1(``0,System.String)">
      <summary>
            Runs a worker within the appspace.  The worker is published so other appspace instances can connect to it.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <param name="worker">The worker instance to run.</param>
      <param name="name">The name under which the worker should be registered.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.RunWorker``1(``0,XcoAppSpaces.Contracts.Worker.PublishMode)">
      <summary>
            Runs a worker within the appspace. 
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <param name="worker">The worker instance to run.</param>
      <param name="publish">Defines if the worker should be published so other appspace instances can connnect to it.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.RunWorker``1(``0,XcoAppSpaces.Contracts.Worker.PublishMode,System.String)">
      <summary>
            Runs a worker within the appspace.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <param name="worker">The worker instance to run.</param>
      <param name="publish">Defines if the worker should be published so other appspace instances can connnect to it.</param>
      <param name="name">The name under which the worker should be registered.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.RunWorker``1(``0,XcoAppSpaces.Contracts.Worker.PublishMode,System.String,Microsoft.Ccr.Core.DispatcherQueue)">
      <summary>
            Runs a worker within the appspace.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <param name="worker">The worker instance to run.</param>
      <param name="publish">Defines if the worker should be published so other appspace instances can connnect to it.</param>
      <param name="name">The name under which the worker should be registered.</param>
      <param name="queue">The CCR dispatcher queue that should be used, or null if the appspace's default dispatcher queue should be used.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.StopWorker(Microsoft.Ccr.Core.IPort)">
      <summary>
            Disposes the given worker instance and removes it from the appspace.
            </summary>
      <param name="worker">The worker to be removed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.StopWorker``1">
      <summary>
            Disposes a worker instance and removes it from the appspace.
            </summary>
      <typeparam name="TMessageContract">The type of the worker.</typeparam>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.StopWorker``1(System.String)">
      <summary>
            Disposes a worker instance and removes it from the appspace.
            </summary>
      <typeparam name="TMessageContract">The type of the worker.</typeparam>
      <param name="name">The name of the worker.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.ConnectWorker``1(System.String)">
      <summary>
            Establishes a connection to a worker that is running at a remote space, and registers
            the worker at the local space.  After ConnectWorker is called, the worker to which the
            connection has been established is also available through the appspace's Resolve method.
            This method allows using addresses that are not displayable with a "hostname:port" pattern.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="workerAddress">The address of the worker in form "address/workername"</param>
      <returns>A worker contract instance that allows to post messages to the remote worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.ConnectWorker``1(System.String,System.String)">
      <summary>
            Establishes a connection to a worker that is running at a remote space, and registers
            the worker at the local space. After ConnectWorker is called, the worker to which the
            connection has been established is also available through the appspace's Resolve method.
            This method allows using addresses that are not displayable with a "hostname:port" pattern.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="workerAddress">The address of the worker in form "address/workername"</param>
      <param name="localName">The name under which the worker should be registered locally.</param>
      <returns>A worker contract instance that allows to post messages to the remote worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.ConnectWorker``1(System.String,System.String,System.String)">
      <summary>
            Establishes a connection to a worker that is running at a remote space, and registers
            the worker at the local space. After ConnectWorker is called, the worker to which the
            connection has been established is also available through the appspace's Resolve method.
            This method allows using addresses that are not displayable with a "hostname:port" pattern.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="commServiceName">The name of the communication service that should be used for communication with the worker.</param>
      <param name="workerAddress">The address of the worker in form "address/workername"</param>
      <param name="localName">The name under which the worker should be registered locally.</param>
      <returns>A worker contract instance that allows to post messages to the remote worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.ConnectWorker``1(XcoAppSpaces.Contracts.Worker.PublishMode,System.String)">
      <summary>
            Establishes a connection to a worker that is running at a remote space, and registers
            the worker at the local space.  After ConnectWorker is called, the worker to which the
            connection has been established is also available through the appspace's Resolve method.
            This method allows using addresses that are not displayable with a "hostname:port" pattern.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="publish">Defines if the created worker proxy should be published so other appspace instances can connnect to it, and by that use the appspace instance to connect to the original worker.</param>
      <param name="workerAddress">The address of the worker in form "address/workername"</param>
      <returns>A worker contract instance that allows to post messages to the remote worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.ConnectWorker``1(XcoAppSpaces.Contracts.Worker.PublishMode,System.String,System.String)">
      <summary>
            Establishes a connection to a worker that is running at a remote space, and registers
            the worker at the local space. After ConnectWorker is called, the worker to which the
            connection has been established is also available through the appspace's Resolve method.
            This method allows using addresses that are not displayable with a "hostname:port" pattern.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="publish">Defines if the created worker proxy should be published so other appspace instances can connnect to it, and by that use the appspace instance to connect to the original worker.</param>
      <param name="workerAddress">The address of the worker in form "address/workername"</param>
      <param name="localName">The name under which the worker should be registered locally.</param>
      <returns>A worker contract instance that allows to post messages to the remote worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.IXcoAppSpace.ConnectWorker``1(XcoAppSpaces.Contracts.Worker.PublishMode,System.String,System.String,System.String)">
      <summary>
            Establishes a connection to a worker that is running at a remote space, and registers
            the worker at the local space. After ConnectWorker is called, the worker to which the
            connection has been established is also available through the appspace's Resolve method.
            This method allows using addresses that are not displayable with a "hostname:port" pattern.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="publish">Defines if the created worker proxy should be published so other appspace instances can connnect to it, and by that use the appspace instance to connect to the original worker.</param>
      <param name="commServiceName">The name of the communication service that should be used for communication with the worker.</param>
      <param name="workerAddress">The address of the worker in form "address/workername"</param>
      <param name="localName">The name under which the worker should be registered locally.</param>
      <returns>A worker contract instance that allows to post messages to the remote worker.</returns>
    </member>
    <member name="P:XcoAppSpaces.Core.IXcoAppSpace.Info">
      <summary>
            Provides meta information about the XcoAppSpace instance, e.g. information about 
            running workers and communication services.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.IXcoAppSpace.Credentials">
      <summary>
            The credentials that are used by the space to connect to remote workers.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.IXcoAppSpace.DefaultDispatcher">
      <summary>
            The CCR dispatcher that is used by the appspace.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.IXcoAppSpace.DefaultDispatcherQueue">
      <summary>
            The CCR dispatcher queue taht is used by the appspace.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.IXcoAppSpace.Address">
      <summary>
            The address of the space (that can be used by other spaces to connect to this space)
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.IXcoAppSpace.Errors">
      <summary>
            Port where errors are posted that occur during commmunication with Fother space instances
            and that have not been caught by causalities (e.g. errors during message deserialization 
            or security errors).
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoTimedAction">
      <summary>
            Represents a timed action that is executed with a ccr timer port.
            Call Invoke() or InvokeDelayed() to start the timed action.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoTimedAction.Continuation">
      <summary>
            Continuation action for the timed action.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoTimedAction.#ctor(Microsoft.Ccr.Core.DispatcherQueue,System.TimeSpan,System.Func{XcoAppSpaces.Core.XcoTimedAction.Continuation})">
      <summary>
            Creates a new XcoTimedAction.
            </summary>
      <param name="dpq">The dispatcher queue that should be used for the timer (the queue's EnqueueTimer method is used).</param>
      <param name="interval">The timer interval.</param>
      <param name="action">The action that should be executed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoTimedAction.Invoke">
      <summary>
            Asynchronously starts the timer without delay.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoTimedAction.InvokeDelayed">
      <summary>
            Asynchonously starts the timer, using the predefined timer interval as delay.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoTimedAction.Dispose">
      <summary>
            Disposes the XcoTimedAction.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoAppSpace">
      <summary>
            The main class of XcoAppSpaces. XcoAppSpace represents the application space
            and allows running workers, as well as resolving worker that have already been
            started and connecting to workers running at a remote space. It also provides
            basic dependency injection container functionality.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.#ctor">
      <summary>
            Creates a new XcoAppSpace without remote communication functionality.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.#ctor(System.String)">
      <summary>
            Creates a new XcoAppSpace by using the given config string.
            </summary>
      <param name="configString">The config string to configure the appspace instance.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.#ctor(XcoAppSpaces.Core.Configuration.IXcoConfiguration)">
      <summary>
            Creates a new XcoAppSpace by using the given configuration.
            </summary>
      <param name="config">
      </param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.Resolve``1">
      <summary>
            Resolves an instance of the requested type with the given name from the local appspace.
            </summary>
      <typeparam name="TContract">The type that is requested.</typeparam>
      <returns>The resolved object.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.Resolve``1(System.String)">
      <summary>
            Resolves worker of the requested type with the given name from the local appspace.
            </summary>
      <typeparam name="TContract">The type that is requested.</typeparam>
      <param name="name">The name of the object to retreive.</param>
      <returns>The resolved object.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.RunWorker``2">
      <summary>
            Runs a worker within the appspace. The worker is published so other appspace instances can connect to it.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <typeparam name="TImplementation">The implementation type of the worker (which must inherit from the contract type).</typeparam>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.RunWorker``2(System.String)">
      <summary>
            Runs a worker within the appspace. The worker is published so other appspace instances can connect to it.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <typeparam name="TImplementation">The implementation type of the worker (which must inherit from the contract type).</typeparam>
      <param name="name">The name under which the worker should be registered.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.RunWorker``2(XcoAppSpaces.Contracts.Worker.PublishMode)">
      <summary>
            Runs a worker within the appspace.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <typeparam name="TImplementation">The implementation type of the worker (which must inherit from the contract type).</typeparam>
      <param name="publish">Defines if the worker should be published so other appspace instances can connnect to it.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.RunWorker``2(XcoAppSpaces.Contracts.Worker.PublishMode,System.String)">
      <summary>
            Runs a worker within the appspace.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <typeparam name="TImplementation">The implementation type of the worker (which must inherit from the contract type).</typeparam>
      <param name="publish">Defines if the worker should be published so other appspace instances can connnect to it.</param>
      <param name="name">The name under which the worker should be registered.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.RunWorker``2(XcoAppSpaces.Contracts.Worker.PublishMode,System.String,Microsoft.Ccr.Core.DispatcherQueue)">
      <summary>
            Runs a worker within the appspace.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <typeparam name="TImplementation">The implementation type of the worker (which must inherit from the contract type).</typeparam>
      <param name="publishMode">Defines if the worker should be published so other appspace instances can connnect to it.</param>
      <param name="name">The name under which the worker should be registered.</param>
      <param name="queue">The CCR dispatcher queue that should be used, or null if the appspace's default dispatcher queue should be used.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.RunWorker``1(``0)">
      <summary>
            Runs a worker within the appspace.  The worker is published so other appspace instances can connect to it.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.RunWorker``1(``0,System.String)">
      <summary>
            Runs a worker within the appspace.  The worker is published so other appspace instances can connect to it.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <param name="worker">The worker instance to run.</param>
      <param name="name">The name under which the worker should be registered.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.RunWorker``1(``0,XcoAppSpaces.Contracts.Worker.PublishMode)">
      <summary>
            Runs a worker within the appspace. 
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <param name="worker">The worker instance to run.</param>
      <param name="publish">Defines if the worker should be published so other appspace instances can connnect to it.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.RunWorker``1(``0,XcoAppSpaces.Contracts.Worker.PublishMode,System.String)">
      <summary>
            Runs a worker within the appspace.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <param name="worker">The worker instance to run.</param>
      <param name="publish">Defines if the worker should be published so other appspace instances can connnect to it.</param>
      <param name="name">The name under which the worker should be registered.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.RunWorker``1(``0,XcoAppSpaces.Contracts.Worker.PublishMode,System.String,Microsoft.Ccr.Core.DispatcherQueue)">
      <summary>
            Runs a worker within the appspace.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker, which must be an IPort (meaning it must be a CCR Port or PortSet).</typeparam>
      <param name="worker">The worker instance to run.</param>
      <param name="publish">Defines if the worker should be published so other appspace instances can connnect to it.</param>
      <param name="name">The name under which the worker should be registered.</param>
      <param name="queue">The CCR dispatcher queue that should be used, or null if the appspace's default dispatcher queue should be used.</param>
      <returns>The worker instance that has been created.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.StopWorker(Microsoft.Ccr.Core.IPort)">
      <summary>
            Disposes the given worker instance and removes it from the appspace.
            </summary>
      <param name="worker">The worker to be removed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.StopWorker``1">
      <summary>
            Disposes a worker instance and removes it from the appspace.
            </summary>
      <typeparam name="TMessageContract">The type of the worker.</typeparam>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.StopWorker``1(System.String)">
      <summary>
            Disposes a worker instance and removes it from the appspace.
            </summary>
      <typeparam name="TMessageContract">The type of the worker.</typeparam>
      <param name="name">The name of the worker.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.ConnectWorker``1(System.String)">
      <summary>
            Establishes a connection to a worker that is running at a remote space, and registers
            the worker at the local space.  After ConnectWorker is called, the worker to which the
            connection has been established is also available through the appspace's Resolve method.
            This method allows using addresses that are not displayable with a "hostname:port" pattern.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="workerAddress">The address of the worker in form "address/workername"</param>
      <returns>A worker contract instance that allows to post messages to the remote worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.ConnectWorker``1(System.String,System.String)">
      <summary>
            Establishes a connection to a worker that is running at a remote space, and registers
            the worker at the local space. After ConnectWorker is called, the worker to which the
            connection has been established is also available through the appspace's Resolve method.
            This method allows using addresses that are not displayable with a "hostname:port" pattern.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="workerAddress">The address of the worker in form "address/workername"</param>
      <param name="localName">The name under which the worker should be registered locally.</param>
      <returns>A worker contract instance that allows to post messages to the remote worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.ConnectWorker``1(System.String,System.String,System.String)">
      <summary>
            Establishes a connection to a worker that is running at a remote space, and registers
            the worker at the local space. After ConnectWorker is called, the worker to which the
            connection has been established is also available through the appspace's Resolve method.
            This method allows using addresses that are not displayable with a "hostname:port" pattern.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="commServiceName">The name of the communication service that should be used for communication with the worker.</param>
      <param name="workerAddress">The address of the worker in form "address/workername"</param>
      <param name="localName">The name under which the worker should be registered locally.</param>
      <returns>A worker contract instance that allows to post messages to the remote worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.ConnectWorker``1(XcoAppSpaces.Contracts.Worker.PublishMode,System.String)">
      <summary>
            Establishes a connection to a worker that is running at a remote space, and registers
            the worker at the local space.  After ConnectWorker is called, the worker to which the
            connection has been established is also available through the appspace's Resolve method.
            This method allows using addresses that are not displayable with a "hostname:port" pattern.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="publish">Defines if the created worker proxy should be published so other appspace instances can connnect to it, and by that use the appspace instance to connect to the original worker.</param>
      <param name="workerAddress">The address of the worker in form "address/workername"</param>
      <returns>A worker contract instance that allows to post messages to the remote worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.ConnectWorker``1(XcoAppSpaces.Contracts.Worker.PublishMode,System.String,System.String)">
      <summary>
            Establishes a connection to a worker that is running at a remote space, and registers
            the worker at the local space. After ConnectWorker is called, the worker to which the
            connection has been established is also available through the appspace's Resolve method.
            This method allows using addresses that are not displayable with a "hostname:port" pattern.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="publish">Defines if the created worker proxy should be published so other appspace instances can connnect to it, and by that use the appspace instance to connect to the original worker.</param>
      <param name="workerAddress">The address of the worker in form "address/workername"</param>
      <param name="localName">The name under which the worker should be registered locally.</param>
      <returns>A worker contract instance that allows to post messages to the remote worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.ConnectWorker``1(XcoAppSpaces.Contracts.Worker.PublishMode,System.String,System.String,System.String)">
      <summary>
            Establishes a connection to a worker that is running at a remote space, and registers
            the worker at the local space. After ConnectWorker is called, the worker to which the
            connection has been established is also available through the appspace's Resolve method.
            This method allows using addresses that are not displayable with a "hostname:port" pattern.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="publishMode">Defines if the created worker proxy should be published so other appspace instances can connnect to it, and by that use the appspace instance to connect to the original worker.</param>
      <param name="commServiceName">The name of the communication service that should be used for communication with the worker.</param>
      <param name="workerAddress">The address of the worker in form "address/workername"</param>
      <param name="localName">The name under which the worker should be registered locally.</param>
      <returns>A worker contract instance that allows to post messages to the remote worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.Dispose">
      <summary>
            Closes the appspace and disposes the CCR dispatcher if it was not handed in at startup.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoAppSpace.ConfigureWithConfigString(System.String)">
      <summary>
            Initializes the XcoAppSpace using the given config string.
            </summary>
      <param name="configString">The config string that should be used for initialization of the space.</param>
      <returns>An XcoAppSpaceConfiguration instance for further configuration of the space.</returns>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoAppSpace.Info">
      <summary>
            Provides meta information about the XcoAppSpace instance, e.g. information about 
            running workers and communication services.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoAppSpace.Credentials">
      <summary>
            The credentials that are used by the space to connect to remote workers.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoAppSpace.DefaultDispatcher">
      <summary>
            The CCR dispatcher that is used by the appspace.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoAppSpace.DefaultDispatcherQueue">
      <summary>
            The CCR dispatcher queue that is used by the appspace.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoAppSpace.Address">
      <summary>
            The address of the space (that can be used by other spaces to connect to this space)
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoAppSpace.Errors">
      <summary>
            Port where errors are posted that occur during commmunication with other space instances
            and that have not been caught by causalities (e.g. errors during message deserialization 
            or security errors).
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoAppSpace.Configure">
      <summary>
            Returns an XcoAppSpaceConfig object for configuring and creating a new space instance.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoPublisher">
      <summary>
            The XcoPublisher manages a list of subscriptions in form of ports. It handles the
            processing of Subscribe and Unsubscribe messages, and the publishing messages
            to all subscribed ports.
            Is the base class for all generic XcoPublisher classes.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher.PublishUnknownType(System.Object)">
      <summary>
            Tries to publish a message of unknown type. An exception is thrown if the type
            of message is not supported by the XcoPublisher instance.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher.PublishWithType``1(``0)">
      <summary>
            Tries to publish a message with the given type. An exception is thrown if the type
            of message is not supported by the XcoPublisher instance.
            </summary>
      <param name="msg">The message to be published.</param>
      <typeparam name="T">The type under which the message should be published (msg must be assignable to this type).</typeparam>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoPublisher`1">
      <summary>
            The XcoPublisher is a worker extension that manages a list of subscriptions in 
            form of ports. It handles the processing of Subscribe and Unsubscribe messages, 
            and provides methods to publish messages to all subscribed ports.
            The the message types that can be published are defined by the XcoPublisher's
            generic types.
            </summary>
      <typeparam name="T">The type of message to be published.</typeparam>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`1.#ctor">
      <summary>
            Creates a new XcoPublisher.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`1.Publish(`0)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`1.Subscribe(Microsoft.Ccr.Core.Port{`0})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`1.Subscribe(Microsoft.Ccr.Core.Port{`0},System.Linq.Expressions.Expression{System.Predicate{`0}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`1.Unsubscribe(Microsoft.Ccr.Core.Port{`0})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoPublisher`2">
      <summary>
            The XcoPublisher is a worker extension that manages a list of subscriptions in 
            form of ports. It handles the processing of Subscribe and Unsubscribe messages, 
            and provides methods to publish messages to all subscribed ports.
            The the message types that can be published are defined by the XcoPublisher's
            generic types.
            </summary>
      <typeparam name="T0">The first message type to be published.</typeparam>
      <typeparam name="T1">The second message type to be published.</typeparam>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`2.#ctor">
      <summary>
            Creates a new XcoPublisher.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`2.Publish(`0)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`2.Publish(`1)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`2.Subscribe(Microsoft.Ccr.Core.Port{`0})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`2.Unsubscribe(Microsoft.Ccr.Core.Port{`0})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`2.Subscribe(Microsoft.Ccr.Core.Port{`1})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`2.Unsubscribe(Microsoft.Ccr.Core.Port{`1})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`2.Subscribe(Microsoft.Ccr.Core.Port{`0},System.Linq.Expressions.Expression{System.Predicate{`0}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`2.Subscribe(Microsoft.Ccr.Core.Port{`1},System.Linq.Expressions.Expression{System.Predicate{`1}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoPublisher`3">
      <summary>
            The XcoPublisher is a worker extension that manages a list of subscriptions in 
            form of ports. It handles the processing of Subscribe and Unsubscribe messages, 
            and provides methods to publish messages to all subscribed ports.
            The the message types that can be published are defined by the XcoPublisher's
            generic types.
            </summary>
      <typeparam name="T0">The first message type to be published.</typeparam>
      <typeparam name="T1">The second message type to be published.</typeparam>
      <typeparam name="T2">The third message type to be published.</typeparam>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`3.#ctor">
      <summary>
            Creates a new XcoPublisher.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`3.Publish(`0)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`3.Publish(`1)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`3.Publish(`2)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`3.Subscribe(Microsoft.Ccr.Core.Port{`0})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`3.Unsubscribe(Microsoft.Ccr.Core.Port{`0})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`3.Subscribe(Microsoft.Ccr.Core.Port{`1})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`3.Unsubscribe(Microsoft.Ccr.Core.Port{`1})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`3.Subscribe(Microsoft.Ccr.Core.Port{`2})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`3.Unsubscribe(Microsoft.Ccr.Core.Port{`2})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`3.Subscribe(Microsoft.Ccr.Core.Port{`0},System.Linq.Expressions.Expression{System.Predicate{`0}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`3.Subscribe(Microsoft.Ccr.Core.Port{`1},System.Linq.Expressions.Expression{System.Predicate{`1}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`3.Subscribe(Microsoft.Ccr.Core.Port{`2},System.Linq.Expressions.Expression{System.Predicate{`2}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoPublisher`4">
      <summary>
            The XcoPublisher is a worker extension that manages a list of subscriptions in 
            form of ports. It handles the processing of Subscribe and Unsubscribe messages, 
            and provides methods to publish messages to all subscribed ports.
            The the message types that can be published are defined by the XcoPublisher's
            generic types.
            </summary>
      <typeparam name="T0">The first message type to be published.</typeparam>
      <typeparam name="T1">The second message type to be published.</typeparam>
      <typeparam name="T2">The third message type to be published.</typeparam>
      <typeparam name="T3">The fourth message type to be published.</typeparam>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.#ctor">
      <summary>
            Creates a new XcoPublisher.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Publish(`0)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Publish(`1)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Publish(`2)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Publish(`3)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Subscribe(Microsoft.Ccr.Core.Port{`0})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Unsubscribe(Microsoft.Ccr.Core.Port{`0})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Subscribe(Microsoft.Ccr.Core.Port{`1})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Unsubscribe(Microsoft.Ccr.Core.Port{`1})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Subscribe(Microsoft.Ccr.Core.Port{`2})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Unsubscribe(Microsoft.Ccr.Core.Port{`2})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Subscribe(Microsoft.Ccr.Core.Port{`3})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Unsubscribe(Microsoft.Ccr.Core.Port{`3})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Subscribe(Microsoft.Ccr.Core.Port{`0},System.Linq.Expressions.Expression{System.Predicate{`0}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Subscribe(Microsoft.Ccr.Core.Port{`1},System.Linq.Expressions.Expression{System.Predicate{`1}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Subscribe(Microsoft.Ccr.Core.Port{`2},System.Linq.Expressions.Expression{System.Predicate{`2}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`4.Subscribe(Microsoft.Ccr.Core.Port{`3},System.Linq.Expressions.Expression{System.Predicate{`3}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoPublisher`5">
      <summary>
            The XcoPublisher is a worker extension that manages a list of subscriptions in 
            form of ports. It handles the processing of Subscribe and Unsubscribe messages, 
            and provides methods to publish messages to all subscribed ports.
            The the message types that can be published are defined by the XcoPublisher's
            generic types.
            </summary>
      <typeparam name="T0">The first message type to be published.</typeparam>
      <typeparam name="T1">The second message type to be published.</typeparam>
      <typeparam name="T2">The third message type to be published.</typeparam>
      <typeparam name="T3">The fourth message type to be published.</typeparam>
      <typeparam name="T4">The fifth message type to be published.</typeparam>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.#ctor">
      <summary>
            Creates a new XcoPublisher.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Publish(`0)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Publish(`1)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Publish(`2)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Publish(`3)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Publish(`4)">
      <summary>
            Publishes the given message to all subscribed ports.
            </summary>
      <param name="msg">The message to be published.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Subscribe(Microsoft.Ccr.Core.Port{`0})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Unsubscribe(Microsoft.Ccr.Core.Port{`0})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Subscribe(Microsoft.Ccr.Core.Port{`1})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Unsubscribe(Microsoft.Ccr.Core.Port{`1})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Subscribe(Microsoft.Ccr.Core.Port{`2})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Unsubscribe(Microsoft.Ccr.Core.Port{`2})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Subscribe(Microsoft.Ccr.Core.Port{`3})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Unsubscribe(Microsoft.Ccr.Core.Port{`3})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Subscribe(Microsoft.Ccr.Core.Port{`4})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Unsubscribe(Microsoft.Ccr.Core.Port{`4})">
      <summary>
            Unsubscribes the given port from receiving published messages.
            </summary>
      <param name="port">The port that should be unsubscribed.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Subscribe(Microsoft.Ccr.Core.Port{`0},System.Linq.Expressions.Expression{System.Predicate{`0}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Subscribe(Microsoft.Ccr.Core.Port{`1},System.Linq.Expressions.Expression{System.Predicate{`1}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Subscribe(Microsoft.Ccr.Core.Port{`2},System.Linq.Expressions.Expression{System.Predicate{`2}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Subscribe(Microsoft.Ccr.Core.Port{`3},System.Linq.Expressions.Expression{System.Predicate{`3}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoPublisher`5.Subscribe(Microsoft.Ccr.Core.Port{`4},System.Linq.Expressions.Expression{System.Predicate{`4}})">
      <summary>
            Subscribes the given port to receive published messages of the given port message type.
            </summary>
      <param name="port">The port that should receive published messages.</param>
      <param name="filterFunc">Predicate that can be used for filtering the published messages.</param>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Exceptions.XcoException">
      <summary>
            XcoException is the base class for all Exceptions thrown in XcoAppSpaces.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoException.#ctor">
      <summary>
            Creates a new XcoException.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoException.#ctor(System.String)">
      <summary>
            Creates a new XcoException.
            </summary>
      <param name="message">The error message.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoException.#ctor(System.String,System.Exception)">
      <summary>
            Creates a new XcoException.
            </summary>
      <param name="message">The error message.</param>
      <param name="innerException">Inner Exception.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Creates a new XcoException. Needed for serialization.
            </summary>
      <param name="info">SerializationInfo for handling type-specific serialization information.</param>
      <param name="context">StreamingContext for handling type-specific serialization information.</param>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Exceptions.XcoSecurityException">
      <summary>
            Exception that is thrown when communication with a worker is not correctly authenticated or authorized.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoSecurityException.#ctor">
      <summary>
            Creates a new XcoSecurityException.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoSecurityException.#ctor(System.String)">
      <summary>
            Creates a new XcoSecurityException.
            </summary>
      <param name="message">The error message.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoSecurityException.#ctor(System.String,System.Exception)">
      <summary>
            Creates a new XcoSecurityException.
            </summary>
      <param name="message">The error message.</param>
      <param name="innerException">The inner exception that has been thrown.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoSecurityException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Creates a new XcoSecurityException. This constructor is needed for serialization.
            </summary>
      <param name="info">SerializationInfo for handling type-specific serialization information.</param>
      <param name="context">StreamingContext for handling type-specific serialization information.</param>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Exceptions.XcoConfigurationException">
      <summary>
            Exception that is thrown when there is an error with the XcoAppSpace configuration.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoConfigurationException.#ctor">
      <summary>
            Creates a new XcoConfigurationException.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoConfigurationException.#ctor(System.String)">
      <summary>
            Creates a new XcoConfigurationException.
            </summary>
      <param name="message">The error message.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoConfigurationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:XcoAppSpaces.Contracts.Exceptions.XcoConfigurationException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="inner">The inner exception.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoConfigurationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Creates a new XcoConfigurationException. This constructor is needed for serialization.
            </summary>
      <param name="info">SerializationInfo for handling type-specific serialization information.</param>
      <param name="context">StreamingContext for handling type-specific serialization information.</param>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Exceptions.XcoWorkerException">
      <summary>
            Exception that is thrown when there is an error instantiating a worker.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoWorkerException.#ctor">
      <summary>
            Creates a new XcoWorkerException.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoWorkerException.#ctor(System.String)">
      <summary>
            Creates a new XcoWorkerException.
            </summary>
      <param name="message">The error message.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoWorkerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Creates a new XcoWorkerException. This constructor is needed for serialization.
            </summary>
      <param name="info">SerializationInfo for handling type-specific serialization information.</param>
      <param name="context">StreamingContext for handling type-specific serialization information.</param>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Exceptions.XcoSubscriptionException">
      <summary>
            Exception that is thrown in case of an error when subscribing to a worker (e.g. the type of message that is subscribed
            to is unknown to the XcoPublisher).
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoSubscriptionException.#ctor">
      <summary>
            Creates a new XcoSubscriptionException.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoSubscriptionException.#ctor(System.String)">
      <summary>
            Creates a new XcoSubscriptionException.
            </summary>
      <param name="message">The error message.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoSubscriptionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Creates a new XcoSubscriptionException. This constructor is needed for serialization.
            </summary>
      <param name="info">SerializationInfo for handling type-specific serialization information.</param>
      <param name="context">StreamingContext for handling type-specific serialization information.</param>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Exceptions.XcoPublishException">
      <summary>
            Exception that is thrown in case of an error when publishing a message (e.g. the type of message to
            be published is unknown by the XcoPublisher).
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoPublishException.#ctor">
      <summary>
            Creates a new XcoPublishException.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoPublishException.#ctor(System.String)">
      <summary>
            Creates a new XcoPublishException.
            </summary>
      <param name="message">The error message.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoPublishException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Creates a new XcoPublishException. This constructor is needed for serialization.
            </summary>
      <param name="info">SerializationInfo for handling type-specific serialization information.</param>
      <param name="context">StreamingContext for handling type-specific serialization information.</param>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Exceptions.XcoCommunicationException">
      <summary>
            Exception that is thrown in case of an error related to remote communication (e.g. problems
            connecting to a remote worker).
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoCommunicationException.#ctor">
      <summary>
            Creates a new XcoCommunicationException.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoCommunicationException.#ctor(System.String)">
      <summary>
            Creates a new XcoCommunicationException.
            </summary>
      <param name="message">The error message.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoCommunicationException.#ctor(System.String,System.Exception)">
      <summary>
            Creates a new XcoCommunicationException.
            </summary>
      <param name="message">The error message.</param>
      <param name="innerException">The inner exception that has been thrown.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoCommunicationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Creates a new XcoCommunicationException. This constructor is needed for serialization.
            </summary>
      <param name="info">SerializationInfo for handling type-specific serialization information.</param>
      <param name="context">StreamingContext for handling type-specific serialization information.</param>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Exceptions.XcoSerializationException">
      <summary>
            Exception that is thrown in case of errors related to serialization or deserialization of messages
            that are sent to other spaces.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoSerializationException.#ctor">
      <summary>
            Creates a new XcoSerializationException.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoSerializationException.#ctor(System.String)">
      <summary>
            Creates a new XcoSerializationException.
            </summary>
      <param name="message">The error message.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoSerializationException.#ctor(System.String,System.Exception)">
      <summary>
            Creates a new XcoSerializationException.
            </summary>
      <param name="message">The error message.</param>
      <param name="innerException">The inner exception that has been thrown.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Exceptions.XcoSerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Creates a new XcoSerializationException. This constructor is needed for serialization.
            </summary>
      <param name="info">SerializationInfo for handling type-specific serialization information.</param>
      <param name="context">StreamingContext for handling type-specific serialization information.</param>
    </member>
    <member name="T:XcoAppSpaces.Core.Communication.Connector">
      <summary>
            Remote communication component for AppSpace. Handles the transport of messages
            from/to remote workers and ports.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.Communication.Connector.#ctor">
      <summary>
            Creates a new Connector.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.Communication.Connector.Initialize(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Initializes the connector instance and gets all other needed services from the service registry.
            </summary>
      <param name="serviceRegistry">The service registry of the current appspace instance.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.Communication.Connector.IsLocal(System.String)">
      <summary>
            Checks a certain address if it is the address of the local space. This is the case if the
            address is either NULL of if it is equal (ignoring case) to the local address.
            </summary>
      <param name="address">The address to be checked.</param>
      <returns>True if the address refers to the local space.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.Communication.Connector.ConnectWorker``1(System.String,System.String,System.Net.ICredentials)">
      <summary>
            Establishes a connection to a worker that is running at a remote space. Creates a local
            proxy of the worker that allows posting messages that are automatically transported
            to the worker.
            If the worker does't exist or the connection to the space cannot be established, an
            XcoCommunicationException is thrown.
            This method is an alternative to the method taking an URI as address, being more flexible
            and therefore allowing things like Jabber usernames to be used.
            </summary>
      <typeparam name="TContract">The contract type of the worker to connect to.</typeparam>
      <param name="workerAddress">The address of the worker in den form "address/workername"</param>
      <param name="commServiceName">The name of the communication service that should be used to communicate with the worker (or null if the default communication service should be used).</param>
      <param name="credentials">The credentials that should be used to connect to the worker.</param>
      <returns>A worker contract instance that allows to post messages to the remote worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.Communication.Connector.ConnectWorker``1(System.String,System.String,System.String,System.Net.ICredentials)">
      <summary>
            Establishes a connection to a worker that is running at a remote space. Creates a local
            proxy of the worker that allows posting messages that are automatically transported
            to the worker.
            If the worker does't exist or the connection to the space cannot be established, an
            XcoCommunicationException is thrown.
            </summary>
      <typeparam name="TContract">The contract type of the worker to connect to.</typeparam>
      <param name="name">The name of the worker.</param>
      <param name="address">The address of the space where the worker is running (in form hostname:port).</param>
      <param name="commServiceName">The name of the communication service that should be used to communicate with the worker (or null if the default communication service should be used).</param>
      <param name="credentials">The credentials that should be used to connect to the worker.</param>
      <returns>A worker contract instance that allows to post messages to the remote worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.Communication.Connector.Dispose">
      <summary>
            Disposes the connector.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.Communication.Connector.Start">
      <summary>
            Starts the connector.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.Communication.Connector.Stop">
      <summary>
            Stops the connector.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Communication.Connector.LocalAddress">
      <summary>
            The local address of the space (in form hostname:port).
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Communication.Connector.CommServices">
      <summary>
            The list of registered communication services.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Communication.Connector.Errors">
      <summary>
            Port where communication errors are posted that are not caught by causalities.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Communication.Connector.CommunicationEvents">
      <summary>
            Events giving information about incoming and outgoing communication, e.g. for monitoring
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Communication.Connector.StartPriority">
      <summary>
            Start priority of the connector (needs to be started before the communication services).
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.Communication.MessageContext">
      <summary>
            Provides information about a currently processed message.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Communication.MessageContext.Current">
      <summary>
            If used while processing a message from a port or worker,
            returns the MessageContext for the given message.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Communication.MessageContext.IsRemoteMessage">
      <summary>
            Returns true if the message was posted from a remote location, or false if it was posted locally.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Communication.MessageContext.RemoteAddress">
      <summary>
            The address of the remote space, if the message was posted remotely.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Communication.MessageContext.TransportServiceName">
      <summary>
            The name of the transport service with which the message has been received, if it was posted remotely.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Communication.MessageContext.SessionID">
      <summary>
            The id of the session, if the message was posted to a worker remotely. The SessionID is provided by
            the security service
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Communication.MessageContext.Username">
      <summary>
            The name of the user that posted the message, if it was posted to a worker remotely. The Username
            is provided by the security service.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Transport.Sockets.Config">
      <summary>
            Configuration contains settings that are target for possible later outsourcing
            into a settings file.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Transport.Sockets.ConfigStringInterpreter">
      <summary>
            Configuration string interpreter for the XcoTCPTransportService.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Transport.Sockets.ConfigStringInterpreter.ConfigPort">
      <summary>
            Config key for setting the port.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Transport.Sockets.ConfigStringInterpreter.ConfigLifetime">
      <summary>
            Config key for setting the connection lifetime (format: mm:ss).
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Transport.Sockets.ConfigStringInterpreter.ConfigName">
      <summary>
            Config key for setting the name.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Transport.Sockets.ConfigStringInterpreter.ConfigIsDefault">
      <summary>
            Config key for setting if the service is the default communication service.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Transport.Sockets.ConfigStringInterpreter.ConfigAuthKey">
      <summary>
            Config key for setting the authentication key.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.Sockets.ConfigStringInterpreter.InterpretDefinition">
      <summary>
            Action definition for interpretion
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.Sockets.ConfigStringInterpreter.GetService">
      <summary>
            Get the current tcp service
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Transport.Sockets.FluentConfigExtensions">
      <summary>
            Defines extension methods for configuration of an XcoTCPTransportService using the fluent interface.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.FluentConfigExtensions.OnPort``1(XcoAppSpaces.Contracts.Service.IXcoServiceFluentConfiguration{XcoAppSpaces.Transport.Sockets.XcoTCPTransportService,``0},System.Int32)">
      <summary>
            Defines on which port the communication service should be running.
            </summary>
      <typeparam name="T">The type of the configuration object.</typeparam>
      <param name="config">The configuration object.</param>
      <param name="port">The port on which the communication service should be running.</param>
      <returns>The configuration object for further configuration with the fluent interface.</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.FluentConfigExtensions.OnRandomPort``1(XcoAppSpaces.Contracts.Service.IXcoServiceFluentConfiguration{XcoAppSpaces.Transport.Sockets.XcoTCPTransportService,``0})">
      <summary>
            Defines that the communication service should be running on a random port.
            </summary>
      <typeparam name="T">The type of the configuration object.</typeparam>
      <param name="config">The configuration object.</param>
      <returns>The configuration object for further configuration with the fluent interface.</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.FluentConfigExtensions.WithConnectionLifetime``1(XcoAppSpaces.Contracts.Service.IXcoServiceFluentConfiguration{XcoAppSpaces.Transport.Sockets.XcoTCPTransportService,``0},System.TimeSpan)">
      <summary>
            Configures the connection lifetime (time after which a connection is closed when no messages are sent or received). 
            The default value is 1 minute. For some scenarios it can make sense to leave connections open for a longer time span 
            to reduce the need for sending messages just to keep the connection alive.
            </summary>
      <typeparam name="T">The type of the configuration object.</typeparam>
      <param name="config">The configuration object.</param>
      <param name="lifetime">The connection life time.</param>
      <returns>The configuration object for further configuration with the fluent interface.</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.FluentConfigExtensions.WithAuthenticationKey``1(XcoAppSpaces.Contracts.Service.IXcoServiceFluentConfiguration{XcoAppSpaces.Transport.Sockets.XcoTCPTransportService,``0},System.String)">
      <summary>
            Defines a key that should be used for authentication of incoming connections.
            </summary>
      <typeparam name="T">The type of the configuration object.</typeparam>
      <param name="config">The configuration object.</param>
      <param name="authenticationKey">Key that should be used for authentication of incoming connections.</param>
      <returns>The configuration object for further configuration with the fluent interface.</returns>
    </member>
    <member name="T:XcoAppSpaces.Transport.Sockets.TransferHelper">
      <summary>
             Helperclass for XcoMessage convert for transfer
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.TransferHelper.#ctor">
      <summary>
             Helper class for XcoMessages converts
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.TransferHelper.Convert(XcoAppSpaces.Contracts.Transport.XcoMessage,System.String)">
      <summary>
            Converts the XcoMessage to a byte[]
            </summary>
      <param name="msg">XcoMessage to convert</param>
      <param name="localAddress">The local address of the transport service.</param>
      <returns>byte[] instance of the XcoMessage</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.TransferHelper.Convert(System.IO.BinaryReader,System.String@,System.Action,System.Action{System.Exception})">
      <summary>
            Convert byte[] to XcoMessage
            </summary>
      <param name="stream">read XcoMessage from stream</param>
      <param name="remoteAddress">Address of the space where the message came from.</param>
      <param name="handleEmptyData">Action that should be called when data is empty</param>
      <param name="handleError">Action that should be called when an error is encountered</param>
      <returns>new XcoMessage instance</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.TransferHelper.ReadData(System.IO.BinaryReader,System.Int32,System.Byte[]@)">
      <summary>
            Read data from stream
            </summary>
      <param name="stream">
      </param>
      <param name="gesamtLen">
      </param>
      <param name="content">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService">
      <summary>
            Communication Service that send/receives messages to/from remote spaces via
            TCP sockets. The service is able to either use connections only one-way, meaning
            two spaces communicating with each other always use two channels (one for sending
            and one for receiving), or two-way, where a single connection between to spaces
            is used to transfer messages in both ways.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.#ctor">
      <summary>
            Creates a new XcoTCPTransportService.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.#ctor(System.Int32)">
      <summary>
            Creates a new XcoTCPTransportService.
            </summary>
      <param name="port">The port where the service should be running.</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.#ctor(System.String,System.Int32)">
      <summary>
            Creates a new XcoTCPTransportService.
            </summary>
      <param name="ipAddress">The local ip address where the service should be running.</param>
      <param name="port">The port where the service should be running.</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.Initialize(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Initializes the transport service.
            </summary>
      <param name="serviceRegistry">Service registry with other services of the space instance.</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.Start">
      <summary>
            Starts the communication service.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.Stop">
      <summary>
            Stops the service and closes all open connections.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.ReleaseConnections">
      <summary>
            Releases all currently active connections.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.Send(XcoAppSpaces.Contracts.Transport.XcoMessage,System.String)">
      <summary>
            Sends a message to a remote space.
            </summary>
      <param name="msg">The messages that should be sent.</param>
      <param name="remoteAddress">The address where the message should be sent to.</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.CheckConnectionTimeouts">
      <summary>
            Checks if any TCPClients have run into a timeout (not sent any message for a 
            defined amount of time), and removes these clients and closes their connections.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.Dispose">
      <summary>
            Stops the service and closes all open connections.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.SecuritySettings">
      <summary>
            Security settings for authentication of incoming connections.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.Port">
      <summary>
            The port on which the service is running.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.LocalAddress">
      <summary>
            The Address of the server.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.ConnectionLifetime">
      <summary>
            The time until a connect is closed when it has not been used (meaning not messages have been sent or received).
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.ActiveConnections">
      <summary>
            Returns a list of addresses to which there are currently active tcp connections.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.StartPriority">
      <summary>
            Start priority of the service.
            </summary>
    </member>
    <member name="E:XcoAppSpaces.Transport.Sockets.XcoTCPTransportService.OnMessageReceived">
      <summary>
            Event that is raised when a message is received.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Transport.MSMQ.ConfigStringInterpreter">
      <summary>
            Configuration string interpreter for the XcoMSMQTransportService.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Transport.MSMQ.ConfigStringInterpreter.ConfigQueueName">
      <summary>
            Config key for setting the queue name.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Transport.MSMQ.ConfigStringInterpreter.ConfigName">
      <summary>
            Configuration key for setting the name.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Transport.MSMQ.ConfigStringInterpreter.ConfigIsDefault">
      <summary>
            Configuration key for setting if the service is the default communication service.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Transport.MSMQ.ConfigStringInterpreter.ConfigDisposeQueue">
      <summary>
            Remove queue after using
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.MSMQ.ConfigStringInterpreter.InterpretDefinition">
      <summary>
            Action definition for interpretion
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.MSMQ.ConfigStringInterpreter.GetService">
      <summary>
            Get the current tcp service
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Transport.MSMQ.FluentConfigExtensions">
      <summary>
            Defines extension methods for configuration of an XcoMSMQTransportService using the fluent interface.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.FluentConfigExtensions.WithQueueName``1(XcoAppSpaces.Contracts.Service.IXcoServiceFluentConfiguration{XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService,``0},System.String)">
      <summary>
            Defines on which queue-name the communication service should be read from.
            </summary>
      <typeparam name="T">The type of the configuration object.</typeparam>
      <param name="config">The configuration object.</param>
      <param name="queuename">The queue name on which the communication service should be read from.</param>
      <returns>The configuration object for further configuration with the fluent interface.</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.FluentConfigExtensions.WithRemoveQueueOnStop``1(XcoAppSpaces.Contracts.Service.IXcoServiceFluentConfiguration{XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService,``0})">
      <summary>
            Defines that the message queue should automatically be removed when the transport service is stopped (meaning when the appspace instance is disposed).
            </summary>
      <typeparam name="T">The type of the configuration object.</typeparam>
      <param name="config">The configuration object.</param>
      <returns>The configuration object for further configuration with the fluent interface.</returns>
    </member>
    <member name="T:XcoAppSpaces.Transport.MSMQ.TransferHelper">
      <summary>
             Helperclass for XcoMessage convert for transfer
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.TransferHelper.#ctor">
      <summary>
             Helper class for XcoMessages converts
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.TransferHelper.Convert(XcoAppSpaces.Contracts.Transport.XcoMessage,System.String)">
      <summary>
            Converts the XcoMessage to a byte[]
            </summary>
      <param name="msg">XcoMessage to convert.</param>
      <param name="remoteAddress">The address to which the message should be sent.</param>
      <returns>byte[] instance of the XcoMessage</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.TransferHelper.Convert(System.IO.BinaryReader,System.String@)">
      <summary>
            Convert byte[] to XcoMessage
            </summary>
      <param name="stream">read XcoMessage from stream</param>
      <param name="remoteAddress">The address where the message came from.</param>
      <returns>new XcoMessage instance</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.TransferHelper.ReadData(System.IO.BinaryReader,System.Int32,System.Byte[]@)">
      <summary>
            Read data from stream
            </summary>
      <param name="stream">
      </param>
      <param name="gesamtLen">
      </param>
      <param name="content">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService">
      <summary>
            Communication Service that send/receives messages to/from remote spaces via
            MSMQ. The service uses one queue for reading messages.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.#ctor">
      <summary>
            Creates a new XcoMSMQTransportService.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.#ctor(System.String)">
      <summary>
            Creates a new XcoMSMQTransportService.
            </summary>
      <param name="queueName">The queueName where the service should read from.</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.#ctor(System.String,System.Boolean)">
      <summary>
            Creates a new XcoMSMQTransportService.
            </summary>
      <param name="queueName">The queueName where the service should read from.</param>
      <param name="removeQueueOnStop">If true the queue will be removed upon disposal of communication service</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.DeleteQueue">
      <summary>
            Delete queue 
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.Initialize(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Initializes the transport service.
            </summary>
      <param name="serviceRegistry">Service registry containing other services of the space.</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.Start">
      <summary>
            Starts the communication service.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.Stop">
      <summary>
            Stops the service and closes all open connections.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.ReleaseConnections">
      <summary>
            Releases all currently active connections.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.Send(XcoAppSpaces.Contracts.Transport.XcoMessage,System.String)">
      <summary>
            Sends a message to a remote space.
            </summary>
      <param name="msg">The messages that should be sent.</param>
      <param name="remoteAddress">The address where the message should be sent</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.CheckConnectionTimeouts(System.Object)">
      <summary>
            Checks if any TCPClients have run into a timeout (not sent any message for a 
            defined amount of time), and removes these clients and closes their connections.
            </summary>
      <param name="timerInfo">Field for additional info from the timer that starts the method (is ignored because not additional info needed).</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.Dispose">
      <summary>
            Stops the service and closes all open connections.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.RemoveQueueOnStop">
      <summary>
            Remove Queue after use if true
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.QueueName">
      <summary>
            The message queue on which the service reads from.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.StartPriority">
      <summary>
            The start priority of the service.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.LocalAddress">
      <summary>
            Returns the MSMQ name
            </summary>
    </member>
    <member name="E:XcoAppSpaces.Transport.MSMQ.XcoMSMQTransportService.OnMessageReceived">
      <summary>
            Event that is raised when a message is received.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.IBindingsHelper">
      <summary>
            Helper for different WCF Bindings
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.IBindingsHelper.GenerateStandardNetTcp(System.Int32)">
      <summary>
            Creates standard Uri for a net.tcp WCF service
            </summary>
      <param name="port">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.IBindingsHelper.Convert(System.String)">
      <summary>
            Converts a given address with the default binding to a service WCF address
            </summary>
      <param name="address">
      </param>
      <returns>WCF service address</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.IBindingsHelper.Convert(System.ServiceModel.Channels.Binding,System.String)">
      <summary>
            Converts a given address and binding to a service WCF address
            </summary>
      <param name="bindingType">The binding that should be used</param>
      <param name="address">The address that should be used</param>
      <returns>WCF service address</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.IBindingsHelper.ServerAddr(System.Uri)">
      <summary>
            The address part of the server (binding-specific)
            </summary>
      <param name="addr">WCF service address</param>
      <returns>The address part of the server</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.IBindingsHelper.Port(System.Uri)">
      <summary>
            Port of the server
            </summary>
      <param name="addr">WCF service address</param>
      <returns>Port of the server</returns>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.BindingsHelper">
      <summary>
            Helper for different WCF Bindings
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Transport.WCF.BindingsHelper.usedBindingScheme">
      <summary>
            Get the current binding scheme
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.BindingsHelper.GenerateStandardNetTcp(System.Int32)">
      <summary>
            Generates an Uri for NetTcp binding.
            </summary>
      <param name="port">The port for the uri.</param>
      <returns>The generated uri.</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.BindingsHelper.Convert(System.String)">
      <summary>
            Converts an address to be correct for current binding.
            </summary>
      <param name="address">The address to be converted.</param>
      <returns>The converted address.</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.BindingsHelper.Convert(System.ServiceModel.Channels.Binding,System.String)">
      <summary>
            Converts the given address for the given binding type.
            </summary>
      <param name="bindingType">The binding type to be used.</param>
      <param name="address">The address to be converted.</param>
      <returns>The converted address.</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.BindingsHelper.Convert(System.ServiceModel.NetNamedPipeBinding,System.String)">
      <summary>
            Converts the given address for the NetNamedPipeBinding.
            </summary>
      <param name="bindingType">The NetNamedPipeBinding type-information.</param>
      <param name="address">The address to be converted.</param>
      <returns>The converted address.</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.BindingsHelper.Convert(System.ServiceModel.NetTcpBinding,System.String)">
      <summary>
            Converts the given address for the NetTcpBinding.
            </summary>
      <param name="bindingType">The NetTcpBinding type-information.</param>
      <param name="address">The address to be converted.</param>
      <returns>The converted address.</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.BindingsHelper.Convert(System.ServiceModel.WSHttpBinding,System.String)">
      <summary>
            Converts the given address for the NetTcpBinding.
            </summary>
      <param name="bindingType">The WSHttpBinding type-information.</param>
      <param name="address">The address to be converted.</param>
      <returns>The converted address.</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.BindingsHelper.ServerAddr(System.Uri)">
      <summary>
            Gets the address value that should be returned by the communication
            service's ServerAdress property (binding info is removed from the address).
            </summary>
      <param name="addr">The address.</param>
      <returns>The value for the ServerAddress property.</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.BindingsHelper.Port(System.Uri)">
      <summary>
            Extracts the port value from the given address.
            </summary>
      <param name="addr">The address.</param>
      <returns>The port value.</returns>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.ConfigStringInterpreter">
      <summary>
            Configuration string interpreter for the XcoWCFTransportService
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Transport.WCF.ConfigStringInterpreter.ConfigPort">
      <summary>
            Configuration key for setting the port.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Transport.WCF.ConfigStringInterpreter.ConfigName">
      <summary>
            Configuration key for setting the name.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Transport.WCF.ConfigStringInterpreter.ConfigIsDefault">
      <summary>
            Configuration key for setting if the service is the default communication service.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.WCF.ConfigStringInterpreter.InterpretDefinition">
      <summary>
            Action definition for interpretion
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.WCF.ConfigStringInterpreter.GetService">
      <summary>
            Get the current WCF service
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.FluentConfigExtensions">
      <summary>
            Defines extension methods for configuration of an XcoWCFTransportService using the fluent interface.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.FluentConfigExtensions.OnPort``1(XcoAppSpaces.Contracts.Service.IXcoServiceFluentConfiguration{XcoAppSpaces.Transport.WCF.XcoWCFTransportService,``0},System.Int32)">
      <summary>
            Defines on which port the communication service should be running.
            </summary>
      <typeparam name="T">The type of the configuration object.</typeparam>
      <param name="config">The configuration object.</param>
      <param name="port">The port on which the communication service should be running.</param>
      <returns>The configuration object for further configuration with the fluent interface.</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.FluentConfigExtensions.OnRandomPort``1(XcoAppSpaces.Contracts.Service.IXcoServiceFluentConfiguration{XcoAppSpaces.Transport.WCF.XcoWCFTransportService,``0})">
      <summary>
            Defines that the communication service should be running on a random port.
            </summary>
      <typeparam name="T">The type of the configuration object.</typeparam>
      <param name="config">The configuration object.</param>
      <returns>The configuration object for further configuration with the fluent interface.</returns>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.IRemoteSpaceService">
      <summary>
            Interface definition for the WCF service used to communication with remote spaces.
            All communication is one-way and session oriented.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.IRemoteSpaceService.Connect">
      <summary>
            Initiates a connection to a remote space. This is always the first Method that
            has to be called when wanting to communicate with a remote space.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.IRemoteSpaceService.Disconnect">
      <summary>
            Terminates the connection to a remote space. This is always the last Method that
            has to be called when wanting to communicate with a remote space.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.IRemoteSpaceService.SendMessage(XcoAppSpaces.Contracts.Transport.XcoMessage,System.String)">
      <summary>
            Sends a message to a remote space (serialized into a byte array).
            </summary>
      <param name="data">The message to be sent.</param>
      <param name="remoteAddress">The address of the space from which the message has been sent.</param>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.SpaceServiceChannel">
      <summary>
            Interface definition for the service channel of the space.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.IXcoWCFTransportSessionShutdown">
      <summary>
            Event on shutdown 
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.IXcoWCFTransportSessionShutdown.Shutdown(System.String)">
      <summary>
            Remove closed channel
            </summary>
      <param name="sessionID">sessionID of closed channel</param>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.RemoteSender">
      <summary>
            Sender for communication with remote spaces. Uses an IRemoteSpaceService to communicate
            with service hosts of remote spaces.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.RemoteSender.LoadConfigurationDelegate">
      <summary>
            Supports different sender-configurations
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.RemoteSender.#ctor(System.String,XcoAppSpaces.Contracts.Logging.IXcoLogger,System.ServiceModel.Configuration.ServiceModelSectionGroup,XcoAppSpaces.Transport.WCF.IXcoWCFTransportSessionShutdown)">
      <summary>
            Creates a new RemoteSender. A new IRemoteSpaceService object is created that communicates
            with the given address, with help of the ChannelFactory class.
            </summary>
      <param name="address">The address of the remote space, in binding form.</param>
      <param name="log">Logger to use for logging.</param>
      <param name="group">External configuration for WCF settings</param>
      <param name="shutdown">Shutdown event for faster cleanup</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.RemoteSender.#ctor(System.String,XcoAppSpaces.Transport.WCF.RemoteSender.LoadConfigurationDelegate,XcoAppSpaces.Contracts.Logging.IXcoLogger,XcoAppSpaces.Transport.WCF.IXcoWCFTransportSessionShutdown,XcoAppSpaces.Transport.WCF.IBindingsHelper)">
      <summary>
            Creates a new RemoteSender. A new IRemoteSpaceService object is created that communicates
            with the given address, with help of the ChannelFactory class.
            </summary>
      <param name="address">The address of the remote space, in binding form.</param>
      <param name="loadConfig">Delegate for loading the service configuration.</param>
      <param name="log">The logger that should be used.</param>
      <param name="shutdown">Shutdown event for faster cleanup</param>
      <param name="bindingHelper">The binding helper that should be used</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.RemoteSender.spaceService_Closed(System.Object,System.EventArgs)">
      <summary>
            Connection lost
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.RemoteSender.Connect">
      <summary>
            Initiates a connection by calling the Connect method of the IRemoteSpaceService object.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.RemoteSender.SendDisable">
      <summary>
            Test - After channel shutdown, sending is not allowed
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.RemoteSender.Disconnect">
      <summary>
            Terminates the connection by calling the Disconnect method of the IRemoteSpaceService object.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.RemoteSender.SendMessage(XcoAppSpaces.Contracts.Transport.XcoMessage,System.String)">
      <summary>
            Sends a message by first serializing it and the using the IRemoteSpaceService object to send it.
            The last send time is set to the current time.
            </summary>
      <param name="msg">The Message to be sent.</param>
      <param name="remoteAddress">The address where the message should sent.</param>
    </member>
    <member name="P:XcoAppSpaces.Transport.WCF.RemoteSender.SessionID">
      <summary>
            The session id of the client channel that is used by communicating with the remote space service.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.WCF.RemoteSender.LastSendTime">
      <summary>
            The time when this RemoteSender has last sent a message.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.SpacePortal">
      <summary>
            Implementation for the server side endpoint of the WCF service for communication with remote
            spaces. Named SpacePortal, because it provides a portal to the space for any incoming remote
            communication.
            Definition of the service behavior: Only one instance is running at the server, but can be
            used concurrent.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.SpacePortal.#ctor(System.Uri,XcoAppSpaces.Transport.WCF.XcoWCFTransportService,XcoAppSpaces.Contracts.Logging.IXcoLogger)">
      <summary>
            Creates a new SpacePortal.
            </summary>
      <param name="addr">The address in which the service host is running (here only needed for information purposes).</param>
      <param name="commService">The communication service.</param>
      <param name="log">Logger to be used for logging.</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.SpacePortal.Connect">
      <summary>
            Does nothing, because it is only needed for connection initiation (which is managed
            internally by WCF).
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.SpacePortal.Disconnect">
      <summary>
            Does nothing, because it is only needed for connection termination (which is managed
            internally by WCF).
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.SpacePortal.SendMessage(XcoAppSpaces.Contracts.Transport.XcoMessage,System.String)">
      <summary>
            Processes a message that has been received. The message is deserialized and the corresponding
            process method is called.
            </summary>
      <param name="msg">The message that has been received.</param>
      <param name="remoteAddress">The address from where the message has been received.</param>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.SpacePortalInfo">
      <summary>
            Get the service information for external use
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.SpacePortalInfo.#ctor(XcoAppSpaces.Transport.WCF.XcoWCFTransportService,XcoAppSpaces.Contracts.Logging.IXcoLogger)">
      <summary>
            Creates a new instance of SpacePortalInfo
            </summary>
      <param name="commService">Active communication service</param>
      <param name="logger">Logger from the transport service</param>
    </member>
    <member name="P:XcoAppSpaces.Transport.WCF.SpacePortalInfo.CommService">
      <summary>
            Interface for the communication service
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.WCF.SpacePortalInfo.Logger">
      <summary>
            Logger from the transport service
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.XcoWCFEndpointBehavior">
      <summary>
            Shutdown endpoint behavior
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFEndpointBehavior.#ctor(XcoAppSpaces.Transport.WCF.IXcoWCFTransportSessionShutdown)">
      <summary>
            Create ShutdownBehavior instance
            </summary>
      <param name="shutdown">Interface for shutdown procedure</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFEndpointBehavior.AddBindingParameters(System.ServiceModel.Description.ServiceEndpoint,System.ServiceModel.Channels.BindingParameterCollection)">
      <summary>
            Not used
            </summary>
      <param name="endpoint">
      </param>
      <param name="bindingParameters">
      </param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFEndpointBehavior.ApplyClientBehavior(System.ServiceModel.Description.ServiceEndpoint,System.ServiceModel.Dispatcher.ClientRuntime)">
      <summary>
            Not used
            </summary>
      <param name="endpoint">
      </param>
      <param name="clientRuntime">
      </param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFEndpointBehavior.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceEndpoint,System.ServiceModel.Dispatcher.EndpointDispatcher)">
      <summary>
            Register shutdown behavior
            </summary>
      <param name="endpoint">
      </param>
      <param name="endpointDispatcher">
      </param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFEndpointBehavior.Validate(System.ServiceModel.Description.ServiceEndpoint)">
      <summary>
            Not used
            </summary>
      <param name="endpoint">
      </param>
    </member>
    <member name="P:XcoAppSpaces.Transport.WCF.XcoWCFEndpointBehavior.Shutdown">
      <summary>
            Interface for shutdown procedure
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.XcoWCFInputSessionShutdown">
      <summary>
            Send session-ID when channel is closed
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFInputSessionShutdown.#ctor(XcoAppSpaces.Transport.WCF.IXcoWCFTransportSessionShutdown)">
      <summary>
            Create ShutdownBehavior instance
            </summary>
      <param name="shutdown">Interface for shutdown procedure</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFInputSessionShutdown.ChannelFaulted(System.ServiceModel.IDuplexContextChannel)">
      <summary>
            Not used
            </summary>
      <param name="channel">
      </param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFInputSessionShutdown.DoneReceiving(System.ServiceModel.IDuplexContextChannel)">
      <summary>
            Channel closed, send sessionID to shutdown cleanup
            </summary>
      <param name="channel">
      </param>
    </member>
    <member name="P:XcoAppSpaces.Transport.WCF.XcoWCFInputSessionShutdown.Shutdown">
      <summary>
            Interface for shutdown procedure
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.XcoWCFTransportService">
      <summary>
            Service that manages incoming and outgoing messages from/to remote spaces by use of WCF. Incoming
            messages are received by a hosted SpacePortal service. Outgoing messages are sent by RemoteSender 
            objects, the currently open RemoteSenders are managed in a list. A Timer regularly checks if any 
            connections to remote spaces have run into a timeout, and closes and removes such connections.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.LoadHostConfigurationDelegate">
      <summary>
            Supports different host-configurations
            </summary>
      <param name="coreUri">Uri from core</param>
      <param name="spacePortal">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.NewRemoteSenderDelegate">
      <summary>
            Supports different constructors
            </summary>
      <param name="addr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="F:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.standardConfig">
      <summary>
            Standard config string for the wcf.config file
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.smsGroup">
      <summary>
            External configuration group
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.SetBindingHelper(XcoAppSpaces.Transport.WCF.IBindingsHelper)">
      <summary>
            Set the BindingHelper for additional functionalities
            </summary>
      <param name="bindingHelper">
      </param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.SetSpaceService(XcoAppSpaces.Transport.WCF.IRemoteSpaceService,System.ServiceModel.Configuration.ServiceModelSectionGroup)">
      <summary>
            Set space instance and WCF configuration
            </summary>
      <param name="newService">External IRemoteSpaceService instance, e.g. from IIS hosting</param>
      <param name="group">Configurationsection for WCF settings</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.#ctor(System.Int32)">
      <summary>
            Creates a new XcoWCFTransportService.
            </summary>
      <param name="port">The port that should be used (net.tcp).</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.#ctor(System.String)">
      <summary>
            Creates a new XcoWCFTransportService.
            </summary>
      <param name="address">The address that should be used (binding-specific).</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.GenerateAddrUri(System.Int32)">
      <summary>
            Generate address uri from port definition
            </summary>
      <param name="port">
      </param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.#ctor">
      <summary>
            Creates a new RemoteServer.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.Initialize(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Initializes the transport service.
            </summary>
      <param name="serviceRegistry">Service registry with other services of the space instance.</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.Start">
      <summary>
            Starts the service host in an own Thread, and waits until the service host is opened. 
            An exception is thrown if an error occured while opening the service host.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.CreateRandomPort">
      <summary>
            Creates Random-Port for the WCF-Service
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.LoadEndPointConfig">
      <summary>
            Load wcf-endpoint configuration from config-file, if exists
            </summary>
      <returns>null if no configuration is found</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.LoadConfiguration(System.Uri,XcoAppSpaces.Transport.WCF.IRemoteSpaceService)">
      <summary>
            Load specific configuration settings.       
            </summary>
      <param name="coreUri">Baseaddress for the wcf-service</param>
      <param name="_spacePortal">The space-portal instance for WCF hosting</param>
      <returns>ServiceHost from the SpacePortal</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.InitDefaultWCFConnection(System.Uri,XcoAppSpaces.Transport.WCF.IRemoteSpaceService)">
      <summary>
            Init default wcf-properties
            </summary>
      <param name="coreUri">
      </param>
      <param name="_spacePortal">
      </param>
      <returns>Default WCF-Service-Host</returns>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.CheckAddressForSharedPort">
      <summary>
            Check if shared port is in use
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.RunServiceHost">
      <summary>
            Method to start in an own thread, that opens a new service host at the given port to receive
            messages from remote kernels. The SpacePortal class is used as service.
            Note: ServiceHost must run in an own thread, otherwise the host will not work when used in
            Windows Forms Applications. This seems to be the case because of some collision with messaging
            in WCF and Windows Forms.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.CheckConnectionTimeouts(System.Object)">
      <summary>
            Checks if any RemoteSenders have run into a timeout (not sent any message for a 
            defined amount of time), and removes these senders and closes their connections.
            </summary>
      <param name="timerInfo">Field for additional info from the timer that starts the method (is ignored because not additional info needed).</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.Send(XcoAppSpaces.Contracts.Transport.XcoMessage,System.String)">
      <summary>
            Sends a message to a remote space. If no remote sender for this message exists yet,
            a new RemoteSender is created and stored in the list of currently open RemoteSenders.
            If a RequestMessage can not be sent, an ResponseMessage with an error is created and given
            back to the Request by using the processResponse method.
            </summary>
      <param name="msg">The message to be sent.</param>
      <param name="toAddress">The address where the message should be sent.</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.Stop">
      <summary>
            Closes the service host, stops the timeout checking and disconnects all senders that 
            are currently connected to other spaces.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.Dispose">
      <summary>
            Closes the service host, stops the timeout checking and disconnects all senders that 
            are currently connected to other spaces.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.ReleaseConnections">
      <summary>
            Release current active connections.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.ShutdownRemoteSender(System.String)">
      <summary>
            Close the RemoteSender because the connected channel has closed
            </summary>
      <param name="channelSessionID">sessionID of closed channel</param>
    </member>
    <member name="M:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.Shutdown(System.String)">
      <summary>
            Remove registered connected channel when closed
            </summary>
      <param name="sessionID">sessionID of closed channel</param>
    </member>
    <member name="P:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.ConfigLoader">
      <summary>
            Load different WCF-Configurations for the servicehost.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.CreateNewRemoteSender">
      <summary>
            Load different RemoteSender instances
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.SharedPortName">
      <summary>
            Name for this instance on the used port
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.Port">
      <summary>
            The port on which the service host is running.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.LocalAddress">
      <summary>
            The Address of the Server.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.StartPriority">
      <summary>
            The start priority of the service.
            </summary>
    </member>
    <member name="E:XcoAppSpaces.Transport.WCF.XcoWCFTransportService.OnMessageReceived">
      <summary>
            Event that is raised when a message is received.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Logging.IXcoLogger">
      <summary>
            Interface definition for Class used for Logging in the appspace. Defines methods
            for all needed message severity levels.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.IXcoLogger.Debug(System.String)">
      <summary>
            Logs a debug message.
            </summary>
      <param name="msg">The message to be logged.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.IXcoLogger.Info(System.String)">
      <summary>
            Logs an Info message.
            </summary>
      <param name="msg">The message to be logged.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.IXcoLogger.Warn(System.String)">
      <summary>
            Logs a warning message.
            </summary>
      <param name="msg">The message to be logged.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.IXcoLogger.Error(System.String)">
      <summary>
            Logs an error message.
            </summary>
      <param name="msg">The message to be logged.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.IXcoLogger.Error(System.String,System.Exception)">
      <summary>
            Logs an error message.
            </summary>
      <param name="msg">The message to be logged.</param>
      <param name="ex">The exception that was thrown.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.IXcoLogger.Fatal(System.String)">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="msg">The message to be logged.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.IXcoLogger.Fatal(System.String,System.Exception)">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="msg">The message to be logged.</param>
      <param name="ex">The exception that was thrown.</param>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Logging.XcoLoggerFactory">
      <summary>
            Factory for creating Loggers. (Logger factory is needed because the different
            components within the appspace require loggers with different names and types,
            so adding a single logger instance to the space is not sufficient.)
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Contracts.Logging.XcoLoggerFactory.CreateInstanceDefault">
      <summary>
            Default function for creating a new IXcoLogger Instance. Returns a new TraceSourceLogger instance with output level set to "Error".
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Contracts.Logging.XcoLoggerFactory.CreateInstance">
      <summary>
            Function for creating a new IXcoLogger Instance. Can be overwritten.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Logging.TraceSourceLogger">
      <summary>
            Logger class used for logging in the XcoAppSpace. Uses the .Net TraceSource class to output 
            the log messages. Settings for this Logger can be easily done in the App.config.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.TraceSourceLogger.#ctor(System.String,System.Diagnostics.SourceLevels)">
      <summary>
            Creates a new Logger.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.TraceSourceLogger.Debug(System.String)">
      <summary>
            Logs a debug message (using TraceEventType.Verbose).
            </summary>
      <param name="msg">The message to be logged.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.TraceSourceLogger.Info(System.String)">
      <summary>
            Logs an Info message (using TraceEventType.Information).
            </summary>
      <param name="msg">The message to be logged.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.TraceSourceLogger.Warn(System.String)">
      <summary>
            Logs a warning message (using TraceEventType.Warning).
            </summary>
      <param name="msg">The message to be logged.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.TraceSourceLogger.Error(System.String)">
      <summary>
            Logs an error message (using TraceEventType.Error).
            </summary>
      <param name="msg">The message to be logged.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.TraceSourceLogger.Error(System.String,System.Exception)">
      <summary>
            Logs an error message (using TraceEventType.Error).
            </summary>
      <param name="msg">The message to be logged.</param>
      <param name="ex">The exception that was thrown.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.TraceSourceLogger.Fatal(System.String)">
      <summary>
            Logs a fatal error message (using TraceEventType.Critical).
            </summary>
      <param name="msg">The message to be logged.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Logging.TraceSourceLogger.Fatal(System.String,System.Exception)">
      <summary>
            Logs a fatal error message (using TraceEventType.Critical).
            </summary>
      <param name="msg">The message to be logged.</param>
      <param name="ex">The exception that was thrown.</param>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Security.IXcoClientCredentials">
      <summary>
            Credentials that can be used to authenticate a user.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Security.IXcoClientCredentials.User">
      <summary>
            The username.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Security.IXcoClientCredentials.Password">
      <summary>
            The (encrypted) password.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Security.IXcoSecurityService">
      <summary>
            Interface 
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Security.IXcoSecurityService.GetClientCredentials(System.Net.ICredentials,System.String)">
      <summary>
            Gets xco client credentials from a given credentials object and for the given address, that can be 
            transfered to a remote space and used to authenticate a user at a remote space.
            </summary>
      <param name="credentials">The ICredentials object where to read the credentials from.</param>
      <param name="address">The address for which the credentials are needed.</param>
      <returns>A new IXcoClientCredentials instance containing the needed authentication information.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Security.IXcoSecurityService.Authenticate(System.String,XcoAppSpaces.Contracts.Security.IXcoClientCredentials)">
      <summary>
            Authenticates access for the given user to the space. It is checked if the username and password
            are valid. A sessionID is generated if authentication is successful. If the user already has an open
            session, the id of the existing session is returned.
            </summary>
      <param name="address">The host address of the user.</param>
      <param name="credentials">The credentials of the user.</param>
      <returns>The result of the authentication, including the Guid of the user session if it was successful.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Security.IXcoSecurityService.Authorize(System.String,System.Guid,Microsoft.Ccr.Core.IPort)">
      <summary>
            Authorizes access for the user of the given session to the given worker. Authorization is successful
            if the user is allowed to access at least one port of the worker.
            </summary>
      <param name="address">The host address of the user.</param>
      <param name="sessionID">The sessionID of the user (that was generated during user authentication).</param>
      <param name="worker">The worker instance.</param>
      <returns>True if the user is authorized to access the worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Security.IXcoSecurityService.CheckPermission(Microsoft.Ccr.Core.IPort,System.Object,System.String,System.Guid)">
      <summary>
            Checks if certain port of a worker can be accessed by a specific session. An XcoSecurityException is thrown
            if the operation is not permitted.
            </summary>
      <param name="worker">The worker that should be accessed.</param>
      <param name="message">The message that should be posted to the worker.</param>
      <param name="address">The address ot the sender of the message.</param>
      <param name="sessionID">The ID of the session that the sender uses for communication.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Security.IXcoSecurityService.GetUsername(System.Guid)">
      <summary>
            Gets the username for the given session id.
            </summary>
      <param name="sessionID">The id of the session for which the user should be retrieved.</param>
      <returns>The username for the given session, or null if no user is applied to this session.</returns>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Security.XcoAuthenticationResult">
      <summary>
            Result of an authentication with an IXcoSecurityService instance.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Security.XcoAuthenticationResult.IsAuthenticated">
      <summary>
            True if the authentication was successful (meaning username and password were correct).
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Security.XcoAuthenticationResult.SessionID">
      <summary>
            The session id that the user must use to access the worker.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Security.XcoSecurityPermissionAttribute">
      <summary>
            Attribute that can be added to a worker or one of its message processor methods or worker extensions to
            allow a certain role to access this worker (or only certain ports of the worker).
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Security.XcoSecurityPermissionAttribute.#ctor(System.String)">
      <summary>
            Creates a new XcoSecurityPermissionAttribute.
            </summary>
      <param name="rolename">The rolename that should have permission.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Security.XcoSecurityPermissionAttribute.Rolename">
      <summary>
            The rolename that should have permission.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Security.XcoSecurityPolicy">
      <summary>
            List of security policies for handling remote access to workers.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Contracts.Security.XcoSecurityPolicy.Permissive">
      <summary>
            Anonymous users are allowed (can access all workers/ports that are not restricted to certain roles).
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Contracts.Security.XcoSecurityPolicy.Restrictive">
      <summary>
            No anonymous users are allowed.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Security.Basic.ConfigStringInterpreter">
      <summary>
            Configuration string interpreter for the XcoBasicSecurityService.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Security.Basic.ConfigStringInterpreter.ConfigPolicy">
      <summary>
            Config key for setting the policy.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Security.Basic.ConfigStringInterpreter.ConfigStore">
      <summary>
            Config key for setting the path of the user store.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Security.Basic.ConfigStringInterpreter.InterpretDefinition">
      <summary>
            Action definition for interpretion
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Security.Basic.ConfigStringInterpreter.GetService">
      <summary>
            Get the current service
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Security.Basic.FluentConfigExtensions">
      <summary>
            Defines extension methods for configuration of an XcoBasicSecurityService using the fluent interface.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.FluentConfigExtensions.WithPolicy``1(XcoAppSpaces.Contracts.Service.IXcoServiceFluentConfiguration{XcoAppSpaces.Security.Basic.XcoBasicSecurityService,``0},XcoAppSpaces.Contracts.Security.XcoSecurityPolicy)">
      <summary>
            Defines which security policy should be used by the XcoBasicSecurityService.
            </summary>
      <typeparam name="T">The type of the configuration object.</typeparam>
      <param name="config">The configuration object.</param>
      <param name="policy">The security policy that should be used.</param>
      <returns>The configuration object for further configuration with the fluent interface.</returns>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.FluentConfigExtensions.WithStorePath``1(XcoAppSpaces.Contracts.Service.IXcoServiceFluentConfiguration{XcoAppSpaces.Security.Basic.XcoBasicSecurityService,``0},System.String)">
      <summary>
            DDefines which user store path should be used by the XcoBasicSecurityService.
            </summary>
      <typeparam name="T">The type of the configuration object.</typeparam>
      <param name="config">The configuration object.</param>
      <param name="storePath">The user store path that should be used for loading and storing users.</param>
      <returns>The configuration object for further configuration with the fluent interface.</returns>
    </member>
    <member name="T:XcoAppSpaces.Security.Basic.User">
      <summary>
            Represents a users within the XcoBasicSecurityService.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.User.#ctor">
      <summary>
            Creates a new User.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.User.#ctor(System.String,System.Byte[],System.String[])">
      <summary>
            Creates a new User.
            </summary>
      <param name="name">The name of the user.</param>
      <param name="password">The (encrypted) password of the user.</param>
      <param name="roles">List of the user's roles.</param>
    </member>
    <member name="P:XcoAppSpaces.Security.Basic.User.Name">
      <summary>
            The name of the user.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Security.Basic.User.Password">
      <summary>
            The (encrypted) password of the user.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Security.Basic.User.Roles">
      <summary>
            List of the user's roles.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Security.Basic.XcoNoSecurityService">
      <summary>
            Security Service that just permits all actions.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoNoSecurityService.Authenticate(System.String,XcoAppSpaces.Contracts.Security.IXcoClientCredentials)">
      <summary>
            Authenticates the given user and address. Allows all users as authenticated and returns an empty session id.
            </summary>
      <param name="address">
      </param>
      <param name="credentials">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoNoSecurityService.Authorize(System.String,System.Guid,Microsoft.Ccr.Core.IPort)">
      <summary>
            Authorizes a given user to access a given worker. Always returns true.
            </summary>
      <param name="address">
      </param>
      <param name="sessionID">
      </param>
      <param name="worker">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoNoSecurityService.CheckPermission(Microsoft.Ccr.Core.IPort,System.Object,System.String,System.Guid)">
      <summary>
            Checks for permission to access the worker port for the given message type. Permission is always granted,
            a SecurityException is never thrown.
            </summary>
      <param name="worker">
      </param>
      <param name="message">
      </param>
      <param name="address">
      </param>
      <param name="sessionID">
      </param>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoNoSecurityService.GetClientCredentials(System.Net.ICredentials,System.String)">
      <summary>
            Creates an XcoBasicClientCredentials object for the given client credentials. This works
            the same way as in the XcoBasicSecurityService, so that XcoAppSpace instances with no
            security can communicate with spaces using the XcoBasicSecurityService without any special
            configuration.
            </summary>
      <param name="credentials">The ICredentials that have been set for the local space instance.</param>
      <param name="address">The address for which a user is needed.</param>
      <returns>An XcoBasicClientCredentials instance according to the given credentials.</returns>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoNoSecurityService.GetUsername(System.Guid)">
      <summary>
            Gets the username for the given session id.
            </summary>
      <param name="sessionID">The id of the session for which the user should be retrieved.</param>
      <returns>The username for the given session, or null if no user is applied to this session.</returns>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoNoSecurityService.Start">
      <summary>
            Starts the service.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoNoSecurityService.Stop">
      <summary>
            Stops the service.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoNoSecurityService.Initialize(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Initializes the service.
            </summary>
      <param name="serviceRegistry">
      </param>
    </member>
    <member name="P:XcoAppSpaces.Security.Basic.XcoNoSecurityService.StartPriority">
      <summary>
            The start priority of the service.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Security.Basic.PasswordUtil">
      <summary>
            Utility class for encrypting passwords and comparing two encrypted passwords.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.PasswordUtil.CreatePasswordHash(System.String)">
      <summary>
            Creates a hash for the given password string using SHA512 algorithm.
            </summary>
      <param name="password">The password string to hash.</param>
      <returns>The hash value.</returns>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.PasswordUtil.AreEqual(System.Byte[],System.Byte[])">
      <summary>
            Compares two hashes, returns true if they are equal.
            </summary>
      <param name="pw1">First hash.</param>
      <param name="pw2">Second hash.</param>
      <returns>true if the hashes are equal.</returns>
    </member>
    <member name="T:XcoAppSpaces.Security.Basic.XcoBasicSecurityService">
      <summary>
            The XcoBasicSecurityService provides a simple security solution for the XcoAppSpace.
            Authentication is based on user/password, authorization on roles which can be assigned
            to users. The users can be stored to and loaded from an XML file.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.#ctor(System.String,XcoAppSpaces.Contracts.Security.XcoSecurityPolicy)">
      <summary>
            Creates a new XcoBasicSecurityService. Users are automatically loaded from the given file path,
            if the file exists. The SaveUsers() method will also automatically use this path to save the
            users file.
            </summary>
      <param name="userStorePath">The path of the users xml file.</param>
      <param name="policy">The security policy that should be used.</param>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.#ctor(System.String)">
      <summary>
            Creates a new XcoBasicSecurityService. Users are automatically loaded from the given file path,
            if the file exists. The SaveUsers() method will also automatically use this path to save the
            users file.
            </summary>
      <param name="userStorePath">The path of the users xml file.</param>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.#ctor">
      <summary>
            Creates a new XcoBasicSecurityService.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.AddUser(System.String,System.String,System.String[])">
      <summary>
            Adds the user with the given name, passwort and roles to the security service.
            An XcoSecurityException is thrown if a user with the given name already exists.
            </summary>
      <param name="name">The name of the user.</param>
      <param name="password">The password of the user.</param>
      <param name="roles">The roles of the user.</param>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.RemoveUser(System.String)">
      <summary>
            Removes the user with the given name from the security service.
            Existing sessions for this user are removed.
            </summary>
      <param name="name">The name of the user to be removed.</param>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.AddRole(System.String,System.String)">
      <summary>
            Adds a role to the user with the given name.
            Note: Existing sessions are not updated with this information.
            </summary>
      <param name="username">The name of the user to which the role should be added.</param>
      <param name="role">The role that should be added.</param>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.RemoveRole(System.String,System.String)">
      <summary>
            Removes a role from the user with the given name.
            Note: Existing sessions are not updated with this information.
            </summary>
      <param name="username">The name of the user from which the role should be removed.</param>
      <param name="role">The role that should be removed.</param>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.SaveUsers">
      <summary>
            Saves the users to a file. If a file path has been specified, the file
            is saved to this path. Otherwise, a standard path is used, which is the
            path of the application, and the file name "XcoAppSpaces.Security.Basic_Users.xml".
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.Authenticate(System.String,XcoAppSpaces.Contracts.Security.IXcoClientCredentials)">
      <summary>
            Authenticates access for the given user to the space. It is checked if the username and password
            are valid. A sessionID is generated if authentication is successful. If the user already has an open
            session, the id of the existing session is returned.
            </summary>
      <param name="address">The host address of the user.</param>
      <param name="credentials">The credentials of the user.</param>
      <returns>The result of the authentication, including the Guid of the user session if it was successful.</returns>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.Authorize(System.String,System.Guid,Microsoft.Ccr.Core.IPort)">
      <summary>
            Authorizes access for the user of the given session to the given worker. Authorization is successful
            if the user is allowed to access at least one port of the worker.
            </summary>
      <param name="address">The host address of the user.</param>
      <param name="sessionID">The sessionID of the user (that was generated during user authentication).</param>
      <param name="worker">The worker instance.</param>
      <returns>True if the user is authorized to access the worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.CheckPermission(Microsoft.Ccr.Core.IPort,System.Object,System.String,System.Guid)">
      <summary>
            Checks if certain port of a worker can be accessed by a specific session. An XcoSecurityException is thrown
            if the operation is not permitted.
            </summary>
      <param name="worker">The worker that should be accessed.</param>
      <param name="message">The message that should be posted to the worker.</param>
      <param name="address">The address ot the sender of the message.</param>
      <param name="sessionID">The ID of the session that the sender uses for communication.</param>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.GetClientCredentials(System.Net.ICredentials,System.String)">
      <summary>
            Gets xco client credentials from a given credentials object and for the given address, that can be 
            transfered to a remote space and used to authenticate a user at a remote space.
            </summary>
      <param name="credentials">The ICredentials object where to read the credentials from.</param>
      <param name="address">The address for which the credentials are needed.</param>
      <returns>A new IXcoClientCredentials instance containing the needed authentication information.</returns>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.GetUsername(System.Guid)">
      <summary>
            Gets the username for the given session id.
            </summary>
      <param name="sessionID">The id of the session for which the user should be retrieved.</param>
      <returns>The username for the given session, or null if no user is applied to this session.</returns>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.Start">
      <summary>
            Starts the service. Loads the list of users from a file if requested,
            and registers itself to the local worker registry to get events
            when workers are added or removed.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.Stop">
      <summary>
            Stops the service.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.Initialize(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Initializes the service. Gets the instance of the local worker registry
            which is needed by the security service for recognizing when workers
            are added or removed.
            </summary>
      <param name="serviceRegistry">
      </param>
    </member>
    <member name="P:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.Policy">
      <summary>
            The security policy that should be used. Is permissive by default.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.StorePath">
      <summary>
            The file path where users should be loaded or stored. If this property
            is set before the XcoAppSpace is instantiated, the users will automatically
            be loaded from this path.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Security.Basic.XcoBasicSecurityService.StartPriority">
      <summary>
            Start priority of the service.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Serialization.IXcoSerializer">
      <summary>
            Interface definition for classes used for serialization and deserialization of 
            objects (used for remote communication and for serialized data storage).
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Serialization.IXcoSerializer.Serialize(System.Object)">
      <summary>
            Serializes an object into a byte array.
            </summary>
      <param name="element">The object to be serialized.</param>
      <returns>The serialized object.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Serialization.IXcoSerializer.Deserialize(System.Byte[])">
      <summary>
            Deserializes an object from a byte array.
            </summary>
      <param name="element">The serialized object.</param>
      <returns>The object that has been deserialized.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Serialization.IXcoSerializer.CanTypeBeSerialized(System.Type,System.String@)">
      <summary>
            Checks if the given type can be serialized. This method is called for every
            message type in the worker contract when connecting to a worker, so that any
            exceptions due to potential serialization problems can be thrown to the user.
            </summary>
      <param name="type">The type to be checked.</param>
      <param name="errorInfo">Contains information about serialization problems, if the type cannot be serialized.</param>
      <returns>True if the type can be serialized, otherwise false.</returns>
    </member>
    <member name="T:XcoAppSpaces.Serialization.Binary.TypeSerializationSurrogate">
      <summary>
            Surrogate that serializes types only by their name, therefore allowing interoperability 
            between different versions of signed assemblies.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Serialization.Binary.XcoBinarySerializer">
      <summary>
            Helper class for serialization and deserialization of objects (used in
            communication with remote spaces). Uses the BinaryFormatter.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Serialization.Binary.XcoBinarySerializer.Initialize(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Initializes the service.
            </summary>
      <param name="serviceRegistry">The registry with other services of the space instance.</param>
    </member>
    <member name="M:XcoAppSpaces.Serialization.Binary.XcoBinarySerializer.Serialize(System.Object)">
      <summary>
            Serializes an object into a byte array.
            </summary>
      <param name="element">The object to be serialized.</param>
      <returns>The serialized object.</returns>
    </member>
    <member name="M:XcoAppSpaces.Serialization.Binary.XcoBinarySerializer.Deserialize(System.Byte[])">
      <summary>
            Deserializes an object from a byte array.
            </summary>
      <param name="element">The serialized object.</param>
      <returns>The object that has been deserialized.</returns>
    </member>
    <member name="M:XcoAppSpaces.Serialization.Binary.XcoBinarySerializer.CanTypeBeSerialized(System.Type,System.String@)">
      <summary>
            Checks if the given type can be serialized. In case of the binary serializer, types must be marked
            as serializable.
            </summary>
      <param name="type">The type to be checked.</param>
      <param name="errorInfo">Contains information about serialization problems, if the type cannot be serialized.</param>
      <returns>True if the type can be serialized, otherwise false.</returns>
    </member>
    <member name="T:XcoAppSpaces.Contracts.CcrWiring.ICcrWirer">
      <summary>
            Service for wiring workers, worker proxies and remote ports with the Ccr
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrWiring.ICcrWirer.CreateWorker``2(Microsoft.Ccr.Core.DispatcherQueue)">
      <summary>
            Creates a new Worker and wires the worker ports with the message handlers contained in the worker class.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <typeparam name="TImplementation">The implementation type of the worker.</typeparam>
      <param name="dpq">The dispatcher queue that should be used for wiring the worker, or null if space's the default dispatcher queue should be used.</param>
      <returns>A WorkerInfo object containing the worker instance and additional information that has been gathered during the worker wiring.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrWiring.ICcrWirer.WireWorker``1(``0,Microsoft.Ccr.Core.DispatcherQueue)">
      <summary>
            Wires a given worker's ports with its message handlers.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="worker">The worker instance.</param>
      <param name="dpq">The dispatcher queue that should be used for wiring the worker, or null if space's the default dispatcher queue should be used.</param>
      <returns>A WorkerInfo object containing the worker instance and additional information that has been gathered during the worker wiring.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrWiring.ICcrWirer.UnwireWorker(Microsoft.Ccr.Core.IPort)">
      <summary>
            Removes all registered receiver tasks from all ports of the worker.
            </summary>
      <param name="worker">The worker that should be unwired.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrWiring.ICcrWirer.CreateWorkerProxy``1(XcoAppSpaces.Contracts.Messaging.WorkerProxyInfo)">
      <summary>
            Creates a worker proxy for a remote worker from the given parameters.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker (must have an empty constructor so it can be instantiated as a proxy).</typeparam>
      <param name="proxyInfo">Information that is needed to create the worker proxy, like name and address of the worker.</param>
      <returns>The created worker proxy.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrWiring.ICcrWirer.GetPortSerializationInfo(Microsoft.Ccr.Core.IPort)">
      <summary>
            Gets a serialization info object that contains all information that is needed by the receiving space
            to deserialize the worker. The current serialization context can be used to get the local adress, and
            to register the port at the local space and get a unique id for the port, if it is not already
            a remote port.
            </summary>
      <param name="port">The port to be serialized.</param>
      <returns>Object containing the info that must be sent to the remote space for deserialization of the port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrWiring.ICcrWirer.WireRemotePort(Microsoft.Ccr.Core.IPort,XcoAppSpaces.Contracts.CcrWiring.XcoPortSerializationInfo)">
      <summary>
            Wires a port using the given serialization info, so that it is ready for remote communication. The
            current serialization context can be used to get the name of the communication service that should be
            used to send messages to the original port.
            </summary>
      <param name="port">The port to be wired.</param>
      <param name="portSerializationInfo">Info that is needed for wiring the remote port, like the port's id and remote address.</param>
    </member>
    <member name="T:XcoAppSpaces.Contracts.CcrWiring.WorkerInfo`1">
      <summary>
            Class that contains information about a worker that is acquired during creation an wiring
            of the worker.
            </summary>
      <typeparam name="T">The contract type of the worker.</typeparam>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrWiring.WorkerInfo`1.#ctor(`0,System.Collections.Generic.List{XcoAppSpaces.Contracts.Service.XcoServiceAttributeInfo},System.Collections.Generic.Dictionary{System.Type,XcoAppSpaces.Core.XcoProcessorAttribute})">
      <summary>
            Creates a new WorkerInfo.
            </summary>
      <param name="instance">The worker instance.</param>
      <param name="serviceAttributes">List of attributes that are assigned to the worker and could be of interest to other services of the space.</param>
      <param name="processorAttributes">List of attributes of the processors of this worker.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrWiring.WorkerInfo`1.Instance">
      <summary>
            The worker instance.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrWiring.WorkerInfo`1.ServiceAttributes">
      <summary>
            List of attributes that are assigned to the worker and could be of interest to other services of the space.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrWiring.WorkerInfo`1.ProcessorAttributes">
      <summary>
            List of attributes of the processors of this worker.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.CcrWiring.XcoPortSerializationInfo">
      <summary>
            Infomation about a Port or PortSet concerning serialization.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrWiring.XcoPortSerializationInfo.#ctor">
      <summary>
            Creates a new XcoPortSerializationInfo.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrWiring.XcoPortSerializationInfo.#ctor(System.String,System.Guid)">
      <summary>
            Creates a new XcoPortSerializationInfo.
            </summary>
      <param name="remoteAddress">The remote address of the port.</param>
      <param name="remotePortGuid">The id of the port.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrWiring.XcoPortSerializationInfo.MakeRemote(System.String,System.Guid)">
      <summary>
            Adds remote information to the given XcoPortSerializationInfo.
            </summary>
      <param name="remoteAddress">The remote address of the port.</param>
      <param name="remotePortGuid">The id of the port.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrWiring.XcoPortSerializationInfo.RemoteAddress">
      <summary>
            The remote address of the port.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrWiring.XcoPortSerializationInfo.RemotePortGuid">
      <summary>
            The id of the port.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrWiring.XcoPortSerializationInfo.IsRemote">
      <summary>
            True if the XcoPortSerializationInfo contains remote information (remote address and port id).
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.CcrDispatching.ICcrDispatcherService">
      <summary>
            Service that gives access to the Ccr Dispatcher and DispatcherQueue of an appspace instance.
            The service can be used by other services of the space to get access to the space's
            Dispatcher and DispatcherQueue. To provide the possiblity of having seperated processing
            of normal worker tasks and appspace-internal tasks (like sending messages or resolving workers)
            two different dispatcher queues are available.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrDispatching.ICcrDispatcherService.Dispatcher">
      <summary>
            The Ccr Dispatcher.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrDispatching.ICcrDispatcherService.DispatcherQueue">
      <summary>
            The Ccr DispatcherQueue used for Worker Tasks.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrDispatching.ICcrDispatcherService.InternalDispatcherQueue">
      <summary>
            The Ccr DispatcherQueue used for AppSpace-internal tasks.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.CcrExtensions.IRemotableTask">
      <summary>
            Interface definition for a remotable ccr task (a ccr task that can send messages to a remote ccr port or portset).
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrExtensions.IRemotableTask.Send(System.Object,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.IPort)">
      <summary>
            Directly sends the given item using the tasks remote address and transport service name.
            </summary>
      <param name="item">The item to be sent.</param>
      <param name="commErrorPort">Optional port where communication errors should be posted back.</param>
      <param name="commAckPort">Optional port where communication ACK should be posted back.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrExtensions.IRemotableTask.RemoteAddress">
      <summary>
            The remote address of the original port or portset.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrExtensions.IRemotableTask.CommServiceName">
      <summary>
            The name of the transport service that should be used to send messages.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrExtensions.IRemotableTask.PortGuid">
      <summary>
            The id of the original port or portset.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.CcrExtensions.PortHelpers">
      <summary>
            This class adds extension methods to the port that are needed at the appspace for working with local and remote ports.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrExtensions.PortHelpers.GetMessageType(Microsoft.Ccr.Core.IPort)">
      <summary>
            Gets the message type of a port.
            </summary>
      <param name="port">The port.</param>
      <returns>The type of messages that can be posted to the port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrExtensions.PortHelpers.GetMessageTypes(Microsoft.Ccr.Core.IPortSet)">
      <summary>
            Gets the message types of a portset.
            </summary>
      <param name="portSet">The portset.</param>
      <returns>The types of messages that can be posted to the portset.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrExtensions.PortHelpers.GetPortInfo(Microsoft.Ccr.Core.IPort)">
      <summary>
            Gets infos that are available for this port about remote communication.
            </summary>
      <param name="port">The port.</param>
      <returns>Remote communication information about this port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrExtensions.PortHelpers.UnregisterAllReceiverTasks(Microsoft.Ccr.Core.IPort)">
      <summary>
            Unregisters all receiver tasks from the port.
            </summary>
      <param name="port">The port.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrExtensions.PortHelpers.GetRemotableTask(Microsoft.Ccr.Core.IPort)">
      <summary>
            If the port is a remote port, returns the remotable task that is registered at the port.
            Null is returned if the port is not a remote port.
            </summary>
      <param name="port">The port.</param>
      <returns>The remotable task, if the port is a remote port, otherwise null</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrExtensions.PortHelpers.GetMessageType(System.Type)">
      <summary>
            Gets the message type from a given type that inherits from Port
            </summary>
      <param name="portType">The port type</param>
      <returns>The message type of the port, or null if no message type could be found</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrExtensions.PortHelpers.GetMessageTypes(System.Type)">
      <summary>
            Gets the message type from a given type that inherits from any of the PortSet types
            </summary>
      <param name="portSetType">The port set type.</param>
      <returns>The message types of the portset, or null if no message types could be found.</returns>
    </member>
    <member name="T:XcoAppSpaces.Contracts.CcrExtensions.XcoPortInfo">
      <summary>
            Infomation about a Port concerning remote communication.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.CcrExtensions.XcoPortInfo.#ctor(System.Boolean,System.String,System.String,System.Guid)">
      <summary>
            Creates a new XcoPortInfo.
            </summary>
      <param name="isRemotePort">True if the port is a remote port.</param>
      <param name="remoteAddress">The remote address where the port is hosted, or null if the port is local.</param>
      <param name="commServiceName">The name of the transport service that the port uses, or null if the port is local.</param>
      <param name="remotePortID">The id of the port, or Guid.Empty if the port is local.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrExtensions.XcoPortInfo.IsRemotePort">
      <summary>
            True if the port is a remote port.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrExtensions.XcoPortInfo.RemoteAddress">
      <summary>
            The remote address where the port is hosted, or null if the port is local.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrExtensions.XcoPortInfo.RemotePortID">
      <summary>
            The id of the port, or Guid.Empty if the port is local.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.CcrExtensions.XcoPortInfo.CommServiceName">
      <summary>
            The name of the transport service that the port uses, or null if the port is local.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoProcessorAttribute">
      <summary>
            Base class for the attributes to mark processor methods for ccr processing.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoProcessorAttribute.MessageTransferMode">
      <summary>
            The mode in which messages coming from remote spaces are transferred for this worker port.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.MessageTransferMode">
      <summary>
            Defines the mode for transferring messages for a certain worker port when coming from remote spaces.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Core.MessageTransferMode.Parallel">
      <summary>
            Messages are transferred in parallel. This provides maximal performance, but it is not guaranteed
            that the messages arrive in the order in which they are posted.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Core.MessageTransferMode.Sequential">
      <summary>
            Messages are transferred sequentially. This guarantees that the messages arrive exactly in the
            order in which they were posted.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoWorkerExtensionAttribute">
      <summary>
            Marks a class as worker extension. When creating a worker, all methods
            of a worker extension class that are marked with XcoConcurrent, XcoExclusive
            or XcoTeardown are also taken into account as message processing methods.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoWorkerExtensionAttribute.#ctor">
      <summary>
            Creates a new XcoWorkerExtensionAttribute.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoWorkerExtensionAttribute.#ctor(System.Type[])">
      <summary>
            Creates a new XcoWorkerExtensionAttribute.
            </summary>
      <param name="required">The list of types for which a port must exist at the worker.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoWorkerExtensionAttribute.IsTypeRequired(System.Type)">
      <summary>
            Checks if the given type is required, meaning if a Port{Type} must exist at the worker for this type.
            </summary>
      <param name="type">The type to be checked.</param>
      <returns>True if the type is required.</returns>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoWorkerExtensionAttribute.Required">
      <summary>
            The list of required types (only either the required types or the optional types should be set).
            For all types in this list the worker must have a port in its contract (an exception will be thrown
            during instantiation of the worker when a port with one of these types is missing).
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.XcoWorkerExtensionAttribute.Optional">
      <summary>
            The list of optional types (only either the required types or the optional types should be set).
            For these types the worker does not require to have a port, but the port will be used by the worker
            extension if it exists.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoConcurrentAttribute">
      <summary>
            Marks a Method of a Worker for processing objects of a certain type
            that are posted to the worker concurrently. (Method and fitting port
            of the worker are added to a CCR ConcurrentReceiverGroup.)
            MessageTransferMode is "Parallel" by default.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoConcurrentAttribute.#ctor">
      <summary>
            Creates a new XcoConcurrentAttribute.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoExclusiveAttribute">
      <summary>
            Marks a Method of a Worker for processing objects of a certain type
            that are posted to the worker exclusively. (Method and fitting port
            of the worker are added to a CCR ExclusiveReceiverGroup.)
            MessageTransferMode is "Sequential" by default.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoExclusiveAttribute.#ctor">
      <summary>
            Creates a new XcoExclusiveAttribute.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.XcoTeardownAttribute">
      <summary>
            Marks a Method of a Worker for processing objects of a certain type
            that are posted to the worker. As soon as an object is processed by
            this method, all CCR ReceiverTasks that are bound to the worker's
            PortSet are shut down. (Method and fitting port of the worker are 
            added to a CCR TeardownReceiverGroup.)
            MessageTransferMode is "Parallel" by default.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.XcoTeardownAttribute.#ctor">
      <summary>
            Creates a new XcoTeardownAttribute.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.CcrWiring.CcrRemote.RemotableTask">
      <summary>
            Base class for special Ccr tasks that can send data to a remote worker or port instance.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrWiring.CcrRemote.RemotableTask.CreateMessage(System.Object)">
      <summary>
            Method that must be implemented by base classes to create a message
            that should be sent from an item that has been posted to the port
            where this task is registered.
            </summary>
      <param name="value">The item that has been posted.</param>
      <returns>The message that should be sent.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrWiring.CcrRemote.RemotableTask.PartialClone(Microsoft.Ccr.Core.IPort,XcoAppSpaces.Core.MessageTransferMode)">
      <summary>
            Partially clones the task, while using the given port and transfer mode.
            </summary>
      <param name="assignedPort">
      </param>
      <param name="mode">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:XcoAppSpaces.Core.CcrWiring.CcrRemote.NamedRemotableTask">
      <summary>
            Special Ccr task that can send data that has been posted to a port to named remote port instance
            (a worker).
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.CcrWiring.CcrRemote.AnonymousRemotableTask">
      <summary>
            Special Ccr task that can send data that has been posted to a port to an anonymous remote port instance
            (identified remotely by the given port guid).
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.CcrWiring.CcrRemote.RemotePortInfoTask">
      <summary>
            Class that holds information about a port - is only registered at a port as receiver
            to allow accessing this information via the IPort.GetRemotableTask() extension method.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.CcrWiring.CcrWirer">
      <summary>
            Service for wiring workers, worker proxies and remote ports with the Ccr
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrWiring.CcrWirer.#ctor">
      <summary>
            Creates a new CcrWirer.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrWiring.CcrWirer.Initialize(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Gets the ccr dispatcher service from the space's service registry, which is needed
            to activate new ccr tasks for workers, worker proxies and remote ports.
            </summary>
      <param name="serviceRegistry">The registry where the service of the space instance are registered</param>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrWiring.CcrWirer.CreateWorker``2(Microsoft.Ccr.Core.DispatcherQueue)">
      <summary>
            Creates a new Worker and wires the worker ports with the message handlers contained in the worker class.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <typeparam name="TImplementation">The implementation type of the worker.</typeparam>
      <param name="dpq">The dispatcher queue that should be used for wiring the worker, or null if space's the default dispatcher queue should be used.</param>
      <returns>A WorkerInfo object containing the worker instance and additional information that has been gathered during the worker wiring.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrWiring.CcrWirer.WireWorker``1(``0,Microsoft.Ccr.Core.DispatcherQueue)">
      <summary>
            Wires a given worker's ports with its message handlers.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="worker">The worker instance.</param>
      <param name="dpq">The dispatcher queue that should be used for wiring the worker, or null if space's the default dispatcher queue should be used.</param>
      <returns>A WorkerInfo object containing the worker instance and additional information that has been gathered during the worker wiring.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrWiring.CcrWirer.CreateWorkerProxy``1(XcoAppSpaces.Contracts.Messaging.WorkerProxyInfo)">
      <summary>
            Creates a worker proxy for a remote worker from the given parameters.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker (must have an empty constructor so it can be instantiated as a proxy).</typeparam>
      <param name="proxyInfo">Information that is needed to create the worker proxy, like name and address of the worker.</param>
      <returns>The created worker proxy.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrWiring.CcrWirer.UnwireWorker(Microsoft.Ccr.Core.IPort)">
      <summary>
            Removes all registered receiver tasks from all ports of the worker.
            </summary>
      <param name="worker">The worker that should be unwired.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrWiring.CcrWirer.GetPortSerializationInfo(Microsoft.Ccr.Core.IPort)">
      <summary>
            Gets a serialization info object that contains all information that is needed by the receiving space
            to deserialize the worker. The current serialization context is used to get the local adress, and
            to register the port at the local space and get a unique id for the port, if it is not already
            a remote port.
            </summary>
      <param name="port">The port to be serialized.</param>
      <returns>Object containing the info that must be sent to the remote space for deserialization of the port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrWiring.CcrWirer.WireRemotePort(Microsoft.Ccr.Core.IPort,XcoAppSpaces.Contracts.CcrWiring.XcoPortSerializationInfo)">
      <summary>
            Wires a port using the given serialization info, so that it is ready for remote communication. The
            current serialization context is used to get the name of the communication service that should be
            used to send messages to the original port.
            </summary>
      <param name="port">The port to be wired.</param>
      <param name="portSerializationInfo">Info that is needed for wiring the remote port, like the port's id and remote address.</param>
    </member>
    <member name="T:XcoAppSpaces.Core.CcrWiring.PortHelpers">
      <summary>
            This class adds extension methods to the port that are needed at the appspace for serializing and deserializing ports,
            as well as registering remotable tasks.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrWiring.PortHelpers.GetPortSerializationInfo(Microsoft.Ccr.Core.IPort)">
      <summary>
            Gets infos that are available for this port about remote communication.
            </summary>
      <param name="port">The port.</param>
      <returns>Remote communication information about this port.</returns>
    </member>
    <member name="T:XcoAppSpaces.Core.CcrWiring.WorkerFactory">
      <summary>
            The WorkerFactory class is responsible for creating workers and wiring their ports to the appropriate
            message handlers.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.CcrDispatching.CcrDispatcherService">
      <summary>
            Service that provides ccr dispatchers and dispatcher queues for ccr task dispatching.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrDispatching.CcrDispatcherService.#ctor">
      <summary>
            Creates a new CcrDispatcherService.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrDispatching.CcrDispatcherService.#ctor(System.Int32)">
      <summary>
            Creates a new CcrDispatcherService.
            </summary>
      <param name="ccrThreadCount">The number of threads that should be used.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrDispatching.CcrDispatcherService.#ctor(Microsoft.Ccr.Core.Dispatcher)">
      <summary>
            Creates a new CcrDispatcherService using an external dispatcher.
            </summary>
      <param name="dispatcher">The dispatcher that should be used.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrDispatching.CcrDispatcherService.Start">
      <summary>
            Starts the service.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrDispatching.CcrDispatcherService.Stop">
      <summary>
            Stops the service by disposing the used Dispatchers und DispatcherQueues. If an external dispatcher is used, it is not disposed.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.CcrDispatching.CcrDispatcherService.Initialize(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Initializes the service (does nothing in case of the CcrDispatcherService).
            </summary>
      <param name="serviceRegistry">
      </param>
    </member>
    <member name="P:XcoAppSpaces.Core.CcrDispatching.CcrDispatcherService.Dispatcher">
      <summary>
            The Ccr Dispatcher.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.CcrDispatching.CcrDispatcherService.DispatcherQueue">
      <summary>
            The Ccr DispatcherQueue used for Worker Tasks.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.CcrDispatching.CcrDispatcherService.InternalDispatcherQueue">
      <summary>
            The Ccr DispatcherQueue used for AppSpace-internal tasks.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.CcrDispatching.CcrDispatcherService.StartPriority">
      <summary>
            The start priority of the service.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.CcrDispatching.ConfigStringInterpreter">
      <summary>
            ConfigStringInterpreter for the CcrDispatcherService
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Core.CcrDispatching.ConfigStringInterpreter.Config_Ccr_Threadcount">
      <summary>
            Configuration key for the ccr thread count.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.CcrDispatching.ConfigStringInterpreter.GetService">
      <summary>
            Returns a new CcrDispatcherService, if the thread count has been set.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.CcrDispatching.ConfigStringInterpreter.InterpretDefinition">
      <summary>
            Action definition for interpretion
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.Configuration.DefaultInterpreters">
      <summary>
            Defines the service implementations and config string interpreters that are used by default.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.Configuration.DefaultServices">
      <summary>
            Defines the service implementations and config string interpreters that are used by default.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.Configuration.Interpreters.SerializerConfigStringInterpreter">
      <summary>
            Config string interpreter for defining which serializer is used. Since
            the serializers themselves don't have any configurable values, this interpreter
            simply allows defining the used serializer by name.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Configuration.Interpreters.SerializerConfigStringInterpreter.InterpretDefinition">
      <summary>
            Action definition for interpretion
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Configuration.Interpreters.SerializerConfigStringInterpreter.GetService">
      <summary>
            Returns the configured serializer
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.Configuration.IXcoConfiguration">
      <summary>
            Interface definition for a configuration object that allows configuring an appspace instance.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.Configuration.IXcoConfiguration.InitServiceRegistry(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Initializes the service registry by adding instances for all services that are needed
            by an appspace instance.
            </summary>
      <param name="reg">The service registry that should be initalized.</param>
    </member>
    <member name="T:XcoAppSpaces.Core.Configuration.SpaceStringConfigurator">
      <summary>
            The SpaceStringConfigurator class allows to configure an appspace instance using a config string.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.Configuration.SpaceStringConfigurator.CreateConfig(System.String)">
      <summary>
            Creates an XcoAppSpaceConfiguration object from the given config string, which can then be used to create a
            new appspace instance with the given configuration. An XcoConfigurationException is thrown if the config 
            string is invalid.
            </summary>
      <param name="configString">The config string for which the configuration object should be created.</param>
      <returns>The configuration that was created from the config string.</returns>
    </member>
    <member name="T:XcoAppSpaces.Core.Configuration.XcoAppSpaceConfig">
      <summary>
            Fluent interface for creating an XcoAppSpace.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.Configuration.XcoAppSpaceConfig.#ctor">
      <summary>
            Creates a new XcoAppSpaceConfiguration.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.Configuration.XcoAppSpaceConfig.AddService(XcoAppSpaces.Contracts.Service.IXcoService)">
      <summary>
            Adds a service to the XcoAppSpaceConfiguration instance.
            </summary>
      <param name="service">The service instance that should be added.</param>
      <returns>An XcoServiceConfiguration instance that allows further configuration of the service.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.Configuration.XcoAppSpaceConfig.AddService(XcoAppSpaces.Contracts.Service.IXcoService,System.String,System.Boolean)">
      <summary>
            Defines a service that the XcoAppSpace should use (if not defined, the default for this type of service is used). An
            exception is thrown if the type of service is unknown.
            </summary>
      <param name="service">The service that the XcoAppSpace should use.</param>
      <param name="name">The name of the service.</param>
      <param name="isDefault">True if the service is the default.</param>
      <returns>An XcoServiceConfiguration instance to configure the service.</returns>
    </member>
    <member name="M:XcoAppSpaces.Core.Configuration.XcoAppSpaceConfig.InitServiceRegistry(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Initializes the service registry by adding instances for all services that are part of this
            XcoAppSpaceConfiguration instance. For any service that has not been configured explicitly,
            an instance of the default service for this service type is added.
            </summary>
      <param name="reg">The service registry that should be initalized.</param>
    </member>
    <member name="P:XcoAppSpaces.Core.Configuration.XcoAppSpaceConfig.CcrDispatcher">
      <summary>
            The configured ccr dispatcher instance (or null, if no special instance has been configured).
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Core.Configuration.XcoServiceConfig">
      <summary>
            Class for XcoService configurations.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Core.Configuration.XcoServiceConfig.AddMapping(System.Type,System.String)">
      <summary>
            Adds a mapping to another service of the given type.
            </summary>
      <param name="serviceType">The service type.</param>
      <param name="serviceName">The service name.</param>
    </member>
    <member name="M:XcoAppSpaces.Core.Configuration.XcoServiceConfig.op_Implicit(XcoAppSpaces.Core.Configuration.XcoServiceConfig)~XcoAppSpaces.Contracts.Service.XcoServiceConfiguration">
      <summary>
            Converts an XcoServiceConfig into an XcoServiceConfiguration.
            </summary>
      <param name="config">The XcoServiceConfig.</param>
      <returns>An XcoServiceConfiguration.</returns>
    </member>
    <member name="P:XcoAppSpaces.Core.Configuration.XcoServiceConfig.ServiceType">
      <summary>
            The type of the service.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Configuration.XcoServiceConfig.Mappings">
      <summary>
            Mappings to other services.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Configuration.XcoServiceConfig.ConfiguredService">
      <summary>
            The service instance.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Configuration.XcoServiceConfig.Name">
      <summary>
            The name of the service.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Core.Configuration.XcoServiceConfig.IsDefault">
      <summary>
            True if the service is the default for this type of service.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Communication.ICommunicationEvents">
      <summary>
            Events giving information about incoming and outgoing communication, e.g. for monitoring
            </summary>
    </member>
    <member name="E:XcoAppSpaces.Contracts.Communication.ICommunicationEvents.OnSendingMessage">
      <summary>
            Event that is triggered before a message is sent. Contains the serialized message parts, address and name of the transport service.
            </summary>
    </member>
    <member name="E:XcoAppSpaces.Contracts.Communication.ICommunicationEvents.OnMessageReceived">
      <summary>
            Event that is triggered after a message has been received. Contains the serialized message parts, address and name of the transport service.
            </summary>
    </member>
    <member name="E:XcoAppSpaces.Contracts.Communication.ICommunicationEvents.OnWorkerResolved">
      <summary>
            Event that is triggered when a request from a remote space is received to resolve a local worker, which is the case when "ConnectWorker"
            is called on the remote space. Contains information about who sent the resolve request, the identifier of the worker that should be resolved
            and the result which will be sent to the remote space.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Communication.MessageEventArgs">
      <summary>
            Event args for message events.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Communication.MessageEventArgs.Message">
      <summary>
            The message that is being sent or received, in serialized state.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Communication.MessageEventArgs.Address">
      <summary>
            The address where the message is sent / from where it has been received.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Communication.MessageEventArgs.TransportServiceName">
      <summary>
            The name of the used transport service.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Communication.WorkerResolveEventArgs">
      <summary>
            Event args for the OnWorkerResolved event.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Communication.WorkerResolveEventArgs.WorkerIdentifier">
      <summary>
            The identifier of the worker (built from workertype/workername) that should be resolved.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Communication.WorkerResolveEventArgs.RemoteAddress">
      <summary>
            The address of the space that sent the resolve request.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Communication.WorkerResolveEventArgs.Result">
      <summary>
            The result that will be sent.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Communication.IConnector">
      <summary>
            Service for connecting to remote workers and handling the space's transport services, as well as communication errors.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Communication.IConnector.IsLocal(System.String)">
      <summary>
            Checks a certain address if it is the address of the local space. This is the case if the
            address is either NULL of if it is equal (ignoring case) to the local address.
            </summary>
      <param name="address">The address to be checked.</param>
      <returns>True if the address refers to the local space.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Communication.IConnector.ConnectWorker``1(System.String,System.String,System.Net.ICredentials)">
      <summary>
            Establishes a connection to a worker that is running at a remote space. Returns information that
            can be used to generate proxy of the worker that allows posting messages that are automatically 
            transported to the worker.
            If the worker does't exist or the connection to the space cannot be established, an
            XcoCommunicationException is thrown.
            </summary>
      <typeparam name="TContract">The contract type of the worker to connect to.</typeparam>
      <param name="workerAddress">The address of the worker in den form "address/workername"</param>
      <param name="commServiceName">The name of the communication service that should be used to communicate with the worker (or null if the default communication service should be used).</param>
      <param name="credentials">The credentials that should be used to connect to the worker.</param>
      <returns>Information about the worker that can be used to generate a proxy to communicate with this worker.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Communication.IConnector.ConnectWorker``1(System.String,System.String,System.String,System.Net.ICredentials)">
      <summary>
            Establishes a connection to a worker that is running at a remote space. Returns information that
            can be used to generate proxy of the worker that allows posting messages that are automatically 
            transported to the worker.
            If the worker does't exist or the connection to the space cannot be established, an
            XcoCommunicationException is thrown.
            </summary>
      <typeparam name="TContract">The contract type of the worker to connect to.</typeparam>
      <param name="name">The name of the worker.</param>
      <param name="address">The address of the space where the worker is running (in form hostname:port).</param>
      <param name="commServiceName">The name of the communication service that should be used to communicate with the worker (or null if the default communication service should be used).</param>
      <param name="credentials">The credentials that should be used to connect to the worker.</param>
      <returns>Information about the worker that can be used to generate a proxy to communicate with this worker.</returns>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Communication.IConnector.LocalAddress">
      <summary>
            The local address of the space (in form hostname:port).
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Communication.IConnector.CommServices">
      <summary>
            The list of registered communication services.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Communication.IConnector.Errors">
      <summary>
            Port where communication errors are posted that are not caught by causalities.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Communication.IConnector.CommunicationEvents">
      <summary>
            Events giving information about incoming and outgoing communication, e.g. for monitoring
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Communication.XcoCommunicationError">
      <summary>
            Description for an error that occurred during communication (serialization, 
            send/receive, deserialization).
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Communication.XcoCommunicationError.#ctor">
      <summary>
            Creates a new XcoCommunicationError.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Communication.XcoCommunicationError.#ctor(System.Exception,System.String,System.String)">
      <summary>
            Creates a new XcoCommunicationError.
            </summary>
      <param name="error">The exception that has been thrown.</param>
      <param name="info">Additional info to the error.</param>
      <param name="sourceAddress">The address of the space where the error occurred.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Communication.XcoCommunicationError.Error">
      <summary>
            The exception that has been thrown.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Communication.XcoCommunicationError.Info">
      <summary>
            Additional info to the error.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Communication.XcoCommunicationError.SourceAddress">
      <summary>
            The address of the space where the error occurred.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Messaging.Ack">
      <summary>
            Acknowledge for successful message transfer.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.Ack.#ctor(System.DateTime)">
      <summary>
            Creates a new Ack.
            </summary>
      <param name="date">The date when the message has been transferred.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.Ack.Date">
      <summary>
            The date when the message has been transferred.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Messaging.CausalityContext">
      <summary>
            Context information that can be sent together with a message
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.CausalityContext.#ctor">
      <summary>
            Creates a new CausalityContext.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.CausalityContext.#ctor(XcoAppSpaces.Contracts.Messaging.CausalityInfo[])">
      <summary>
            Creates a new CausalityContext.
            </summary>
      <param name="causalities">List of causalities that should be installed for processing the message.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.CausalityContext.Causalities">
      <summary>
            List of causalities that should be installed for processing the message.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Messaging.CausalityInfo">
      <summary>
            Information about a causality
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.CausalityInfo.#ctor">
      <summary>
            Creates a new CausalityInfo.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.CausalityInfo.#ctor(Microsoft.Ccr.Core.ICausality)">
      <summary>
            Creates a new CausalityInfo.
            </summary>
      <param name="c">The causality from which the relevant information should be taken.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.CausalityInfo.Name">
      <summary>
            The name of the causality.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.CausalityInfo.ExceptionPort">
      <summary>
            The exception port of the causality.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.CausalityInfo.CoordinationPort">
      <summary>
            The coordinatio port of the causality.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Messaging.MessageToSend">
      <summary>
            Provides information about a message to be sent.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.MessageToSend.#ctor(System.String,System.String,XcoAppSpaces.Contracts.Messaging.CausalityContext,XcoAppSpaces.Contracts.Messaging.RemoteMessage,Microsoft.Ccr.Core.Port{System.Exception},Microsoft.Ccr.Core.Port{XcoAppSpaces.Contracts.Messaging.Ack})">
      <summary>
            Creates a new MessageToSend.
            </summary>
      <param name="remoteAddress">The address of the space the message should be sent to.</param>
      <param name="commServiceName">The name of the transport service that should be used to send the message.</param>
      <param name="context">The causality context of the message.</param>
      <param name="data">The messsage to be sent.</param>
      <param name="commErrorPort">Optional port for communication errors.</param>
      <param name="commAckPort">Optional port for communication ACK.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.MessageToSend.RemoteAddress">
      <summary>
            The address of the space the message should be sent to.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.MessageToSend.CommServiceName">
      <summary>
            The name of the transport service that should be used to send the message.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.MessageToSend.Context">
      <summary>
            The causality context of the message.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.MessageToSend.Data">
      <summary>
            The messsage to be sent.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.MessageToSend.CommErrorPort">
      <summary>
            Optional port for posting back communication errors. If this port is set, then not the causality
            will be used for communication errors, but this port. This is e.g. used when using Send() instead
            of Post().
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.MessageToSend.CommAckPort">
      <summary>
            Optional port for posting back ack when the message has been successfullly sent. If this port 
            is set, then not the causality coordination port will be used for ack, but this port. This
            is e.g. used when using Send() instead of Post() to prevent the need of installing a causality
            just for the ACK functionality.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Messaging.RemoteMessage">
      <summary>
            Base definition for remote messages
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.RemoteMessage.#ctor(System.Object)">
      <summary>
            Creates a new RemoteMessage.
            </summary>
      <param name="msg">The message data.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.RemoteMessage.Msg">
      <summary>
            The message data.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Messaging.RemotePortMessage">
      <summary>
            Message that is sent to a remote port.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.RemotePortMessage.#ctor">
      <summary>
            Creates a new RemotePortMessage.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.RemotePortMessage.#ctor(System.Guid,System.Object)">
      <summary>
            Creates a new RemotePortMessage.
            </summary>
      <param name="portID">The id of the port.</param>
      <param name="msg">The message data.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.RemotePortMessage.ToString">
      <summary>
            Returns a string representation of the RemotePortMessage.
            </summary>
      <returns>A string representation of the RemotePortMessage</returns>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.RemotePortMessage.PortID">
      <summary>
            The id of the port.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Messaging.SerializationContext">
      <summary>
            Provides thread-based context information needed for serialization and deserialization of ports and portsets.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.SerializationContext.#ctor(System.Func{Microsoft.Ccr.Core.IPort,System.Guid},Microsoft.Ccr.Core.Handler{XcoAppSpaces.Contracts.Messaging.MessageToSend},System.String,System.String)">
      <summary>
            Creates a new SerializationContext and assigns it to the SerializationContext.Current property of the current thread.
            </summary>
      <param name="registerPort">Delegate to register a port at the local space instance.</param>
      <param name="messageProcessor">Delegate that can be used to send messages to remote space instances.</param>
      <param name="localAddress">The local space address.</param>
      <param name="currentCommServiceName">The name of the communication service where the message is sent/received.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.SerializationContext.RegisterPort(Microsoft.Ccr.Core.IPort)">
      <summary>
            Registers a port at the local space instance, and assigns a unique id to this port.
            This allows remote space instances to send messages to this port, if they know its id. 
            </summary>
      <param name="port">The port to be registered.</param>
      <returns>Unique id that has been assigned to the port.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.SerializationContext.Dispose">
      <summary>
            Disposes the SerializationContext and removes it from the current thread.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.SerializationContext.Current">
      <summary>
            The serialization context for the current thread.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.SerializationContext.MessageProcessor">
      <summary>
            Delegate that can be used to send messages to remote space instances.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.SerializationContext.LocalAddress">
      <summary>
            The local space address.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.SerializationContext.CurrentCommServiceName">
      <summary>
            The name of the communication service where the message is sent/received.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Messaging.WorkerMessage">
      <summary>
            Message that is sent to a remote worker.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.WorkerMessage.#ctor">
      <summary>
            Creates a new WorkerMessage.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.WorkerMessage.#ctor(System.String,System.Guid,System.Object)">
      <summary>
            Creates a new WorkerMessage.
            </summary>
      <param name="workerIdentifier">Identifier of the worker, built out of the worker's type and name.</param>
      <param name="sessionID">The session id needed for authentication.</param>
      <param name="msg">The message data.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.WorkerMessage.ToString">
      <summary>
            Returns a string representation of the WorkerMessage.
            </summary>
      <returns>A string representation of the WorkerMessage</returns>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.WorkerMessage.WorkerIdentifier">
      <summary>
            Identifier for the worker, built from workertype/workername.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.WorkerMessage.SessionID">
      <summary>
            The session id needed for authentication.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Messaging.WorkerProxyInfo">
      <summary>
            Information about a worker that is needed to create a worker proxy.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.WorkerProxyInfo.#ctor">
      <summary>
            Creates a new WorkerProxyInfo.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Messaging.WorkerProxyInfo.#ctor(System.Type,System.String,System.String,System.String,System.String,System.Guid,System.Collections.Generic.Dictionary{System.Type,XcoAppSpaces.Core.XcoProcessorAttribute},Microsoft.Ccr.Core.Handler{XcoAppSpaces.Contracts.Messaging.MessageToSend})">
      <summary>
            Creates a new WorkerProxyInfo.
            </summary>
      <param name="contractType">The contract type of the worker.</param>
      <param name="name">The name of the worker.</param>
      <param name="address">The address of the space where the worker is hosted.</param>
      <param name="identifier">Identifier of the worker, built out of the worker's type and name.</param>
      <param name="commServiceName">The name of the transport service that should be used to send messages to the worker.</param>
      <param name="sessionID">The id of the session that should be used to communicate with the worker.</param>
      <param name="processorAttributes">List of attributes of the processors of this worker.</param>
      <param name="messageProcessor">Method that takes messages that should be sent from the proxy.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.WorkerProxyInfo.ContractType">
      <summary>
            The contract type of the worker.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.WorkerProxyInfo.WorkerName">
      <summary>
            The name of the worker.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.WorkerProxyInfo.WorkerAddress">
      <summary>
            The address of the space where the worker is hosted.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.WorkerProxyInfo.WorkerIdentifier">
      <summary>
            The address of the space where the worker is hosted.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.WorkerProxyInfo.CommServiceName">
      <summary>
            The name of the transport service that should be used to send messages to the worker.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.WorkerProxyInfo.SessionID">
      <summary>
            The id of the session that should be used to communicate with the worker.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.WorkerProxyInfo.ProcessorAttributes">
      <summary>
            List of attributes of the processors of this worker.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Messaging.WorkerProxyInfo.MessageProcessor">
      <summary>
            Method that takes messages that should be sent from the proxy.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Service.IXcoServiceFluentConfiguration`2">
      <summary>
            Interface that is implemented by classes allowing fluent service configuration. Allows
            service implementations to extend the configuration of their own service with additional
            extension methods.
            </summary>
      <typeparam name="TService">The type of service that is getting configured.</typeparam>
      <typeparam name="TConfig">The type of configuration object that should be returned for further configuration with the fluent interface.</typeparam>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.IXcoServiceFluentConfiguration`2.Service">
      <summary>
            The service that is getting configured.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.IXcoServiceFluentConfiguration`2.FluentConfig">
      <summary>
            The configuration object that should be returned for further configuration with the fluent interface.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Service.IXcoConfigStringInterpreter">
      <summary>
            Interface for classes that are able to interpret a space configuration.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.IXcoConfigStringInterpreter.Interpret(System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Interprets the given configuration string and, according to the configuration string elements,
            alters the space configuration (e.g. by adding new services or altering the configuration of already
            added services).
            </summary>
      <param name="configStringElements">Dictionary of configuration elements (key-value pairs)</param>
      <returns>Configuration for the service</returns>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.IXcoConfigStringInterpreter.InterpretKeys">
      <summary>
            Returns a list of the keys that can be understood by this interpreter.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Service.IXcoService">
      <summary>
            Interface for services that can be used by an XcoAppSpace.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.IXcoService.Initialize(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Initializes the services. Hands over the service registry, so the service can get access 
            to other services of the appspace instance, if it needs to.
            </summary>
      <param name="serviceRegistry">The service registry of the current appspace instance.</param>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Service.IXcoServiceRegistry">
      <summary>
            The service registry contains all services of a space instance and can initialize, start and stop
            its services.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.IXcoServiceRegistry.Resolve``1">
      <summary>
            Gets the service with the given type from the registry.
            </summary>
      <typeparam name="T">The type of the service.</typeparam>
      <returns>The resolved service instance, or null if no instance could be found.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.IXcoServiceRegistry.Resolve``1(System.String)">
      <summary>
            Gets the service with the given type and name from the registry.
            </summary>
      <typeparam name="T">The type of the service.</typeparam>
      <param name="name">The name of the service.</param>
      <returns>The resolved service instance, or null if no instance could be found.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.IXcoServiceRegistry.ResolveAll``1">
      <summary>
            Gets all services with the given type from the registry.
            </summary>
      <typeparam name="T">The type of the service.</typeparam>
      <returns>List of all services including their configuration data.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.IXcoServiceRegistry.Register``1(``0)">
      <summary>
            Registers a new service at the registry.
            </summary>
      <typeparam name="T">The type of the service.</typeparam>
      <param name="service">The service instance.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.IXcoServiceRegistry.Register(XcoAppSpaces.Contracts.Service.XcoServiceConfiguration)">
      <summary>
            Registers a new service at the registry.
            </summary>
      <param name="service">The service to be added.</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.IXcoServiceRegistry.InitializeServices">
      <summary>
            Initializes all services in the registry, by calling their Initialize methods.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.IXcoServiceRegistry.StartServices">
      <summary>
            Starts all stateful services in the registry by calling their Start methods (in the order 
            according to the start priority of the services).
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.IXcoServiceRegistry.StopServices">
      <summary>
            Stops all stateful services in the registry by calling their Stop methods.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Service.IXcoStatefulService">
      <summary>
            Interface for stateful services that can be used by an XcoAppSpace.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.IXcoStatefulService.Start">
      <summary>
            Starts the service.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.IXcoStatefulService.Stop">
      <summary>
            Stops the service.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.IXcoStatefulService.StartPriority">
      <summary>
            StartPriority for the service (services with a low priority are started first, e.g. priority 1 comes before priority 5).
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Service.XcoConfigStringInterpreterBase">
      <summary>
            Basic interpreter for service config strings
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.XcoConfigStringInterpreterBase.Interpret(System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Interprets the given configuration string and, according to the configuration string elements, creates
            an XcoServiceConfiguration instance if needed config string elements are present.
            </summary>
      <param name="configStringElements">Dictionary of configuration elements (key-value pairs)</param>
      <returns>Configuration for the service</returns>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.XcoConfigStringInterpreterBase.ServiceConfig">
      <summary>
            Configuration of the service
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.XcoConfigStringInterpreterBase.InterpretDefinition">
      <summary>
            The interpret definition for all config strings 
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.XcoConfigStringInterpreterBase.GetService">
      <summary>
            Get serviceinstance
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.XcoConfigStringInterpreterBase.InterpretKeys">
      <summary>
            Returns a list of the keys that can be understood by this interpreter.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Service.XcoServiceAttribute">
      <summary>
            Base class for attributes that can be added to Workers (and/or their Methods/Fields)
            and should be recognized when instantiating a worker because a service
            needs them (e.g. security service).
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Service.XcoServiceAttributeInfo">
      <summary>
            Information about a service attribute that belongs to a certain worker or one of its message processor methods.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.XcoServiceAttributeInfo.Attr">
      <summary>
            The attribute instance.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.XcoServiceAttributeInfo.WorkerMessageType">
      <summary>
            The message type the given attribute was assigned to, or null if the attribute belongs to the worker directly.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Service.XcoServiceConfiguration">
      <summary>
            Configuration for an IXcoService instance.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.XcoServiceConfiguration.AddMapping``1(System.String)">
      <summary>
            Adds a mapping for the given service type.
            </summary>
      <typeparam name="T">The service type.</typeparam>
      <returns>Mapping for the given type.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.XcoServiceConfiguration.GetMapping``1">
      <summary>
            Gets the mapping name that is registered for the given service type, or null of no mapping exists.
            </summary>
      <typeparam name="T">The service type.</typeparam>
      <returns>Mapping for the given type.</returns>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.XcoServiceConfiguration.Name">
      <summary>
            The name of the service.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.XcoServiceConfiguration.IsDefault">
      <summary>
            True if the service is a default service. (E.g. default communication service which
            is used as default by the space if no other communication service is chosen)
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.XcoServiceConfiguration.Service">
      <summary>
            The service instance.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.XcoServiceConfiguration.ServiceType">
      <summary>
            The type of the service.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.XcoServiceConfiguration.Mappings">
      <summary>
            Explicit mappings to other services. Meaning of the mappings depends on the type of the service.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Service.XcoServiceConfiguration`1">
      <summary>
            Configuration for an IXcoService instance.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Service.XcoServiceConfiguration`1.#ctor">
      <summary>
            Creates a new XcoServiceConfiguration.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Service.XcoServiceConfiguration`1.Service">
      <summary>
            The service instance.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Transport.MessageReceivedDelegate">
      <summary>
            Delegate definition for event that is raised by a transport service when a message is received.
            </summary>
      <param name="msg">The received message.</param>
      <param name="remoteAddress">The address from which the message was received.</param>
      <param name="commService">The transport service that received the message.</param>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Transport.IXcoTransportService">
      <summary>
            Interface definition for Services that can be used for communication between application spaces.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Transport.IXcoTransportService.Send(XcoAppSpaces.Contracts.Transport.XcoMessage,System.String)">
      <summary>
            Sends a message to a remote space.
            </summary>
      <param name="msg">The messages that should be sent.</param>
      <param name="remoteAddress">The address of the space where the message should be sent.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Transport.IXcoTransportService.LocalAddress">
      <summary>
            The address of the server.
            </summary>
    </member>
    <member name="E:XcoAppSpaces.Contracts.Transport.IXcoTransportService.OnMessageReceived">
      <summary>
            Event that is raised when a message is received.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Transport.XcoMessage">
      <summary>
            Interface definition for a message to be sent by remote communication.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Transport.XcoMessage.RaiseTransferSuccessfulEvent">
      <summary>
            Method to allow the transport service raising the OnTransferSuccessful event.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Transport.XcoMessage.RaiseTransferFailedEvent(System.Exception)">
      <summary>
            Method to allow the transport service raising the OnTransferFailed event.
            </summary>
      <param name="ex">Exception explaining why the transfer failed.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Transport.XcoMessage.CausalityContext">
      <summary>
            The causality context of the message, defining the causalities
            that should be installed for processing the message.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Transport.XcoMessage.Content">
      <summary>
            The content of the message.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Transport.XcoMessage.ContentInfo">
      <summary>
            Info about the message content that can be used for an error message if deserialization fails.
            </summary>
    </member>
    <member name="E:XcoAppSpaces.Contracts.Transport.XcoMessage.OnTransferSuccessful">
      <summary>
            Event that is raised by the transport service when the transfer of the message was successful.
            </summary>
    </member>
    <member name="E:XcoAppSpaces.Contracts.Transport.XcoMessage.OnTransferFailed">
      <summary>
            Event that is raised by the transport service when the transfer of the message failed.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Worker.WorkerEventHandler">
      <summary>
            Delegate used for events when the worker is added or removed.
            </summary>
      <param name="sender">The IXcoWorkerRegistry instance that triggered the event.</param>
      <param name="workerInfo">Information about the worker that has been added or removed.</param>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Worker.IXcoWorkerRegistry">
      <summary>
            Interface for class that provides access to the registry of local workers. Allows
            to resolve workers, check if a worker exists and register new ones.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Worker.IXcoWorkerRegistry.Register``1(``0,System.String)">
      <summary>
            Registers a new worker.
            </summary>
      <typeparam name="TContract">The contract type of the worker.</typeparam>
      <param name="instance">The worker instance to be registered.</param>
      <param name="name">The name of the worker (null if the worker doesn't have a name).</param>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Worker.IXcoWorkerRegistry.Exists(System.String,System.Boolean,System.Boolean)">
      <summary>
            Checks if a certain worker exists.
            </summary>
      <param name="workerIdentifier">Identifier of the worker, built out of the worker's type and name.</param>
      <param name="onlyPublished">Only search for published workers.</param>
      <param name="connectionRequest">True if the method is called because of a connection request.</param>
      <returns>True if a worker with the given type and name exists.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Worker.IXcoWorkerRegistry.Resolve(System.String,System.Boolean)">
      <summary>
            Resolves a worker from the registry and returns an info object that contains
            the worker object and further information about the worker.
            </summary>
      <param name="workerIdentifier">Identifier of the worker, built out of the worker's type and name.</param>
      <param name="onlyPublished">Only search for published workers.</param>
      <returns>A worker info object for the worker, if one with the given type and name exists, otherwise null.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Worker.IXcoWorkerRegistry.Resolve``1(System.String)">
      <summary>
            Resolves a worker from the registry.
            </summary>
      <typeparam name="TMessageContract">The contract type of the worker.</typeparam>
      <param name="name">The name of the worker.</param>
      <returns>The worker instance, if one with the given type and name exists, otherwise null.</returns>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Worker.IXcoWorkerRegistry.GenerateIdentifier(System.Type,System.String)">
      <summary>
            Generates an identifier string for the given worker type and name.
            </summary>
      <param name="workerType">Worker type.</param>
      <param name="workerName">Worker name (or null, if the worker doesn't have a name).</param>
      <returns>
      </returns>
    </member>
    <member name="E:XcoAppSpaces.Contracts.Worker.IXcoWorkerRegistry.WorkerAdded">
      <summary>
            Event that is triggered when a new worker is added to the worker registry.
            </summary>
    </member>
    <member name="E:XcoAppSpaces.Contracts.Worker.IXcoWorkerRegistry.WorkerRemoved">
      <summary>
            Event that is triggered when an existing worker is removed form the worker registry.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Worker.PublishMode">
      <summary>
             Defines if a worker should be published so other appspace
             instances can connnect to it
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Contracts.Worker.PublishMode.Unpublished">
      <summary>
             Worker will no be published, invisible for other spaces.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Contracts.Worker.PublishMode.Published">
      <summary>
             Worker will be published, so other space instance can connect to it.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.Worker.XcoWorkerInfo">
      <summary>
            Presents information about a worker in the space.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Contracts.Worker.XcoWorkerInfo.#ctor(Microsoft.Ccr.Core.IPort,System.Type,System.String,XcoAppSpaces.Contracts.Worker.PublishMode,System.Collections.Generic.List{XcoAppSpaces.Contracts.Service.XcoServiceAttributeInfo},System.Collections.Generic.Dictionary{System.Type,XcoAppSpaces.Core.XcoProcessorAttribute},System.Boolean,System.String,System.String,System.String)">
      <summary>
            Creates a new XcoWorkerInfo.
            </summary>
      <param name="instance">The worker instance.</param>
      <param name="contractType">The contract type of the worker.</param>
      <param name="name">The name of the worker.</param>
      <param name="publishMode">The publish mode of the worker, specifies if the worker is visible to remote spaces.</param>
      <param name="serviceAttributes">List of attributes of the worker, that could be interesting to services of the space.</param>
      <param name="processorAttributes">List of attributes of the processors of this worker.</param>
      <param name="isRemote">True if the worker is not local, but actually hosted by another appspace instance.</param>
      <param name="remoteAddress">The remote address of the worker, or null if the worker is local.</param>
      <param name="transportServiceName">Information about the transport service that the worker uses, or null if the worker is local.</param>
      <param name="identifier">Identifier of the worker, built out of the worker's type and name.</param>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Worker.XcoWorkerInfo.Name">
      <summary>
            The name of the worker.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Worker.XcoWorkerInfo.IsPublished">
      <summary>
            True if the worker is published (reachable by other appspace instances).
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Worker.XcoWorkerInfo.IsRemote">
      <summary>
            True if the worker is not local, but actually hosted by another appspace instance.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Worker.XcoWorkerInfo.RemoteAddress">
      <summary>
            The remote address of the worker, or null if the worker is local.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Worker.XcoWorkerInfo.TransportServiceName">
      <summary>
            Information about the transport service that the worker uses, or null
            if the worker is local.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Worker.XcoWorkerInfo.Identifier">
      <summary>
            Identifier of the worker, built from the worker's type and name
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Worker.XcoWorkerInfo.Worker">
      <summary>
            The worker instance.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Worker.XcoWorkerInfo.ContractType">
      <summary>
            The contract type of the worker.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Worker.XcoWorkerInfo.ServiceAttributes">
      <summary>
            List of attributes of the worker, that could be interesting to services of the space.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Worker.XcoWorkerInfo.ProcessorAttributes">
      <summary>
            List of attributes of the processors of this worker.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.Worker.XcoWorkerInfo.NumberOfConnections">
      <summary>
            The number of connections to the worker (= how many times the "ConnectWorker" method
            was called to connect to this worker).
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.WorkerResolve.ResolveRequest">
      <summary>
            Message class for a request to resolve a certain worker.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.WorkerResolve.ResolveRequest.WorkerIdentifier">
      <summary>
            Identifier for the worker, built from workertype/workername.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.WorkerResolve.ResolveRequest.WorkerAddress">
      <summary>
            The address of the worker.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.WorkerResolve.ResolveRequest.ID">
      <summary>
            Unique ID of the request, so the returning response can then be mapped.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.WorkerResolve.ResolveRequest.ClientCredentials">
      <summary>
            Security credentials that should be used to authentication and authorization to access the worker.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.WorkerResolve.ResolveRequest.ResponsePort">
      <summary>
            Port where the response should be posted.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.WorkerResolve.ResolveResponse">
      <summary>
            Message class for responding to a request for resolving a certain worker.
            Contains additional information about communicating with the worker.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.WorkerResolve.ResolveResponse.RequestID">
      <summary>
            The id of the request, so the response can be mapped to it.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.WorkerResolve.ResolveResponse.Status">
      <summary>
            The outcome of the requested resolve.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.WorkerResolve.ResolveResponse.SessionID">
      <summary>
            The session id that should be used to communicate with the worker.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.WorkerResolve.ResolveResponse.Error">
      <summary>
            The exception that occurred, when there was a communication error.
            </summary>
    </member>
    <member name="P:XcoAppSpaces.Contracts.WorkerResolve.ResolveResponse.ProcessorAttributes">
      <summary>
            The processor attributes of the worker per port type, to be used for
            creating the worker proxy (e.g. defines if a worker port runs in sequential
            or parallel transfer mode).
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.WorkerResolve.ResolveStatus">
      <summary>
            Status enum for responding to a resolve request.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Contracts.WorkerResolve.ResolveStatus.Ok">
      <summary>
            The worker resolve was successful.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Contracts.WorkerResolve.ResolveStatus.WorkerNotFound">
      <summary>
            The worker with the given name, type and address could not be found.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Contracts.WorkerResolve.ResolveStatus.NotAuthenticated">
      <summary>
            The user could not be authenticated (missing credentials or wrong username/password).
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Contracts.WorkerResolve.ResolveStatus.NotAuthorized">
      <summary>
            The user doesn't have permission to access the worker.
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Contracts.WorkerResolve.ResolveStatus.CommunicationError">
      <summary>
            There was an error during communication (e.g. the space is not running or cannot not be reached for some other reason).
            (This state is only for local usage where the request was sent.)
            </summary>
    </member>
    <member name="F:XcoAppSpaces.Contracts.WorkerResolve.ResolveStatus.NoResponse">
      <summary>
            There was no response to the resolve request (the other space did not answer).
            (This state is only for local usage where the request was sent.)
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Contracts.WorkerResolve.ResolveWorkerContract">
      <summary>
            Worker contract for the AppSpace-internal ResolveWorker that allows
            remote spaces to resolve workers.
            </summary>
    </member>
    <member name="T:XcoAppSpaces.Serialization.Json.XcoJsonSerializer">
      <summary>
            XcoJsonSerializer serializes and desrializes messages in the Json format, making serialization
            plattform independent.
            </summary>
    </member>
    <member name="M:XcoAppSpaces.Serialization.Json.XcoJsonSerializer.AddSurrogate(BruteForceSerializer.Contract.ISerializationSurrogate)">
      <summary>
            Adds a serialization surrogate to the serializer, that can be used to define special serialization
            mechanisms for certain types.
            </summary>
      <param name="surrogate">The surrogate to be added.</param>
    </member>
    <member name="M:XcoAppSpaces.Serialization.Json.XcoJsonSerializer.Deserialize(System.Byte[])">
      <summary>
            Deserializes an object from a byte array.
            </summary>
      <param name="element">The serialized object.</param>
      <returns>The object that has been deserialized.</returns>
    </member>
    <member name="M:XcoAppSpaces.Serialization.Json.XcoJsonSerializer.Serialize(System.Object)">
      <summary>
            Serializes an object into a byte array.
            </summary>
      <param name="element">The object to be serialized.</param>
      <returns>The serialized object.</returns>
    </member>
    <member name="M:XcoAppSpaces.Serialization.Json.XcoJsonSerializer.CanTypeBeSerialized(System.Type,System.String@)">
      <summary>
            Checks if the given type can be serialized. In case of the Json serializer, types must be
            public and have an empty default constructor.
            </summary>
      <param name="type">The type to be checked.</param>
      <param name="errorInfo">Contains information about serialization problems, if the type cannot be serialized.</param>
      <returns>True if the type can be serialized, otherwise false.</returns>
    </member>
    <member name="M:XcoAppSpaces.Serialization.Json.XcoJsonSerializer.Initialize(XcoAppSpaces.Contracts.Service.IXcoServiceRegistry)">
      <summary>
            Initializes the service.
            </summary>
      <param name="serviceRegistry">The service registry of the local space.</param>
    </member>
    <member name="F:Microsoft.Ccr.Core.CausalityThreadContext.Stacks">
      <summary>
            Collection of causality stacks. Null if only one causality present
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.CausalityThreadContext.ActiveCausality">
      <summary>
            If only one causality is present this field is set
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.CausalityThreadContext.Normalize">
      <summary>
            Collapses empty stacks and if only a single causality is found
            sets ActiveCausality to that causality and Stacks to null
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Dispatcher">
      <summary>
            Implementation of the CCR Task Dispatcher/Scheduler
            </summary>
      <remarks>
            Programs can schedule code by adding at least one port to the dispatcher instance
            and then posting task instances. Using Activate() or spawn within the context of a class deriving
            from CcrServiceBase that is associated with a dispatcher port instance is the most common way to interact
            with the dispatcher.
            </remarks>
    </member>
    <member name="F:Microsoft.Ccr.Core.Dispatcher._suspendedQueueCount">
      <summary>
            Number of queues in suspend mode. For performance reasons, it is not wrapped in an accessor
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.AddThread(System.Threading.Thread)">
      <summary>
            Adds a slot to the global causality static table, for the supplied thread instance
            </summary>
      <param name="thread">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.SetCurrentThreadCausalities(Microsoft.Ccr.Core.CausalityThreadContext)">
      <summary>
            Sets all causalities for the current thread, overwriting any that exist
            </summary>
      <param name="context">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.CloneCausalitiesFromCurrentThread">
      <summary>
            Clones local thread causality context for use in a new thread
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.GetCurrentThreadCausalities">
      <summary>
            Returns all causality stacks associated with the current thread
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.AddCausality(Microsoft.Ccr.Core.ICausality)">
      <summary>
            Adds a causality to the current thread causality stack
            </summary>
      <param name="causality">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.AddCausalityBreak">
      <summary>
            Adds a causality with BreakOnReceive = true to the current thread causality stack.
            In a debug build, if a debugger is attached this will cause the debugger to break
            just before the any task in this causality is executed.
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.RemoveCausality(Microsoft.Ccr.Core.ICausality)">
      <summary>
            Removes a causality from the current thread context
            </summary>
      <param name="causality">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.ClearCausalities">
      <summary>
            Removes all causalities from current thread context
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.RemoveCausality(System.String)">
      <summary>
            Removes a causality from the current thread context
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.#ctor">
      <summary>
            Constructs a Dispatcher instance using the default number of threads and no friendly tag
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.#ctor(System.Int32,System.String)">
      <summary>
            Constructs a Dispatcher instance. The instance is usable only after AddPort is called at least once
            </summary>
      <param name="threadCount">Number of OS threads to use for processing CCR Tasks</param>
      <param name="threadPoolName">Friendly name to use for the OS Threads and this dispatcher instance</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.#ctor(System.Int32,System.Threading.ThreadPriority,System.Boolean,System.String)">
      <summary>
            Constructs a Dispatcher instance. The instance is usable only after AddPort is called at least once
            </summary>
      <param name="threadCount">Number of OS threads to use for processing CCR Tasks</param>
      <param name="priority">OS Thread priority to use for threads exexuting CCR tasks</param>
      <param name="useBackgroundThreads">If true, background threads are used, which do not prevent application exit</param>
      <param name="threadPoolName">Friendly name to use for the OS Threads and this dispatcher instance</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.#ctor(System.Int32,System.Threading.ThreadPriority,Microsoft.Ccr.Core.DispatcherOptions,System.String)">
      <summary>
            Constructs a Dispatcher instance. The instance is usable only after AddPort is called at least once
            </summary>
      <param name="threadCount">Number of OS threads to use for processing CCR Tasks</param>
      <param name="priority">OS Thread priority to use for threads exexuting CCR tasks</param>
      <param name="options">Dispatcher scheduling options</param>
      <param name="threadPoolName">Friendly name to use for the OS Threads and this dispatcher instance</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.#ctor(System.Int32,System.Threading.ThreadPriority,Microsoft.Ccr.Core.DispatcherOptions,System.Threading.ApartmentState,System.String)">
      <summary>
            Constructs a Dispatcher instance. The instance is usable only after AddPort is called at least once
            </summary>
      <param name="threadCount">Number of OS threads to use for processing CCR Tasks</param>
      <param name="priority">OS Thread priority to use for threads exexuting CCR tasks</param>
      <param name="options">Dispatcher scheduling options</param>
      <param name="threadApartmentState">Thread apartment state. Use ApartmentState.Unknown when STA/MTA is not required for interop</param>
      <param name="threadPoolName">Friendly name to use for the OS Threads and this dispatcher instance</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.#ctor(System.Int32,System.Threading.ThreadPriority,Microsoft.Ccr.Core.DispatcherOptions,System.Threading.ApartmentState,System.Int32,System.String)">
      <summary>
            Constructs a Dispatcher instance. The instance is usable only after AddPort is called at least once
            </summary>
      <param name="threadCount">Number of OS threads to use for processing CCR Tasks</param>
      <param name="priority">OS Thread priority to use for threads exexuting CCR tasks</param>
      <param name="options">Dispatcher scheduling options</param>
      <param name="threadApartmentState">Thread apartment state. Use ApartmentState.Unknown when STA/MTA is not required for interop</param>
      <param name="maxThreadStackSize">Thread maximum stack size</param>
      <param name="threadPoolName">Friendly name to use for the OS Threads and this dispatcher instance</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.AddQueue(System.String,Microsoft.Ccr.Core.DispatcherQueue)">
      <summary>
            Adds a queue, in the form of a DispatcherQueue instance, used to schedule CCR tasks
            </summary>
      <remarks>At least one DispatcherQueue instance must be associated with a Dispatcher instance for any scheduling to occur</remarks>
      <param name="queueName">Friendly tag associated with this Task queue</param>
      <param name="queue">Dispatcher queue instance</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.RemoveQueue(System.String)">
      <summary>
            Removes an ITask port from this dispatcher
            </summary>
      <remarks>The port removal will happen asynchronously to guarantee any tasks posted already on the port execute</remarks>
      <param name="queueName">Friendly name associated with dispatcher port</param>
      <returns>True if the port being removed is the last port associated with this dispatcher. False otherwise. If true dispatcher instance will be disposed asynchronously</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.AddWorker(System.Threading.ThreadPriority,System.Threading.ApartmentState,System.Int32)">
      <summary>
            Creates one TaskExecutionWorker instance associated with one OS thread
            </summary>
      <remarks>This routine should only be called once per dispatcher instance</remarks>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.StartWorkers">
      <summary>
            Starts TaskExecutionWorker instances. 
            </summary>
      <remarks>This routine should only be called once per dispatcher instance</remarks>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.Signal">
      <summary>
            Called by the DispatcherQueue post() implementation 
            whenever an ITask instance is enqueued and is available for execution.
            </summary>
      <remarks>
            The Signal() method will ensure at least one TaskExecutionWorker will process
            the enqueued ITask instance next time one of them becomes available.
            </remarks>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.QueueSuspendNotification">
      <summary>
            Called by dispatcher queues to notify the dispatcher they have been suspended
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.QueueResumeNotification">
      <summary>
            Called by dispatcher queues to notify the dispatcher they have been resumed
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.Dispose">
      <summary>
            Stops all scheduling and disposes this dispatcher instance
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Dispatcher.Shutdown(System.Boolean)">
      <summary>
            Stops all dispatcher worker threads and cleans up the dispatcher
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Dispatcher.ActiveCausalities">
      <summary>
            Retrieves a collection of all the bottom of the stack causalities
            that would be responsible for capturing exceptions in the current context
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.Dispatcher.HasActiveCausalities">
      <summary>
            True indicates that one or more causality is active on the current thread context
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Dispatcher.PendingTaskCount">
      <summary>
            Number of pending tasks across all dispatcher ports associated to this dispatcher
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Dispatcher.ProcessedTaskCount">
      <summary>
            Monotonically increasing counter indicating total number of task processed so far
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Dispatcher.WorkerThreadCount">
      <summary>
            Number of worker threads processing tasks across all dispatcher ports associated with this dispatcher
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Dispatcher.ThreadsPerCpu">
      <summary>
            Number of threads per Cpu, if threads are not specified when initializing the dispatcher
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Dispatcher.Options">
      <summary>
            Dispatcher configuration options
            </summary>
      <remarks>The property should treated as read-only. 
            Changing values after dispatcher initialization does not guarantee they will take effect</remarks>
    </member>
    <member name="P:Microsoft.Ccr.Core.Dispatcher.Name">
      <summary>
            Friendly name associated with this dispatcher instance
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Dispatcher.UnhandledExceptionPort">
      <summary>
            Gets or sets a port that any unhandled exceptions occuring in tasks running in threads
            owned by this dispatcher will be sent to.
            </summary>
      <remarks>
            If the exception is posted to the UnhandledExceptionPort, or an event is raised on the relevant DispatcherQueue
            then an exception will not be posted.
            </remarks>
    </member>
    <member name="P:Microsoft.Ccr.Core.Dispatcher.DispatcherQueues">
      <summary>
            Collection of task ports associated with this dispatcher instance
            </summary>
    </member>
    <member name="E:Microsoft.Ccr.Core.Dispatcher.UnhandledException">
      <summary>
            This event is raised when an unhandled exception occurs in tasks running in threads
            owned by this dispatcher.
            </summary>
      <remarks>
            If the exception is posted to the UnhandledExceptionPort, or an event is raised on the relevant DispatcherQueue
            then this event will not be raised.
            </remarks>
    </member>
    <member name="T:Microsoft.Ccr.Core.ICausality">
      <summary>
            Context for propagating failure and coordination ports across tasks
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.ICausality.Guid">
      <summary>
            Unique identifier
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.ICausality.Name">
      <summary>
            Causality name
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.ICausality.ExceptionPort">
      <summary>
            Exception port
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.ICausality.CoordinationPort">
      <summary>
            Optional port for user specified coordination
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Causality">
      <summary>
            Logical context that flows across tasks
            <remarks>Causalities greatly simplify partial failure handling, by providing a multi threaded version of structured exception handling.
            An exception port supplied within a causality can be used by any handler that was executed as a result of some root action.
            Causalities deal with joins (merge of causalities) and forks, enabling a simple model for hierarchical handling of errors in a 
            concurrent setting</remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Causality.#ctor(System.String)">
      <summary>
            Initialization constructor
            </summary>
      <param name="name">Friendly name</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Causality.#ctor(System.Guid)">
      <summary>
            Initialization constructor
            </summary>
      <param name="guid">Unique identifer</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Causality.#ctor(System.String,Microsoft.Ccr.Core.IPort)">
      <summary>
            Initialization constructor
            </summary>
      <param name="name">Friendly name</param>
      <param name="exceptionPort">Exception port</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Causality.#ctor(System.String,Microsoft.Ccr.Core.IPort,Microsoft.Ccr.Core.IPort)">
      <summary>
            Initialization constructor
            </summary>
      <param name="name">Friendly name</param>
      <param name="exceptionPort">Exception port</param>
      <param name="coordinationPort">Coordination port</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Causality.#ctor(System.String,System.Guid,Microsoft.Ccr.Core.IPort,Microsoft.Ccr.Core.IPort)">
      <summary>
            Initialization constructor
            </summary>
      <param name="name">Friendly name</param>
      <param name="guid">Unique identifier</param>
      <param name="exceptionPort">Exception port</param>
      <param name="coordinationPort">Coordination port</param>
    </member>
    <member name="P:Microsoft.Ccr.Core.Causality.Guid">
      <summary>
            Unique identifier
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Causality.BreakOnReceive">
      <summary>
            If true and a debugger is attached, will cause a break
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Causality.Name">
      <summary>
            Causality name
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Causality.ExceptionPort">
      <summary>
            Exception port
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Causality.CoordinationPort">
      <summary>
            Optional port for user specified coordination
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Shutdown">
      <summary>
            Generic message type to signle shutdown.
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Shutdown.ResultPort">
      <summary>
            Result port instance to report success or failure
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.EmptyValue">
      <summary>
            Utility type, with a singleton instance for use in signalling applications where no values need to be communicated
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.EmptyValue.SharedInstance">
      <summary>
            Singleton
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.SuccessResult">
      <summary>
            Indicates success result
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.SuccessResult.#ctor">
      <summary>
            Default constructor. Status field are default.
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.SuccessResult.#ctor(System.Int32)">
      <summary>
            Constructs a SuccessResult instance with an integer status
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.SuccessResult.#ctor(System.String)">
      <summary>
            Constructs a SuccessResult instance with a string status
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.SuccessResult.Instance">
      <summary>
            Shared instance
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.SuccessResult.StatusMessage">
      <summary>
            Readonly string status
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.SuccessResult.Status">
      <summary>
            Readonly int status
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.IPort">
      <summary>
            Core interface abstracting CCR single type ports
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IPort.PostUnknownType(System.Object)">
      <summary>
            Enqueues an object
            </summary>
      <param name="item">Object to enqueue</param>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">Thrown if the port is not compatible with the message instance type</exception>
    </member>
    <member name="M:Microsoft.Ccr.Core.IPort.TryPostUnknownType(System.Object)">
      <summary>
            Attempts to enqueue an untyped message instance 
            </summary>
      <param name="item">Object to enqueue</param>
      <returns>True if message instance type is compatible with port and enqueue succeeded. False otherwise</returns>
    </member>
    <member name="T:Microsoft.Ccr.Core.IPortSet">
      <summary>
            Required interface for multiple type ports with independent message queues
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IPortSet.Test``1">
      <summary>
            Atomically removes a message from the port, or returns null if none present
            </summary>
      <returns>an enqueued messages if port is non empty. Null otherwise</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.IPortSet.Ports">
      <summary>
            Collection of base ports
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.IPortSet.Item(System.Type)">
      <summary>
            Returned IPort instance associated with item type
            </summary>
      <param name="portItemType">
      </param>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
      </exception>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.IPortSet.SharedPort">
      <summary>
            Shared port instance for all item types
            </summary>
      <remarks>Valid when Mode is PortSetMode.Shared, null otherwise</remarks>
    </member>
    <member name="P:Microsoft.Ccr.Core.IPortSet.Mode">
      <summary>
            PortSet operation mode
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`2">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`2.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`2.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`2.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`2.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`2.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`2.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`2.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`2.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1})~`0">
      <summary>
            Invoke the Test method to extract an item of this type
            </summary>
      <param name="port">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`2.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1})~`1">
      <summary>
            Invoke the Test method to extract an item of this type
            </summary>
      <param name="port">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`2.Test``1">
      <summary>
            Atomically removes a message from the port, or returns null if none present
            </summary>
      <returns>an enqueued messages if port is non empty. Null otherwise</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`2.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1})~Microsoft.Ccr.Core.Choice">
      <summary>
            Implicitly creates a Choice Arbiter with one receiver per type. 
            When a branch is chosen, a delegate will post the item back in the port set
            </summary>
      <param name="portSet">PortSet instance to generate Choice from</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`2.PostUnknownType(System.Object)">
      <summary>
            Untyped post of a message. 
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown when the message type is incompatible with any of the port generic type arguments
            </exception>
      <param name="item">The item to enqueue.</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`2.TryPostUnknownType(System.Object)">
      <summary>
            Attempts unsafe (untyped) post of a message instance. 
            <remarks>
            Use to avoid possible exception thrown if message type is incompatible with the port
            </remarks></summary>
      <param name="item">
      </param>
      <returns>
            If the item type is compatible with one of the contained port types, it enqueues
            the item and returns true. Otherwise it returns false with no exception
            thrown
            </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`2.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`2.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`2.Ports">
      <summary>
            Array of single queue ports for each generic type in this port instance
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>If the mode of operation is PortSetMode.SharedPort, the single shared port instance is returned</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`2.Item(System.Type)">
      <summary>
            Returns the port instance used to store items of specified type
            </summary>
      <param name="portItemType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`2.SharedPort">
      <summary>
            Common port instance for all item types when port is set to SharedMode
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`2.Mode">
      <summary>
            Port operation mode
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.SuccessFailurePort">
      <summary>
            Port collection with ports typed for SuccessResult and Exception
            </summary>
      <remarks>This port type is appropriate as the result port type for generic request/response interactions</remarks>
    </member>
    <member name="T:Microsoft.Ccr.Core.Arbiters.PortMode">
      <summary>
            Port operation modes
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Arbiters.PortMode.Default">
      <summary>
            Default port mode, no optimizations based on registered receivers
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Arbiters.PortMode.OptimizedSingleReissueReceiver">
      <summary>
            Port posting is optimized with the assumption only a single re-issue receiver
            is registered and its a single phase (always consumes message during evaluation
            <remarks>This mode should be used with caution. 
            It has strict requirements on the receiver that must be registered with the port:
            1) Only one receiver must be registered
            2) Receiver must be re-issue
            3) Receiver.Process() must be implemented in the derived receiver class
            Note: When the port is in this mode causalities are not propagated.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Arbiters.PortSetMode">
      <summary>
            PortSet operation modes
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Arbiters.PortSetMode.Default">
      <summary>
            Default mode, independent queues for each type in generic type arguments
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Arbiters.PortSetMode.SharedPort">
      <summary>
            PortSet uses a single Port instance for all generic type arguments
            <remarks>This mode should be used with caution. It is only appropriate
            for PortSet instances where only a single message instance
            will be posted, chosen from one of the types in the generic port definition. 
            Response ports for are a common example where having two independent queues 
            is redundant since only one message, on only one of the queues can ever be posted.
            </remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Arbiters.IPortArbiterAccess">
      <summary>
            Internal only port methods
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.IPortArbiterAccess.TestForElement">
      <summary>
            Atomically removes a single element, returns null if none available
            </summary>
      <remarks>Used only by two phase arbiters</remarks>
      <returns>Element instance</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.IPortArbiterAccess.TestForMultipleElements(System.Int32)">
      <summary>
            Atomically removes multiple elements, or null if specified number is not available.        
            </summary>
      <remarks>Used only by two phase arbiters</remarks>
      <returns>Array with elements extracted from port</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.IPortArbiterAccess.PostElement(Microsoft.Ccr.Core.Arbiters.IPortElement)">
      <summary>
            Inserts Element at the beginning of the Port FIFO
            </summary>
      <remarks>This is unlike all other Post apis 
            and used only by two phase arbiters that need to return an item to the port</remarks>
      <param name="element">
      </param>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.IPortArbiterAccess.Mode">
      <summary>
            Specifies port operation optimized for different arbiter types
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.ITask">
      <summary>
            Container for executable CCR code
            <remarks>
            Implementation of the Task interface allows code to execute in the context of the
            CCR dispatcher. Arbiters, receive thunks, un guarded user delegates can use ITask to
            execute in arbitrary context
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.ITask.PartialClone">
      <summary>
            Shallow clone of Task arguments
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.ITask.Execute">
      <summary>
            Invoked by the dispatcher to execute the delegate associated with the task
            </summary>
      <returns>If the delegate is of an Iretator handler this will return the iterator instance</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.ITask.LinkedIterator">
      <summary>
            For internal use only. Parent iterator context associated with this task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.ITask.ArbiterCleanupHandler">
      <summary>
            Handler that executes when task is complete
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.ITask.TaskQueue">
      <summary>
            Dispatcher queue used to schedule this task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.ITask.Item(System.Int32)">
      <summary>
            Enumeration of all IPortElements associated with this task
            <remarks>If Count is zero its not valid to call this indexer</remarks></summary>
      <param name="index">Zero based into associated port elements</param>
      <returns>IPortElement instance</returns>
      <exception cref="T:System.NotImplementedException">Thrown if Count is zero</exception>
    </member>
    <member name="P:Microsoft.Ccr.Core.ITask.PortElementCount">
      <summary>
            Number of IPortElements available with this task
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.IPortReceive">
      <summary>
            Receiver registration and dequeuing methods for ports
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IPortReceive.Test">
      <summary>
            Untyped atomic dequeue
            </summary>
      <returns>A message instance if port non empty, null otherwise</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.IPortReceive.RegisterReceiver(Microsoft.Ccr.Core.Arbiters.ReceiverTask)">
      <summary>
            Associates a receiver (and its arbiter) with the port
            </summary>
      <param name="receiver">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.IPortReceive.UnregisterReceiver(Microsoft.Ccr.Core.Arbiters.ReceiverTask)">
      <summary>
            Removes a receiver from the port
            </summary>
      <param name="receiver">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.IPortReceive.GetReceivers">
      <summary>
            List of receiver thunks attached to the port
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.IPortReceive.GetItems">
      <summary>
            Queued items
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.IPortReceive.Clear">
      <summary>
            Clears all items from port
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.IPortReceive.ItemCount">
      <summary>
            Messages currently in the port
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortNotFoundException">
      <summary>
            Thrown when a message instance of incompatible type is posted on a Port instance
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortNotFoundException.#ctor">
      <summary>
            Default Constructor
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serialization default constructor
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortNotFoundException.#ctor(System.String)">
      <summary>
            Thrown on type mismatch
            </summary>
      <param name="message">Exception message</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortNotFoundException.#ctor(System.String,System.Exception)">
      <summary>
            Thrown on type mismatch
            </summary>
      <param name="message">Exception message</param>
      <param name="innerException">Inner Exception</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortNotFoundException.#ctor(Microsoft.Ccr.Core.IPort,System.Object,System.String)">
      <summary>
      </summary>
      <param name="port">Port instance that threw the exception</param>
      <param name="posted">Message with type not supported by the port</param>
      <param name="message">Exception message</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortNotFoundException.#ctor(Microsoft.Ccr.Core.IPort,System.Object)">
      <summary>
      </summary>
      <param name="port">Port instance that threw the exception</param>
      <param name="posted">Message with type not supported by the port</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortNotFoundException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Provides serialization help for this exception
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortNotFoundException.Port">
      <summary>
            Port instance that threw the exception
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortNotFoundException.ObjectPosted">
      <summary>
            Object that caused the exception when post or postuntyped was attempted
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Store`1.Receivers">
      <summary>
            Used when more than one receiver is active on the port
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Store`1.ActiveReceiver">
      <summary>
            Used when a single receiver is registered
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Store`1.Elements">
      <summary>
            Root node for linked list of port elements (item containers)
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Port`1">
      <summary>
            Type safe message queue and receiver attach point for the CCR.
            </summary>
      <remarks>It enqueues messages and keeps track of receivers
            that can consume messages. Its the primary interaction point for CCR programs
            </remarks>
      <typeparam name="T">Type for messages that can be enqueued</typeparam>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.#ctor">
      <summary>
            Creates a new typed port instance
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.GetReceivers">
      <summary>
            Array of all receivers associated with this port
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.RegisterReceiver(Microsoft.Ccr.Core.Arbiters.ReceiverTask)">
      <summary>
            Associates a receiver task with this port
            </summary>
      <param name="receiver">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.UnregisterReceiver(Microsoft.Ccr.Core.Arbiters.ReceiverTask)">
      <summary>
            Unregisters a receiver/arbiter from the port.
            </summary>
      <param name="receiver">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.PostUnknownType(System.Object)">
      <summary>
            Untyped post of an object. 
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown when the item type is incompatible with the port generic type argument
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.HasConversionFromNull">
      <summary>
            Checks if generic type argument is a nullable type
            </summary>
      <returns>True if nullable false otherwise</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.TryPostUnknownType(System.Object)">
      <summary>
            Attempts unsafe (untyped) post of an object. 
            <remarks>
            Use to avoid possible exception thrown if item type is incompatible with the port
            </remarks></summary>
      <param name="item">
      </param>
      <returns>
            If the item type is compatible with the port type, it enqueues
            the message and returns true. Otherwise it returns false with no exception
            thrown
            </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.PostElement(Microsoft.Ccr.Core.Arbiters.IPortElement)">
      <summary>
            Returns element at the beginning of FIFO
            </summary>
      <param name="element">
            Message Container previously created from posting to this port
            </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.GetItems">
      <summary>
            All items currently queued. Items are not removed from the port
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.Test">
      <summary>
            Atomically removes a message from the port, or returns null if none present
            </summary>
      <returns>an enqueued messages if port is non empty. Null otherwise</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.TestForElement">
      <summary>
            Atomically removes a message container
            </summary>
      <returns>IPortElement instance if port is non empty. Null otherwise</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.TestForMultipleElements(System.Int32)">
      <summary>
            Atomically removes multiple message containers
            </summary>
      <returns>IPortElement instance array if port has the specified number of elements. Null otherwise</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.Test(`0@)">
      <summary>
            Atomically removes a message from the port, if port is non empty.
            </summary>
      <remarks>
            Non blocking attempt to dequeue a message from the port. Returns false if no message is present
            </remarks>
      <param name="item">
            Set to an instance of a previously enqueued message if port is non empty. Set to default(T) otherwise
            </param>
      <returns>True if a message was succesfully dequeued from the port. False otherwise</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.op_Implicit(Microsoft.Ccr.Core.Port{`0})~`0">
      <summary>
            Invoke the Test method to extract an item
            </summary>
      <param name="port">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.ToString">
      <summary>
            Provides a detailed description of the port state including registered receivers and their hierarchy
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.GetHashCode">
      <summary>
            Application domain unique identity for this port instance. Guaranteed to be stable for the lifetime of the port instance
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.Clear">
      <summary>
            Clears all items from the port
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Port`1.op_Implicit(Microsoft.Ccr.Core.Port{`0})~Microsoft.Ccr.Core.Receiver{`0}">
      <summary>
            Implicitly creates a one time Receiver Arbiter registered on this port.
            The receiver will execute a delegate that posts an item back into the port
            </summary>
      <param name="port">Port instance to generate a Receiver from</param>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.Port`1.Mode">
      <summary>
            Current mode of operation for posting messages
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Port`1.ItemCount">
      <summary>
            Number of messages currently enqueued
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type specified at runtime
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the Ports accessor
            </remarks></summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.PortSet.SharedPortInternal">
      <summary>
            Shared port instance
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.PortSet.PortsTable">
      <summary>
            Table of typed ports
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.PortSet.Types">
      <summary>
            Types supported by this port set
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.PortSet.ModeInternal">
      <summary>
            PortSet operation mode
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet.#ctor(System.Type[])">
      <summary>
            Initialization constructor
            </summary>
      <param name="types">Item types supported by this port set</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet.PostUnknownType(System.Object)">
      <summary>
            Untyped post of a message. 
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown when the message type is incompatible with any of the port generic type arguments
            </exception>
      <param name="item">The item to enqueue.</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet.TryPostUnknownType(System.Object)">
      <summary>
            Attempts unsafe (untyped) post of a message instance. 
            <remarks>
            Use to avoid possible exception thrown if message type is incompatible with the port
            </remarks></summary>
      <param name="item">
      </param>
      <returns>
            If the item type is compatible with one of the contained port types, it enqueues
            the item and returns true. Otherwise it returns false with no exception
            thrown
            </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet.FindTypeFromRuntimeType(System.Object,System.Type[],System.Type@)">
      <summary>
            finds a type match between the runtime type of an object and the type array elements, considering sub type matching
            </summary>
      <param name="item">
      </param>
      <param name="types">
      </param>
      <param name="portItemType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet.Test``1">
      <summary>
            Atomically removes a message from the port, or returns null if none present
            </summary>
      <returns>an enqueued messages if port is non empty. Null otherwise</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet.AllocatePort``1">
      <summary>
            Allocates a Port instance of the specified type
            </summary>
      <typeparam name="TYPE">Port item type</typeparam>
      <returns>Port instance</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet.op_Implicit(Microsoft.Ccr.Core.PortSet)~Microsoft.Ccr.Core.Choice">
      <summary>
            Implicitly creates a Choice Arbiter with one receiver per type. 
            When a branch is chosen, a delegate will post the item back in the port set
            </summary>
      <param name="portSet">PortSet instance to generate Choice from</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet.ImplicitChoiceOperator(Microsoft.Ccr.Core.IPortSet)">
      <summary>
            Converts a IPortSet instance to a Choice with a branch for each port type
            </summary>
      <param name="portSet">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet.Ports">
      <summary>
            Array of single queue ports for each generic type in this port instance
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>If the mode of operation is PortSetMode.SharedPort, the single shared port instance is returned</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet.SharedPort">
      <summary>
            Shared port instance for all generic type arguments of this instance         
            <remarks>Valid if the mode of operation is PortSetMode.SharedPort, null otherwise</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet.Mode">
      <summary>
            Port operation mode
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet.Item(System.Type)">
      <summary>
            Returns the port instance used to store items of specified type
            </summary>
      <param name="portItemType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Microsoft.Ccr.Core.Arbiter">
      <summary>
            Arbiter factory
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.ExecuteNow(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.ITask)">
      <summary>
            Executes task in the current thread context, blocking the current thread until completion but also minimizing thread switches in the case of iterative tasks
            </summary>
      <remarks>The task will block the current thread until it completes. If the task is an iterative task, only the first stage of the iterator is executed in the current thread context</remarks>
      <param name="dispatcherQueue">
      </param>
      <param name="task">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.Activate(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.ITask[])">
      <summary>
            Registers an arbiter on ports and associates a dispatcher queue for executing the
            user's code
            </summary>
      <param name="dispatcherQueue">
      </param>
      <param name="arbiter">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.FromHandler(Microsoft.Ccr.Core.Handler)">
      <summary>
            Converts a handler delegate to a task so it can be scheduled
            </summary>
      <param name="handler">
      </param>
      <returns>Instance of Task</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.FromIteratorHandler(Microsoft.Ccr.Core.IteratorHandler)">
      <summary>
            Converts an iterator handler delegate to a task so it can be scheduled
            </summary>
      <param name="handler">
      </param>
      <returns>Instance of IterativeTask</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.ExecuteToCompletion(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.ITask)">
      <summary>
            Activates a task and waits for its completion
            </summary>
      <remarks>Yielding on the return value allows an iterators to logically block for a task completion, even if that task is an iterator itself</remarks>
      <param name="dispatcherQueue">Dispatcher queue used to schedule the task</param>
      <param name="task">Task to execute and wait for its completion</param>
      <returns>Instance of a Receiver task that will execute when task is complete</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.ExecuteToCompletion(Microsoft.Ccr.Core.DispatcherQueue,Microsoft.Ccr.Core.ITask,Microsoft.Ccr.Core.Port{Microsoft.Ccr.Core.EmptyValue})">
      <summary>
            Activates a task and waits for its completion
            </summary>
      <remarks>Posts an item on a port when a task is finished. Allows chaining of tasks for non-iterator methods</remarks>
      <param name="dispatcherQueue">Dispatcher queue used to schedule the task</param>
      <param name="task">Task to execute and wait for its completion</param>
      <param name="donePort">User supplied port to post an empty value when task is complete</param>
      <returns>Instance of a Receiver task that will execute when task is complete</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.Receive``1(System.Boolean,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Creates a single item receiver
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="persist">True if receiver can stay registered with the port after the first message</param>
      <param name="port">Port instance to register receiver with</param>
      <param name="handler">User delegate that executes on message arrival at the port</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.ReceiveFromPortSet``1(System.Boolean,Microsoft.Ccr.Core.IPortSet,Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Creates a single item receiver. Use with non-generic PortSet instances only
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="persist">True if receiver can stay registered with the port after the first message</param>
      <param name="portSet">PortSet instance to register receiver with</param>
      <param name="handler">User delegate that executes on message arrival at the port</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.Receive``1(System.Boolean,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Handler{``0},System.Predicate{``0})">
      <summary>
            Creates a single item receiver
            </summary>
      <typeparam name="T">Message type</typeparam>
      <param name="persist">True if receiver can stay registered with the port after the first message</param>
      <param name="port">Port instance to register receiver with</param>
      <param name="handler">User delegate that executes on message arrival at the port</param>
      <param name="predicate">User delegate that executes before the handler is allowed to run and filter each message</param>
      <returns>Instance of Receiver arbiter</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.ReceiveFromPortSet``1(System.Boolean,Microsoft.Ccr.Core.IPortSet,Microsoft.Ccr.Core.Handler{``0},System.Predicate{``0})">
      <summary>
            Creates a single item receiver. Use with non-generic PortSet instances only
            </summary>
      <typeparam name="T">Message type</typeparam>
      <param name="persist">True if receiver can stay registered with the port after the first message</param>
      <param name="portSet">Port instance to register receiver with</param>
      <param name="handler">User delegate that executes on message arrival at the port</param>
      <param name="predicate">User delegate that executes before the handler is allowed to run and filter each message</param>
      <returns>Instance of Receiver arbiter</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.ReceiveWithIterator``1(System.Boolean,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.IteratorHandler{``0})">
      <summary>
            Creates a single item receiver for a iterator user handler
            </summary>
      <typeparam name="T">Message type</typeparam>
      <param name="persist">True if receiver can stay registered with the port after the first message</param>
      <param name="port">Port instance to register receiver with</param>
      <param name="handler">User delegate that executes on message arrival at the port</param>
      <returns>Instance of Receiver arbiter</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.ReceiveWithIteratorFromPortSet``1(System.Boolean,Microsoft.Ccr.Core.IPortSet,Microsoft.Ccr.Core.IteratorHandler{``0})">
      <summary>
            Creates a single item receiver for a iterator user handler. Use with non-generic PortSet instances only
            </summary>
      <typeparam name="T">Message type</typeparam>
      <param name="persist">True if receiver can stay registered with the port after the first message</param>
      <param name="portSet">Port instance to register receiver with</param>
      <param name="handler">User delegate that executes on message arrival at the port</param>
      <returns>Instance of Receiver arbiter</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.ReceiveWithIterator``1(System.Boolean,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.IteratorHandler{``0},System.Predicate{``0})">
      <summary>
            Creates a single item receiver for a iterator user handler
            </summary>
      <typeparam name="T">Message type</typeparam>
      <param name="persist">True if receiver can stay registered with the port after the first message</param>
      <param name="port">Port instance to register receiver with</param>
      <param name="handler">User delegate that executes on message arrival at the port</param>
      <param name="predicate">User delegate that executes before the handler is allowed to run and filter each message</param>
      <returns>Instance of Receiver arbiter</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.ReceiveWithIteratorFromPortSet``1(System.Boolean,Microsoft.Ccr.Core.IPortSet,Microsoft.Ccr.Core.IteratorHandler{``0},System.Predicate{``0})">
      <summary>
            Creates a single item receiver for a iterator user handler. Use with non-generic PortSet instances only
            </summary>
      <typeparam name="T">Message type</typeparam>
      <param name="persist">True if receiver can stay registered with the port after the first message</param>
      <param name="portSet">Port instance to register receiver with</param>
      <param name="handler">User delegate that executes on message arrival at the port</param>
      <param name="predicate">User delegate that executes before the handler is allowed to run and filter each message</param>
      <returns>Instance of Receiver arbiter</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.JoinedReceive``2(System.Boolean,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Port{``1},Microsoft.Ccr.Core.Handler{``0,``1})">
      <summary>
            Creates a join receiver arbiter that waits for two messages to arrive on two ports, in any order
            </summary>
      <remarks>Joined receives perform a two phase protocol to extracting, one at a time, items for the ports in the join.
            This guarantees that if two different joins, that are listening on one or more shared port, can continue to make progress
            without starvation. However it has significant performance implications if there is alot of contention on these ports.
            MultipleItemReceive methods are recommended for cases where consuming the items on a port directly is not an issue
            and scatter/gather is the main goal.
            </remarks>
      <typeparam name="T0">Message type</typeparam>
      <typeparam name="T1">Message type</typeparam>
      <param name="persist">True if receiver can stay registered with the port after the first message </param>
      <param name="port0">Port instance for message type T0</param>
      <param name="port1">Port instance for message type T1</param>
      <param name="handler">User delegate that will execute when the join is satisfied</param>
      <returns>Instance of JointReceiver arbiter</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.JoinedReceiveWithIterator``2(System.Boolean,Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Port{``1},Microsoft.Ccr.Core.IteratorHandler{``0,``1})">
      <summary>
            Creates a join receiver arbiter that waits for two messages to arrive on two ports, in any order
            </summary>
      <typeparam name="T0">Message type</typeparam>
      <typeparam name="T1">Message type</typeparam>
      <param name="persist">True if receiver can stay registered with the port after the first message </param>
      <param name="port0">Port instance for message type T0</param>
      <param name="port1">Port instance for message type T1</param>
      <param name="handler">User delegate of an iterator that will execute when the join is satisfied</param>
      <returns>Instance of JointReceiver arbiter</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.MultipleItemReceive``1(System.Boolean,Microsoft.Ccr.Core.Port{``0},System.Int32,Microsoft.Ccr.Core.VariableArgumentHandler{``0})">
      <summary>
            Create a join receiver that will wait for a specified number of messages on a single port
            </summary>
      <typeparam name="T">Message type</typeparam>
      <param name="persist">True if receiver can stay registered with the port after the first message</param>
      <param name="port">Port instance to attach receiver</param>
      <param name="itemCount">Number of messages to wait for before executing user delegate</param>
      <param name="handler">User delegate</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.MultiplePortReceive``1(System.Boolean,Microsoft.Ccr.Core.Port{``0}[],Microsoft.Ccr.Core.VariableArgumentHandler{``0})">
      <summary>
            Create a join receiver that will wait for a specified number of messages across multiple ports
            </summary>
      <typeparam name="T">Message type</typeparam>
      <param name="persist">True if receiver can stay registered with the port after the first message</param>
      <param name="ports">Ports to register receiver with</param>
      <param name="handler">User delegate</param>
      <returns>Instance of JoinReceiver arbiter</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.MultipleItemReceive``1(Microsoft.Ccr.Core.VariableArgumentHandler{``0},Microsoft.Ccr.Core.Port{``0}[])">
      <summary>
            A helper task that collects items from multiple ports.
            It then accumulates the results in a collection. When the supplied count
            is reached it will execute the user task. This is not a Join, since it does not implement a two phase protocol
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.MultipleItemReceive``2(Microsoft.Ccr.Core.PortSet{``0,``1},System.Int32,Microsoft.Ccr.Core.Handler{System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``1}})">
      <summary>
            Creates a coordination task that collects items from multiple ports in the same PortSet.
            It then accumulates the results in collections based on item type. When the supplied count
            is reached it will execute the user task. 
            </summary>
      <param name="portSet">PortSet instance</param>
      <param name="totalItemCount">Total number of items to receive across all ports in the PortSet instance</param>
      <param name="handler">User delegate</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.Interleave(Microsoft.Ccr.Core.TeardownReceiverGroup,Microsoft.Ccr.Core.ExclusiveReceiverGroup,Microsoft.Ccr.Core.ConcurrentReceiverGroup)">
      <summary>
            Creates an interleave arbiter using the supplied receiver groups
            </summary>
      <param name="teardown">Group of receivers that will execute only once and cause the interleave to teardown atomically</param>
      <param name="exclusive">Group of receivers that can only run exclusively (no other receiver can be active)</param>
      <param name="concurrent">Group of receivers that can execute concurrently with only receivers in the concurrent group</param>
      <returns>Instance of a Choice Arbiter</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.Choice(Microsoft.Ccr.Core.Arbiters.ReceiverTask[])">
      <summary>
            Creates a choice arbiter
            </summary>
      <param name="receivers">Receivers that will execute only once and exclusive of each other</param>
      <returns>Instance of Choice Arbiter</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.Choice(Microsoft.Ccr.Core.IPortSet)">
      <summary>
            Creates a choice arbiter with a branch for each port in the port set
            </summary>
      <remarks>
            A non-persisted receiver is attached to each port on the port set and used as a branch
            in the Choice arbiter. When the first item arrives on any of the ports within the port set,
            the receiver simply posts the item back, allowing the choice to complete. Use this method
            within iterators, followed by a call to the Test method on the port set to retrieve the item
            or by simply assigning the port set to a variable of one of the PortSet types
            </remarks>
      <param name="portSet">PortSet instance to create Choice with</param>
      <returns>Instance of Choice Arbiter</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiter.Choice``2(Microsoft.Ccr.Core.PortSet{``0,``1},Microsoft.Ccr.Core.Handler{``0},Microsoft.Ccr.Core.Handler{``1})">
      <summary>
            Creates a common version of the instance arbiter given a port set with two types and 
            a delegate for each type
            </summary>
      <param name="resultPort">PortSet to attach one time receivers with the supplied delegates</param>
      <param name="handler0">Delegate for message type T0</param>
      <param name="handler1">Delegate for message type T1</param>
      <returns>Instance of Choice arbiter</returns>
    </member>
    <member name="T:Microsoft.Ccr.Core.TaskCommon">
      <summary>
            Common base class for ITask implementations
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.TaskCommon.PartialClone">
      <summary>
            Abstract definition of PartialClone
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.TaskCommon.Execute">
      <summary>
            Abstract definition of Execute
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.TaskCommon.ArbiterCleanupHandler">
      <summary>
            Set by a top level arbiter so it can execute logic on task completion
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.TaskCommon.LinkedIterator">
      <summary>
            Iterator that needs to be processed once current task completes
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.TaskCommon.TaskQueue">
      <summary>
            Dispatcher queue to use for scheduling any tasks 
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.TaskCommon.Item(System.Int32)">
      <summary>
            Abstract definition of element indexer
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.TaskCommon.PortElementCount">
      <summary>
            Abstract definition of element count
             </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Task">
      <summary>
            Implementation of ITask for zero argument handlers
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task.#ctor(Microsoft.Ccr.Core.Handler)">
      <summary>
            Constructs a zero argument Task instance
            </summary>
      <remarks>If causalities are active they are captured at constructor invokation</remarks>
      <param name="handler">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task.PartialClone">
      <summary>
            Shallow copy of this Task Instance
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task.Execute">
      <summary>
            Executes Handler associated with task instance
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.Task.Handler">
      <summary>
            Delegate associated with the Task instance
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Task.Item(System.Int32)">
      <summary>
            Not implemented on zero argument task instances
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.Task.PortElementCount">
      <summary>
            Always returns zero
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.IterativeTask">
      <summary>
            Zero argument Task instance associated with an iterator handler
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask.#ctor(Microsoft.Ccr.Core.IteratorHandler)">
      <summary>
            Constructs an IterativeTask instance
            </summary>
      <param name="handler">Iterator delegate</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask.PartialClone">
      <summary>
            Shallow clone
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask.Execute">
      <summary>
            Executes Handler associated with task instance
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.IterativeTask.Handler">
      <summary>
            Iterator handler associated with task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.IterativeTask.Item(System.Int32)">
      <summary>
            Not supported on zero argument task instances
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.IterativeTask.PortElementCount">
      <summary>
            always returns zero
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.InterleaveReceiverGroup">
      <summary>
            Receiver group
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.InterleaveReceiverGroup.#ctor(Microsoft.Ccr.Core.Arbiters.ReceiverTask[])">
      <summary>
            Constructs an group of receivers
            </summary>
      <param name="branches">Receivers</param>
    </member>
    <member name="T:Microsoft.Ccr.Core.TeardownReceiverGroup">
      <summary>
            Receivers that will execute one time only after all concurrent and exclusive handlers
            are finished. The interleave will then un register all receivers from ports and prevent
            any further handlers form executing. 
            If multiple teardown receivers are present, only one will execute, the one that first has its
            constraints (first one that receives a message for simple receives) met.
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.TeardownReceiverGroup.#ctor(Microsoft.Ccr.Core.Arbiters.ReceiverTask[])">
      <summary>
      </summary>
      <param name="branches">
      </param>
    </member>
    <member name="T:Microsoft.Ccr.Core.ExclusiveReceiverGroup">
      <summary>
            Receivers with user delegates that must run exclusive to each other and any receiver in a Concurrent group
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.ExclusiveReceiverGroup.#ctor(Microsoft.Ccr.Core.Arbiters.ReceiverTask[])">
      <summary>
            Constructs an Exclusive group of receivers
            </summary>
      <param name="branches">Receivers</param>
    </member>
    <member name="T:Microsoft.Ccr.Core.ConcurrentReceiverGroup">
      <summary>
            Receivers with user delegates that can run concurrently with each other
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.ConcurrentReceiverGroup.#ctor(Microsoft.Ccr.Core.Arbiters.ReceiverTask[])">
      <summary>
            Constructs a ConcurrentReceiverGroup instance
            </summary>
      <param name="branches">
      </param>
    </member>
    <member name="T:Microsoft.Ccr.Core.InterleaveReceivers">
      <summary>
            Classification of interleave receiver groups
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.InterleaveReceivers.Teardown">
      <summary>
            Exclusive one-time receiver that tears down the interleave context atomically
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.InterleaveReceivers.Exclusive">
      <summary>
            Exclusive receiver
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.InterleaveReceivers.Concurrent">
      <summary>
            Concurrent receiver
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.InterleaveReceiverContext">
      <summary>
            Private tuple of receiver context used by the interleave arbiter and associated with each receive branch
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Arbiters.IArbiterTask">
      <summary>
            All CCR arbiters that allow nesting must implement this interface
            <remarks>
            Arbiters implement the coordination logic between user code and one or more ports.
            Usually an arbiter also implements Receiver so it can be directly attached to
            a port. The arbiter logic is invoked in the context of Port.Post() and 
            in non side-effecting way, determines it can consume the message and schedule the users code
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.IArbiterTask.Evaluate(Microsoft.Ccr.Core.Arbiters.ReceiverTask,Microsoft.Ccr.Core.ITask@)">
      <summary>
            This method is invoked in the context of port post(). It must be non blocking
            and has to determine if the message being posted can be directly consumed or
            schedule a second phase by returning a task
            </summary>
      <param name="receiver">The receive thunk nested under this arbiter that caused the arbiter to get called</param>
      <param name="deferredTask">The arbiter can set this parameter if it wants a task scheduler upon function exit</param>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.IArbiterTask.ArbiterState">
      <summary>
            Current State of the arbiter
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Interleave">
      <summary>
            The Interleave arbiter is a generalization of reader/writer lock style synchronization
            </summary>
      <remarks>
            Intelreave will guarantee that the user delegates associated with the receivers
            in the Exclusive group will run Exclusive to eah other and any delegate associated with the Concurrent receivers.
            Interleav eis biased towards Exclusive receivers so if a Concurrent receiver is currently executing and an
            Exclusive receiver is ready to execute, it will wait untilt he Concurrent receiver is complete and it will 
            preempt any more Concurrent receivers from running until all Exclusive receivers have run
            </remarks>
    </member>
    <member name="F:Microsoft.Ccr.Core.Interleave._mutexBranches">
      <summary>
            List of exclusive receiver tasks.
            Mutex branch reference is used as the synchronization object for the interleave
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Interleave._concurrentBranches">
      <summary>
            List of concurrent receiver tasks
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Interleave._nextMutexQueueIndex">
      <summary>
            Index into the _mutexBranches collection for the next receiver task that should be processed for pending items
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Interleave.ToString">
      <summary>
            Human readable description of interleave branches and current state
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Interleave.#ctor">
      <summary>
            Constructs an empty interleave instance
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Interleave.#ctor(Microsoft.Ccr.Core.TeardownReceiverGroup,Microsoft.Ccr.Core.ExclusiveReceiverGroup,Microsoft.Ccr.Core.ConcurrentReceiverGroup)">
      <summary>
            Constructs an interleave arbiter composed out of an Exclusive and Concurrent group of receivers
            </summary>
      <param name="teardown">Teardown Receivers</param>
      <param name="mutex">Mutually Exclusive receivers</param>
      <param name="concurrent">Receivers that can execute their delegates Concurrent to each other</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Interleave.#ctor(Microsoft.Ccr.Core.ExclusiveReceiverGroup,Microsoft.Ccr.Core.ConcurrentReceiverGroup)">
      <summary>
            Constructs an interleave arbiter composed out of an Exclusive and Concurrent group of receivers
            </summary>
      <param name="mutex">Mutually Exclusive receivers</param>
      <param name="concurrent">Receivers that can execute their delegates Concurrent to each other</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Interleave.PartialClone">
      <summary>
            Not supported
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Interleave.Execute">
      <summary>
            Registers the interleave arbiter as a parent to all the participating receivers
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Interleave.CombineWith(Microsoft.Ccr.Core.Interleave)">
      <summary>
            Allows a new interleave arbiter instance, to be combined with an existing active interleave
            </summary>
      <param name="child">Interleave instance to combine with parent</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Interleave.Cleanup(Microsoft.Ccr.Core.ITask)">
      <summary>
            Cleanup any pending Exclusive and Concurrent branches, then schedule Winner task
            </summary>
      <param name="winner">Task that should execute after cleanup</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Interleave.Evaluate(Microsoft.Ccr.Core.Arbiters.ReceiverTask,Microsoft.Ccr.Core.ITask@)">
      <summary>
            Invoked by port logic to let arbiter examing message instances as they get posted
            </summary>
      <param name="receiver">Nested receiver thunk instance associated with port being posted on</param>
      <param name="deferredTask">Set to task if the arbiter has something to schedule</param>
      <returns>true if the task needs to be scheduled</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Interleave.Arbitrate(System.Boolean)">
      <summary>
            Changes the interleave state variables. Must be called under a lock
            </summary>
      <param name="IsExclusive">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Interleave.ProcessPending(System.Boolean,System.Collections.Generic.List{Microsoft.Ccr.Core.Arbiters.ReceiverTask})">
      <summary>
            Round robin between all the queues associated with each receiver and dequeue a single pending task
            </summary>
      <param name="IsExclusive">
      </param>
      <param name="receivers">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Interleave.TryDequeuePendingTask(Microsoft.Ccr.Core.InterleaveReceivers)">
      <summary>
            Attempts to dequeue a pending task from one of the internal interleave queues
            </summary>
      <remarks>The method should be used only in advanced scenarios where low level control of interleave behavior is required</remarks>
      <param name="receiverMask">Compination of reciever group flags determining which queues of pending tasks are searched</param>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.Interleave.PendingExclusiveCount">
      <summary>
            Number of queued exclusive tasks waiting to execute
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Interleave.PendingConcurrentCount">
      <summary>
            Number of queued concurrent tasks waiting to execute
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Interleave.ArbiterCleanupHandler">
      <summary>
            Set by a top level arbiter so it can execute logic on task completion
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Interleave.LinkedIterator">
      <summary>
            Iterator that needs to be processed once current task completes
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Interleave.ArbiterState">
      <summary>
            Current state
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Interleave.TaskQueue">
      <summary>
            Dispatcher queue to use for scheduling tasks 
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Interleave.Item(System.Int32)">
      <summary>
            Not supported
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.Interleave.PortElementCount">
      <summary>
            Always zero
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Arbiters.ReceiverTask">
      <summary>
            Base class for receiver implementations
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.ReceiverTask.ToString">
      <summary>
            Human readabable description of receiver type, associated handler, nesting hierarchy and state
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.ReceiverTask.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.ReceiverTask.#ctor(Microsoft.Ccr.Core.ITask)">
      <summary>
            Initialization constructor
            </summary>
      <param name="taskToRun">Task to execute when receiver condition is satisfied</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.ReceiverTask.PartialClone">
      <summary>
            Shallow clone of receiver state and task state
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.ReceiverTask.Execute">
      <summary>
            Invoked by the scheduler to register the receiver on the ports. 
            </summary>
      <remarks>If the scheduler directly calls this routine it means this receiver is not nested under any arbiter</remarks>
      <returns>Returns null always</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.ReceiverTask.Evaluate(Microsoft.Ccr.Core.Arbiters.IPortElement,Microsoft.Ccr.Core.ITask@)">
      <summary>
            Invoked by port post logic when a new message instance is enqueued
            </summary>
      <param name="deferredTask">set to a task instance if the receiver meets its constraints and consumes the message</param>
      <param name="messageNode">Message container being posted on the port</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.ReceiverTask.Consume(Microsoft.Ccr.Core.Arbiters.IPortElement)">
      <summary>
            Invoked when port has been set to the PortOperationMode.SingleReIssueReceiver.
            Assumes item will be consumed and any task generated will be scheduled by receiver
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.ReceiverTask.Cleanup">
      <summary>
            invoked by a parent arbiter when arbitration is complete. This method is always called even if this receiver won
            </summary>
      <remarks>For persisted receivers cleanup requires un registering from ports</remarks>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.ReceiverTask.Cleanup(Microsoft.Ccr.Core.ITask)">
      <summary>
            invoked by a parent arbiter for queued tasks that failed to execute. Items stored in the task must be returned to ports
            </summary>
      <param name="taskToCleanup">Task to use for re-posting arguments back to ports</param>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.ReceiverTask.ArbiterContext">
      <summary>
            Used by parent arbiter to store context
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.ReceiverTask.Arbiter">
      <summary>
            Parent arbiter. The setter can only be invoked once
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.ReceiverTask.State">
      <summary>
            Receiver state
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.ReceiverTask.Item(System.Int32)">
      <summary>
            Returns the arguments contained in the receiver
            </summary>
      <param name="index">Argument index</param>
      <returns>Argument instance</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.ReceiverTask.PortElementCount">
      <summary>
            Number of arguments this receiver is waiting on
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.ReceiverTask.UserTask">
      <summary>
            Task instance that contains the user delegate plus arguments.
            </summary>
      <remarks>The task instance will be scheduled if the receiver constraints are met</remarks>
    </member>
    <member name="T:Microsoft.Ccr.Core.JoinReceiverTask">
      <summary>
            Shared logic for join arbiters
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.JoinReceiverTask._commitAttempt">
      <summary>
            used to guard against multiple activations of user delegate on one-time joins
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiverTask.Register">
      <summary>
            Must be implemented by derived classes
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiverTask.Cleanup(Microsoft.Ccr.Core.ITask)">
      <summary>
            Must be implemented by derived classes
            </summary>
      <param name="taskToCleanup">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiverTask.ShouldCommit">
      <summary>
            Must be implemented by derived classes
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiverTask.Evaluate(Microsoft.Ccr.Core.Arbiters.ReceiverTask,Microsoft.Ccr.Core.ITask@)">
      <summary>
            Determines if a commit should be scheduled by checking if all items from ports are available
            </summary>
      <returns>always returns false since join never</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiverTask.Commit">
      <summary>
            Must be implemented by derived classes
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiverTask.Arbitrate(Microsoft.Ccr.Core.ITask,Microsoft.Ccr.Core.Arbiters.IPortElement[],System.Boolean)">
      <summary>
            Determines if join commit can proceed
            </summary>
      <param name="winner">Task to execute if commit occurs</param>
      <param name="items">Items retrieved from ports</param>
      <param name="allTaken">True if the join retrieved all necessery items. False if partial commit occured</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiverTask.UnrollPartialCommit(Microsoft.Ccr.Core.Arbiters.IPortElement[])">
      <summary>
            Must be implemented by derived classes.
            </summary>
      <param name="items">
      </param>
    </member>
    <member name="P:Microsoft.Ccr.Core.JoinReceiverTask.Arbiter">
      <summary>
            Parent arbiter instance
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.JoinReceiverTask.ArbiterState">
      <summary>
            Arbiter state
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.JoinReceiver">
      <summary>
            Join implementation across multiple ports
            </summary>
      <remarks>
            The join arbiter will attach individual receivers on each port participating in the join.
            As messages get posted in the ports, the parent arbiter (an instance of JoinReceiver)
            will determine if it has messages across all ports. Without actually consuming the messages
            It will schedule a commit phase and try to extract, using the Test() method on the ports,
            all the messages required for the join to complete. If all messages are retrived, commit succeeds but
            the arbiter will still ask its parent (since join can be nested under choice or interleave)
            if it can proceed scheduling the user delegate. If it can, it schedules a task with all the messages as arguments.
            If it fails, it will call UnrollPartialCommit to put the messages back in their original ports
            </remarks>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiver.ToString">
      <summary>
            Description of JoinReceiver state
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiver.#ctor(System.Boolean,Microsoft.Ccr.Core.ITask,Microsoft.Ccr.Core.IPortReceive[])">
      <summary>
            Constructs a Join Receiver, an arbiter that waits for one message per port in any order
            </summary>
      <param name="persist">Set to true if join persists on the ports after processing one set of messages</param>
      <param name="task">User task that will execute when join is satisfied</param>
      <param name="ports">Ports that participate in the join</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiver.Cleanup">
      <summary>
            Removes individual receiver thunks attached to ports participating in the join
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiver.Cleanup(Microsoft.Ccr.Core.ITask)">
      <summary>
            Returns messages instances attached to the task instance, to the appropriate ports
            participating in the join
            </summary>
      <param name="taskToCleanup">Task instance with message arguments to post back</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiver.Register">
      <summary>
            Registers child receivers on each port in the join, so it can get notified when messages
            become available in the ports
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiver.Evaluate(Microsoft.Ccr.Core.Arbiters.IPortElement,Microsoft.Ccr.Core.ITask@)">
      <summary>
            Invoked in the context of Port.Post() to examine a message
            </summary>
      <param name="deferredTask">Always set to null</param>
      <param name="messageNode">Message instance being posted</param>
      <returns>Always false</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiver.Consume(Microsoft.Ccr.Core.Arbiters.IPortElement)">
      <summary>
            Consume
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiver.ShouldCommit">
      <summary>
            Checks if the ports participating in the join have one message each so it can schedule
            a Commit phase and attempt to retrieve the items
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiver.Commit">
      <summary>
            Attempts to remove one item per port and complete the join
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinReceiver.UnrollPartialCommit(Microsoft.Ccr.Core.Arbiters.IPortElement[])">
      <summary>
            If the join commit fails for any reason this routine will post back any items
            taken from ports
            </summary>
      <param name="items">
      </param>
    </member>
    <member name="T:Microsoft.Ccr.Core.JoinSinglePortReceiver">
      <summary>
            Join receiver that waits for N items all on the same port
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinSinglePortReceiver.#ctor(System.Boolean,Microsoft.Ccr.Core.ITask,Microsoft.Ccr.Core.IPortReceive,System.Int32)">
      <summary>
            A Join receiver that waits for N messages on the same port
            </summary>
      <param name="persist">Set to true if join persists on the ports after it executes the user task once</param>
      <param name="task">User task that will execute when join is satisfied</param>
      <param name="port">Port used to receive the messages</param>
      <param name="count">Number of messages to wait for before join is satisfied</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinSinglePortReceiver.Cleanup">
      <summary>
            Unregisters from the port
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinSinglePortReceiver.Cleanup(Microsoft.Ccr.Core.ITask)">
      <summary>
            Posts back to the port any message instances associated with the task
            </summary>
      <param name="taskToCleanup">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinSinglePortReceiver.Register">
      <summary>
            register this join arbiter directly on the single port participating in the join
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinSinglePortReceiver.ShouldCommit">
      <summary>
            Determines if the port has N messages and if it does schedules a commit
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinSinglePortReceiver.Evaluate(Microsoft.Ccr.Core.Arbiters.IPortElement,Microsoft.Ccr.Core.ITask@)">
      <summary>
            Called in the context of Port.Post() to check if the join can schedule a commit
            </summary>
      <param name="deferredTask">Not used</param>
      <param name="messageNode">Message being posted. Not used</param>
      <returns>always returns false since it never consumes a message</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinSinglePortReceiver.Consume(Microsoft.Ccr.Core.Arbiters.IPortElement)">
      <summary>
            Consume
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinSinglePortReceiver.Commit">
      <summary>
            Attempts to retrieve N items from the same port
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.JoinSinglePortReceiver.UnrollPartialCommit(Microsoft.Ccr.Core.Arbiters.IPortElement[])">
      <summary>
            If commit fails this routine gets called to post back any items mremoved from the port
            </summary>
      <param name="items">
      </param>
    </member>
    <member name="T:Microsoft.Ccr.Core.Receiver">
      <summary>
            The most basic arbiter associates a user delegate (a receiver) with a port
            </summary>
      <remarks>
            When a message is posted to a port with a Receiver attached, the receiver will
            always consume the message, create a Task with the message and user delegate as arguments and schedule the task
            </remarks>
    </member>
    <member name="M:Microsoft.Ccr.Core.Receiver.#ctor(Microsoft.Ccr.Core.IPortReceive,Microsoft.Ccr.Core.ITask)">
      <summary>
            Constructs a SingleItemReceiver
            </summary>
      <param name="port">Port that the receiver will be attached to</param>
      <param name="task">Task instance typed to the same type as the port and with a user handler specified</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Receiver.#ctor(System.Boolean,Microsoft.Ccr.Core.IPortReceive,Microsoft.Ccr.Core.ITask)">
      <summary>
            Constructs a SingleItemReceiver
            </summary>
      <param name="persist">
      </param>
      <param name="port">
      </param>
      <param name="task">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Receiver.Cleanup">
      <summary>
            Unregisters this receiver instance from the port
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Receiver.Cleanup(Microsoft.Ccr.Core.ITask)">
      <summary>
            Post back any message instances associated with the Task instance
            </summary>
      <param name="taskToCleanup">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Receiver.Evaluate(Microsoft.Ccr.Core.Arbiters.IPortElement,Microsoft.Ccr.Core.ITask@)">
      <summary>
            Invoked in the context Port.Post(). The receiver will consult its parent
            arbiter and if the parent accepts, the receiver will consume the item, 
            and schedule a task with it as an argument
            </summary>
      <param name="deferredTask">Set to a task instance with the user delegate and message if arbitration is succesfull</param>
      <param name="messageNode">Message being posted</param>
      <returns>True if parent arbiter accepts, false otherwise</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Receiver.Consume(Microsoft.Ccr.Core.Arbiters.IPortElement)">
      <summary>
            Consume
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="P:Microsoft.Ccr.Core.Receiver.KeepItemInPort">
      <summary>
            Set to true to generate a NOP task as an iterator can progress while returning
            false from Evaluate, thus keeping an item in the port.
            </summary>
      <remarks>Used for implicit convertion operators of port to Receiver or Choice that are meant
            to progress iterator logic but with no continuation supplied</remarks>
    </member>
    <member name="P:Microsoft.Ccr.Core.Receiver.Arbiter">
      <summary>
            Parent arbiter to consult before consuming a message
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.MultipleItemHelperReceiver">
      <summary>
            Receiver that attaches to ports included in a MultipleItemReceiver. Calls to
            parent when messages is posted on its attached port
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.GatherPrivateReceiver">
      <summary>
            A helper task that uses single item persisted receivers to collect items from multiple
            ports and then accumulate them across collections based on item type. When the supplied count
            is reached it will execute the user task. This essentially a gather operation that works with
            an scatterg operation that used the same PortSet for the response port in all outbound messages
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.MultipleItemReceiver">
      <summary>
            Collects N messages from N ports, then executes a task passing a collection with N messages
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemReceiver.#ctor(Microsoft.Ccr.Core.ITask,Microsoft.Ccr.Core.IPortReceive[])">
      <summary>
            Initialization constructor
            </summary>
      <param name="ports">Ports that items will be posted</param>
      <param name="userTask">Task to execute when one message from each port has been received</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemReceiver.PartialClone">
      <summary>
            Creates new instance of receiver with the same initial parameters as current instance
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemReceiver.Execute">
      <summary>
            Activate task by registering receivers to each port
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemReceiver.Evaluate(Microsoft.Ccr.Core.Arbiters.IPortElement,Microsoft.Ccr.Core.ITask@)">
      <summary>
            Not implemented
            </summary>
      <param name="messageNode">
      </param>
      <param name="deferredTask">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemReceiver.Consume(Microsoft.Ccr.Core.Arbiters.IPortElement)">
      <summary>
            Not implemented
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemReceiver.Cleanup">
      <summary>
            Cleanup
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemReceiver.Cleanup(Microsoft.Ccr.Core.ITask)">
      <summary>
            Cleanup of user task if commit through arbiter hierarchy fails
            </summary>
      <param name="taskToCleanup">
      </param>
    </member>
    <member name="P:Microsoft.Ccr.Core.MultipleItemReceiver.Arbiter">
      <summary>
            Parent arbiter to consult before consuming a message
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.MultipleItemGather">
      <summary>
            Collects N messages from K ports, then executes a task passing K typed collections of messages
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemGather.#ctor(System.Type[],Microsoft.Ccr.Core.IPortReceive[],System.Int32,Microsoft.Ccr.Core.Handler{System.Collections.ICollection[]})">
      <summary>
            Constructs a helper for gathering results
            </summary>
      <param name="types">Array of discrete types. Must match generic type parameters of ports supplied</param>
      <param name="ports">Ports that items will be posted</param>
      <param name="itemCount">Total number of items received across all ports</param>
      <param name="handler">Handler to execute when total number of messages have been received</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemGather.PartialClone">
      <summary>
            Creates new instance of receiver with the same initial parameters as current instance
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemGather.Execute">
      <summary>
            Activate task by registering receivers to each port
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemGather.Cleanup">
      <summary>
            Cleanup
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemGather.Evaluate(Microsoft.Ccr.Core.Arbiters.IPortElement,Microsoft.Ccr.Core.ITask@)">
      <summary>
            Not supported
            </summary>
      <param name="messageNode">port element</param>
      <param name="deferredTask">task</param>
      <returns>true or false</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemGather.Consume(Microsoft.Ccr.Core.Arbiters.IPortElement)">
      <summary>
            Not supported
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemGather.Cleanup(Microsoft.Ccr.Core.ITask)">
      <summary>
            invoked by a parent arbiter to return items back to ports if another receiver won arbitration
            </summary>
      <param name="taskToCleanup">Task to use for re-posting arguments back to ports</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.MultipleItemGather.UnrollPartialCommit(System.Collections.ICollection[])">
      <summary>
            Returns any items retrieved back to their respective ports
            </summary>
      <param name="results">
      </param>
    </member>
    <member name="P:Microsoft.Ccr.Core.MultipleItemGather.Arbiter">
      <summary>
            Parent arbiter to consult before consuming a message
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Receiver`1">
      <summary>
            Strongly typed version of <see cref="T:Microsoft.Ccr.Core.Receiver" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Receiver`1.#ctor(Microsoft.Ccr.Core.IPortReceive,System.Predicate{`0},Microsoft.Ccr.Core.Task{`0})">
      <summary>
            Constructs a SingleItemReceiver
            </summary>
      <param name="port">Port that the receiver will be attached to</param>
      <param name="predicate">Predicate delegate that guards the user delegate with some value based match</param>
      <param name="task">Task instance typed to the same type as the port and with a user handler specified</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Receiver`1.#ctor(System.Boolean,Microsoft.Ccr.Core.IPortReceive,System.Predicate{`0},Microsoft.Ccr.Core.Task{`0})">
      <summary>
            Constructs a SingleItemReceiver
            </summary>
      <param name="persist">
      </param>
      <param name="port">
      </param>
      <param name="predicate">
      </param>
      <param name="task">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Receiver`1.#ctor(System.Boolean,Microsoft.Ccr.Core.IPortReceive,System.Predicate{`0},Microsoft.Ccr.Core.IterativeTask{`0})">
      <summary>
            Constructs a SingleItemReceiver
            </summary>
      <param name="persist">
      </param>
      <param name="port">
      </param>
      <param name="predicate">
      </param>
      <param name="task">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Receiver`1.#ctor(Microsoft.Ccr.Core.IPortReceive,System.Predicate{`0},Microsoft.Ccr.Core.IterativeTask{`0})">
      <summary>
            Constructs a SingleItemReceiver
            </summary>
      <param name="port">Port that the receiver will be attached to</param>
      <param name="predicate">Predicate delegate that guards the user delegate with some value based match</param>
      <param name="task">Task instance typed to the same type as the port and with a user handler specified</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Receiver`1.Evaluate(Microsoft.Ccr.Core.Arbiters.IPortElement,Microsoft.Ccr.Core.ITask@)">
      <summary>
            Invoked in the context Port.Post(). The receiver will consult its parent
            arbiter and if the parent accepts, the receiver will consume the item, 
            and schedule a task with it as an argument
            </summary>
      <param name="deferredTask">Set to a task instance with the user delegate and message if arbitration is succesfull</param>
      <param name="messageNode">Message being posted</param>
      <returns>True if parent arbiter accepts, false otherwise</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.Receiver`1.Predicate">
      <summary>
            Predicate logic for the receiver
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Choice">
      <summary>
            The choice arbiter will arbitrate between N child receivers (branches) and only allow one to
            proceed
            </summary>
      <remarks>
            If the child arbiters/receivers are reissue the choice will always allow them
            to proceed. When the first non-reissue receiver to fire executes however the entire choice context
            will teardown
            </remarks>
    </member>
    <member name="M:Microsoft.Ccr.Core.Choice.ToString">
      <summary>
            Description of the Choice state and children branches
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Choice.#ctor(Microsoft.Ccr.Core.Arbiters.ReceiverTask[])">
      <summary>
            Constructs a Choice arbiter given an array of receivers
            </summary>
      <param name="branches">Receiver tasks that form the choice</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Choice.PartialClone">
      <summary>
            Not supported
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Choice.Execute">
      <summary>
            Invoked by the dispatcher/scheduler to register the choice as a parent arbiter
            on all its receivers
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Choice.Cleanup(Microsoft.Ccr.Core.ITask)">
      <summary>
            Clenaup is scheduled when one of the branches wins arbitration and needs
            to schedule the user continuation
            </summary>
      <param name="winner">Task generated by the winning receiver</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Choice.Evaluate(Microsoft.Ccr.Core.Arbiters.ReceiverTask,Microsoft.Ccr.Core.ITask@)">
      <summary>
            Invoked by the child receivers to determine if they can proceed
            </summary>
      <param name="receiver">Child receiver invoking this method</param>
      <param name="deferredTask">Set to null if the receiver calling in lost arbitration. Not modified otherwise</param>
      <returns>true if child receiver one the arbitration. False otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.Choice.TaskQueue">
      <summary>
            Dispatcher queue to use for scheduling any tasks 
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Choice.ArbiterCleanupHandler">
      <summary>
            Set by a top level arbiter so it can execute logic on task completion
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Choice.LinkedIterator">
      <summary>
            Iterator that needs to be processed once current task completes
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Choice.ArbiterState">
      <summary>
            Current state of the choice arbiter.
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Choice.Item(System.Int32)">
      <summary>
            Not supported
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.Choice.PortElementCount">
      <summary>
            Always zero
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortExtensions">
      <summary>
            Port extension methods for coordination primitive creation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortExtensions.Receive``1(Microsoft.Ccr.Core.Port{``0})">
      <summary>
            Iterator use only. Creates a one time receiver that satisfies the yield operation and leaves the received item in the port
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="port">Port instance</param>
      <returns>Receiver instance for yielding execution</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortExtensions.Receive``1(Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Creates a one time receiver
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="port">
      </param>
      <param name="handler">User delegate that executes when there is an item on the port</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortExtensions.Receive``1(Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Handler{``0},System.Predicate{``0})">
      <summary>
            Creates a one time receiver
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="port">
      </param>
      <param name="handler">User delegate that executes when there is an item on the port</param>
      <param name="predicate">Predicate that determines if item should be consumed by receiver or ignored</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortExtensions.Join``2(Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Port{``1},Microsoft.Ccr.Core.Handler{``0,``1})">
      <summary>
            Creates a one time Join across two ports
            </summary>
      <param name="port">
      </param>
      <param name="port1">
      </param>
      <param name="handler">User delegate that executes when there is an item on the port</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortExtensions.Join``3(Microsoft.Ccr.Core.Port{``0},Microsoft.Ccr.Core.Port{``1},Microsoft.Ccr.Core.Port{``2},Microsoft.Ccr.Core.Handler{``0,``1,``2})">
      <summary>
            Creates a one time Join across two ports
            </summary>
      <param name="port">
      </param>
      <param name="port1">
      </param>
      <param name="port2">
      </param>
      <param name="handler">User delegate that executes when there is an item on the port</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortExtensions.Join``1(Microsoft.Ccr.Core.Port{``0},System.Int32,Microsoft.Ccr.Core.VariableArgumentHandler{``0})">
      <summary>
            Creates a one time Join for multiple items from the same port instance
            </summary>
      <typeparam name="T0">
      </typeparam>
      <param name="port">Port instance to collect items from, in any order</param>
      <param name="itemCount">Number of items</param>
      <param name="handler">User delegates that executes when all items are received</param>
      <returns>
      </returns>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSetExtensions">
      <summary>
            PortSet extension methods for coordination primitive creation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSetExtensions.Choice``2(Microsoft.Ccr.Core.PortSet{``0,``1})">
      <summary>
            Iterator use only. Creates a choice with a one time receiver registered in each Port within the port set, that will post the item back in the port.
            </summary>
      <typeparam name="T0">
      </typeparam>
      <typeparam name="T1">
      </typeparam>
      <param name="portSet">PortSet instance to register choice and receivers on</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSetExtensions.Choice``3(Microsoft.Ccr.Core.PortSet{``0,``1,``2})">
      <summary>
            Iterator use only. Creates a choice with a one time receiver registered in each Port within the port set, that will post the item back in the port.
            </summary>
      <param name="portSet">PortSet instance to register choice and receivers on</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSetExtensions.Choice``2(Microsoft.Ccr.Core.PortSet{``0,``1},Microsoft.Ccr.Core.Handler{``0},Microsoft.Ccr.Core.Handler{``1})">
      <summary>
            Creates a choice with two one time receivers, one for each port in the port set.
            </summary>
      <typeparam name="T0">
      </typeparam>
      <typeparam name="T1">
      </typeparam>
      <param name="portSet">PortSet instance to register choice and receivers on</param>
      <param name="handler0">Handler that executes if item of type T0 is received first</param>
      <param name="handler1">Handler that executes if item of type T1 is received first</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSetExtensions.Choice``3(Microsoft.Ccr.Core.PortSet{``0,``1,``2},Microsoft.Ccr.Core.Handler{``0},Microsoft.Ccr.Core.Handler{``1},Microsoft.Ccr.Core.Handler{``2})">
      <summary>
            Creates a choice with two one time receivers, one for each port in the port set.
            </summary>
      <typeparam name="T0">
      </typeparam>
      <typeparam name="T1">
      </typeparam>
      <typeparam name="T2">
      </typeparam>
      <param name="portSet">PortSet instance to register choice and receivers on</param>
      <param name="handler0">Handler that executes if item of type T0 is received first</param>
      <param name="handler1">Handler that executes if item of type T1 is received first</param>
      <param name="handler2">Handler that executes if item of type T1 is received first</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSetExtensions.MultipleItemReceive``2(Microsoft.Ccr.Core.PortSet{``0,``1},System.Int32,Microsoft.Ccr.Core.Handler{System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``1}})">
      <summary>
            Creates a coordination task that collects items from multiple ports in the same PortSet.
            It then accumulates the results in collections based on item type. When the supplied count
            is reached it will execute the user task. 
            </summary>
      <param name="portSet">PortSet instance</param>
      <param name="totalItemCount">Total number of items to receive across all ports in the PortSet instance</param>
      <param name="handler">User delegate</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSetExtensions.Receive``2(Microsoft.Ccr.Core.PortSet{``0,``1},Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Creates a one time receiver
            </summary>
      <param name="portSet">
      </param>
      <param name="handler">User delegate that executes when there is an item on the port</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSetExtensions.Receive``2(Microsoft.Ccr.Core.PortSet{``0,``1},Microsoft.Ccr.Core.Handler{``1})">
      <summary>
            Creates a one time receiver
            </summary>
      <param name="portSet">
      </param>
      <param name="handler">User delegate that executes when there is an item on the port</param>
      <returns>
      </returns>
    </member>
    <member name="T:Microsoft.Ccr.Core.Arbiters.IPortElement">
      <summary>
            Container for port messages
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.IPortElement.Owner">
      <summary>
            Port that owns this element
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.IPortElement.Next">
      <summary>
            Linked list Next pointer
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.IPortElement.Previous">
      <summary>
            Linked list Previous pointer
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.IPortElement.CausalityContext">
      <summary>
            CCR use only. Used for flowing context across tasks
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.IPortElement.Item">
      <summary>
            Message instance
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Arbiters.IPortElement`1">
      <summary>
            Container for typed port messages
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.IPortElement`1.TypedItem">
      <summary>
            Message instance
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Arbiters.PortElement`1">
      <summary>
            Container class for port messages. Generic type is the same as the port type
            this container will be posted to. Ports maintain a queue of these containers
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.PortElement`1.#ctor(`0)">
      <summary>
            Constructs a PortElement
            </summary>
      <param name="item">Item</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Arbiters.PortElement`1.#ctor(`0,Microsoft.Ccr.Core.Port{`0})">
      <summary>
            Constructs a PortElement
            </summary>
      <param name="item">Item</param>
      <param name="owner">Port instance that owns this element</param>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.PortElement`1.Owner">
      <summary>
            Port instance that owns this element
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.PortElement`1.Next">
      <summary>
            Next element 
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.PortElement`1.Previous">
      <summary>
            Previous element
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.PortElement`1.CausalityContext">
      <summary>
            Logical context associated with this element
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.PortElement`1.Item">
      <summary>
            Message instance
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Arbiters.PortElement`1.TypedItem">
      <summary>
            Typed accessor to message instance
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Arbiters.ArbiterTaskState">
      <summary>
            State types for CCR arbiters
            <remarks>Choice, interleave, join are all arbiters than can be in one of these states</remarks></summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Arbiters.ArbiterTaskState.Created">
      <summary>
            Initial state of an arbiter before its attached to a port or child receivers/arbiters
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Arbiters.ArbiterTaskState.Active">
      <summary>
            When a port is registered to a port or at least one children arbiter, it becomes active
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Arbiters.ArbiterTaskState.Done">
      <summary>
            An arbiter reaches the Done state when it will no longer process any more messages and its ready for cleanup
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Arbiters.ReceiverTaskState">
      <summary>
            Receive thunk state
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Arbiters.ReceiverTaskState.Onetime">
      <summary>
            Onetime receivers will process one message and then unregister
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Arbiters.ReceiverTaskState.Persistent">
      <summary>
            Persistant receivers consume more than one item and stay registered on the port
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Arbiters.ReceiverTaskState.CleanedUp">
      <summary>
            A receiver will reach this state if its one time and it processed a message or because its
            parent arbiter decided to clean it up
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Resource1">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.ChoiceAlreadyActiveException">
      <summary>
              Looks up a localized string similar to "Choice has already been initialized".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.ChoiceBranchesCannotBePersisted">
      <summary>
              Looks up a localized string similar to "Receiver tasks in Choice can not be persisted".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.DispatcherPortTestNotValidInThreadpoolMode">
      <summary>
              Looks up a localized string similar to "Test not valid when dispatcher port is using thread pool".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.EnqueueTimerNotSupportedForClrThreadPoolDispatcherQueues">
      <summary>
              Looks up a localized string similar to "Not supported on dispatcher queues that use the CLR ThreadPool. Use dispatcherQueue constructed with a CCR dispatcher".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.ExceptionDuringArbiterCleanup">
      <summary>
              Looks up a localized string similar to "ArbiterCleanup failed during exception handling for failed task".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.ExceptionDuringCausalityHandling">
      <summary>
              Looks up a localized string similar to n by task".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.HandleExceptionLog">
      <summary>
              Looks up a localized string similar to "TaskExecutionWorker:HandleException".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.InterleaveCannotHaveFinalizerException">
      <summary>
              Looks up a localized string similar to  "Interleave can not have a Finalizer".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.IteratorsCannotYieldToInterleaveException">
      <summary>
              Looks up a localized string similar to "Iterators can not yield to interleave".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.IteratorsCannotYieldToReissueException">
      <summary>
              Looks up a localized string similar to "Iterators can not yield to a re-issue (!) receive".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.JoinReceiverDuplicatePortMessage">
      <summary>
              Looks up a localized string similar to "Duplicate port supplied to multiple-port Join".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.JoinSinglePortReceiverAtLeastOneItemMessage">
      <summary>
              Looks up a localized string similar to "You must join with at least 1 items".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.JoinsMustHaveOnePortMinimumException">
      <summary>
              Looks up a localized string similar to "Joins must have at least one port".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.ReceiveThunkInvalidOperation">
      <summary>
              Looks up a localized string similar to "An Arbiter is already registered for this thunk!".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.TaskAlreadyHasFinalizer">
      <summary>
              Looks up a localized string similar to "Task instance already has a completion handler".
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Resource1.TeardownBranchesCannotBePersisted">
      <summary>
              Looks up a localized string similar to "Receiver tasks in teardown group can not be persisted".
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.DispatcherOptions">
      <summary>
            Dispatcher configuration options
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.DispatcherOptions.None">
      <summary>
            Default options will be used
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.DispatcherOptions.UseBackgroundThreads">
      <summary>
            The Task Execution Worker Threads will be created as background threads, allowing application exit even if they are active
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.DispatcherOptions.UseProcessorAffinity">
      <summary>
            Task Execution Worker Threads will be assigned on an individual core. 
            If number of threads is greater than number of cores, the dispatcher will equally distribute threads per core
            </summary>
      <remarks>Affinity is just a hint to the operating system. There are no strong guarantees that a thread will remain on the assigned core</remarks>
    </member>
    <member name="F:Microsoft.Ccr.Core.DispatcherOptions.SuppressDisposeExceptions">
      <summary>
            Attempting to enqueue or dequeue tasks after Dispose is called on the Dispatcher and its associated queues will silently fail instead of
            throwing exceptions
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.TaskExecutionPolicy">
      <summary>
            Specifies dispatcher queue task scheduling behavior
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.TaskExecutionPolicy.Unconstrained">
      <summary>
            Default behavior, all tasks are queued with no constraints
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.TaskExecutionPolicy.ConstrainQueueDepthDiscardTasks">
      <summary>
            Queue enforces maximum depth (specified at queue creation) 
            and discards tasks enqueued after the limit is reached
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.TaskExecutionPolicy.ConstrainQueueDepthThrottleExecution">
      <summary>
            Queue enforces maximum depth (specified at queue creation)
            but does not discard anny tasks. It forces the thread posting any tasks after the limit is reached, to
            sleep until the queue depth falls below the limit
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.TaskExecutionPolicy.ConstrainSchedulingRateDiscardTasks">
      <summary>
            Queue enforces the rate of task scheduling specified at queue creation
            and discards tasks enqueued after the current scheduling rate is above the specified rate
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.TaskExecutionPolicy.ConstrainSchedulingRateThrottleExecution">
      <summary>
            Queue enforces the rate of task scheduling specified at queue creation
            and forces the thread posting tasks to sleep until the current rate of task scheduling falls below
            the specified average rate
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.DispatcherQueue">
      <summary>
            Special variant of a typed Port for enqueing and scheduling CCR Tasks
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.DispatcherQueue._taskQueue">
      <summary>
            Queue for ITask implementations thats dont use TaskCommon abstract base class
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.DispatcherQueue._taskCommonListHead">
      <summary>
            Custom (optimized) queue (list head) for ITask implementations that use TaskCommon base class
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.DispatcherQueue.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.DispatcherQueue.#ctor(System.String)">
      <summary>
            Constructs an instance of the dispatcher port using the CLR thread pool for task execution
            </summary>
      <param name="name">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.DispatcherQueue.#ctor(System.String,Microsoft.Ccr.Core.Dispatcher)">
      <summary>
            Constructs an instance of the dispatcher port using the specified CCR dispatcher
            </summary>
      <param name="name">
      </param>
      <param name="dispatcher">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.DispatcherQueue.#ctor(System.String,Microsoft.Ccr.Core.Dispatcher,Microsoft.Ccr.Core.TaskExecutionPolicy,System.Int32)">
      <summary>
            Constructs an instance of the dispatcher port using the specified CCR dispatcher
            </summary>
      <param name="name">Friendly name</param>
      <param name="dispatcher">Dispatcher instance for executing tasks</param>
      <param name="policy">Task scheduling policy</param>
      <param name="maximumQueueDepth">Maximum number of pending tasks. 
            Only valid when appropriate policy is specified</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.DispatcherQueue.#ctor(System.String,Microsoft.Ccr.Core.Dispatcher,Microsoft.Ccr.Core.TaskExecutionPolicy,System.Double)">
      <summary>
            Constructs an instance of the dispatcher port using the specified CCR dispatcher
            </summary>
      <param name="name">Friendly name</param>
      <param name="dispatcher">Dispatcher instance for executing tasks</param>
      <param name="policy">Task scheduling policy</param>
      <param name="schedulingRate">Average desired scheduling rate, in tasks per second. 
            Only valid when appropriate policy is specified</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.DispatcherQueue.#ctor(System.String,Microsoft.Ccr.Core.Dispatcher,Microsoft.Ccr.Core.TaskExecutionPolicy,System.Int32,System.Double)">
      <summary>
            Constructs an instance of the dispatcher port using the specified CCR dispatcher
            </summary>
      <param name="name">Friendly name</param>
      <param name="dispatcher">Dispatcher instance for executing tasks</param>
      <param name="policy">Task scheduling policy</param>
      <param name="maximumQueueDepth">Maximum number of pending tasks. 
            Only used when appropriate policy is specified</param>
      <param name="schedulingRate">Average desired scheduling rate, in tasks per second. 
            Only used when appropriate policy is specified</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.DispatcherQueue.EnqueueTimer(System.TimeSpan,Microsoft.Ccr.Core.Port{System.DateTime})">
      <summary>
            Enqueues a timer registration that will post a DateTime item on the timerPort
            </summary>
      <param name="timeSpan">
      </param>
      <param name="timerPort">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.DispatcherQueue.Enqueue(Microsoft.Ccr.Core.ITask)">
      <summary>
            Enqueue ITask instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">Thrown if message type is not derived from ITask</exception>
      <param name="task">ITask instance</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.DispatcherQueue.Suspend">
      <summary>
            Suspend scheduling of tasks. Tasks can still be queued
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.DispatcherQueue.Resume">
      <summary>
            Resumes execution of tasks, including any tasks queued while in paused state
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.DispatcherQueue.TryDequeue(Microsoft.Ccr.Core.ITask@)">
      <summary>
            Atomically removes an ITask instance if the port is non empty
            </summary>
      <param name="task">ITask instance if port is not empty. Null otherwise</param>
      <returns>True if port is not empty</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.DispatcherQueue.Dispose">
      <summary>
            Dispose releases resources associated with this instance
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.DispatcherQueue.Dispose(System.Boolean)">
      <summary>
            Implementation of dispose
            </summary>
      <param name="disposing">
      </param>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.IsDisposed">
      <summary>
            True if Disposed method has been called (dispose might still be in progress)
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.IsSuspended">
      <summary>
            True if task scheduling is suspended
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.Name">
      <summary>
            Friendly name for consumer of this dispatcher port
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.IsUsingThreadPool">
      <summary>
            Indicates if the CLR thread pool is used for task execution, instead of a CCR Dispatcher
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.Dispatcher">
      <summary>
            Parent dispatcher managing OS threads that execute tasks queued through this instance
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.Count">
      <summary>
            Number of ITask instances currently queued
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.ScheduledTaskCount">
      <summary>
            Number of tasks scheduled so far
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.Policy">
      <summary>
            Execution policy
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.MaximumQueueDepth">
      <summary>
            Maximum depth of queued tasks
            </summary>
      <remarks>Valid only when appropriate policy is set</remarks>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.CurrentSchedulingRate">
      <summary>
            Current rate of tasks being scheduled in tasks/second
            </summary>
      <remarks>Valid only when appropriate execution policy is set</remarks>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.MaximumSchedulingRate">
      <summary>
            Upper bound on scheduling rate that determines throttling
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.Timescale">
      <summary>
            Factor multiplied with TimeSpan values to compute absolute time duration for all EnqueueTimer calls 
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.ExecutionPolicyNotificationPort">
      <summary>
            Signals execution policy events such as queue limits being exceeded.
            </summary>
      <remarks> 
            Stores discarded tasks when <see cref="T:Microsoft.Ccr.Core.TaskExecutionPolicy" /> is enabled. If policy is not set to discard
            null items will still be queued to signal that throttling is occuring due to limits being exceeded.
            </remarks>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.ThrottlingSleepInterval">
      <summary>
            Duration of thread sleep when throttling is enforced during an Enqueue operation
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.DispatcherQueue.UnhandledExceptionPort">
      <summary>
            Gets or sets a port that any unhandled exceptions occuring in tasks running in 
            this DispatcherQueue will be sent to.
            </summary>
    </member>
    <member name="E:Microsoft.Ccr.Core.DispatcherQueue.UnhandledException">
      <summary>
            This event is raised when an unhandled exception occurs in tasks running in this 
            DispatcherQueue
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.TaskExecutionWorker.CheckStartupComplete">
      <summary>
            when all the workers associated with same Dispatcher instance are initialized and started
            we signal an event on the parent to indicate startup is complete
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.TaskExecutionWorker.CheckShutdownComplete">
      <summary>
            When all workers have exited their thread entry methods and are processing no items
            we signal a shutdown event on the parent
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.TaskExecutionWorker.IsCriticalException(System.Exception)">
      <summary>
            Is the supplied exception of sufficient severity that it should not be handled?
            </summary>
      <param name="exception">The exception to test</param>
      <returns>True, if this exception should not be handled by the application</returns>
    </member>
    <member name="T:Microsoft.Ccr.Core.CcrServiceBase">
      <summary>
            Base CCR class
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.CcrServiceBase.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.CcrServiceBase.#ctor(Microsoft.Ccr.Core.DispatcherQueue)">
      <summary>
            Create instance using a specific dispatcher port.
            </summary>
      <param name="dispatcherQueue">
      </param>
    </member>
    <member name="M:Microsoft.Ccr.Core.CcrServiceBase.Activate``1(``0[])">
      <summary>
            Submits CCR tasks to the dispatcher port for execution. If the task was a receiver orchestration
            like join or choice, executing it means registering constraints on ports to
            guard the execution of user code
            </summary>
      <typeparam name="T">Task instance</typeparam>
      <param name="tasks">Tasks to execute</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.CcrServiceBase.EmptyHandler``1(``0)">
      <summary>
            An empty handler implementation that can be used in a receiver to 
            handle a message without side effects
            </summary>
      <typeparam name="T">The message type</typeparam>
      <param name="message">The message</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.CcrServiceBase.TimeoutPort(System.Int32)">
      <summary>
            Creates a port to receive a time signal, registers a timeout with the sequencer,
            supplying the private port. 
            </summary>
      <param name="milliseconds">Timeout in milliseconds</param>
      <returns>Port instance registered with sequencer for receiving timeout signal</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.CcrServiceBase.TimeoutPort(System.TimeSpan)">
      <summary>
            Creates a port to receive a time signal, registers a timeout with the sequencer,
            supplying the private port. 
            </summary>
      <param name="ts">Timespan for timeout period</param>
      <returns>Port instance registered with sequencer for receiving timeout signal</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.CcrServiceBase.Spawn(Microsoft.Ccr.Core.Handler)">
      <summary>
            Invoke a message handler asynchronously, supplying any arguments explicitly.
            </summary>
      <param name="handler">The message handler to invoke.</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.CcrServiceBase.SpawnIterator(Microsoft.Ccr.Core.IteratorHandler)">
      <summary>
            Invoke an iterator-based message handler asynchronously, supplying any arguments explicitly.
            </summary>
      <param name="handler">The message handler to invoke.</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.CcrServiceBase.Spawn``1(``0,Microsoft.Ccr.Core.Handler{``0})">
      <summary>
            Invoke a message handler asynchronously, supplying any arguments explicitly.
            </summary>
      <typeparam name="T0">The 0th parameter type to the message handler.</typeparam>
      <param name="t0">The 0th parameter to the message handler.</param>
      <param name="handler">The message handler to invoke.</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.CcrServiceBase.SpawnIterator``1(``0,Microsoft.Ccr.Core.IteratorHandler{``0})">
      <summary>
            Invoke an iterator-based message handler asynchronously, supplying any arguments explicitly.
            </summary>
      <typeparam name="T0">The 0th parameter type to the message handler.</typeparam>
      <param name="t0">The 0th parameter to the message handler.</param>
      <param name="handler">The message handler to invoke.</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.CcrServiceBase.Spawn``2(``0,``1,Microsoft.Ccr.Core.Handler{``0,``1})">
      <summary>
            Invoke a message handler asynchronously, supplying any arguments explicitly.
            </summary>
      <typeparam name="T0">The 0th parameter type to the message handler.</typeparam>
      <param name="t0">The 0th parameter to the message handler.</param>
      <typeparam name="T1">The 1th parameter type to the message handler.</typeparam>
      <param name="t1">The 1th parameter to the message handler.</param>
      <param name="handler">The message handler to invoke.</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.CcrServiceBase.SpawnIterator``2(``0,``1,Microsoft.Ccr.Core.IteratorHandler{``0,``1})">
      <summary>
            Invoke an iterator-based message handler asynchronously, supplying any arguments explicitly.
            </summary>
      <typeparam name="T0">The 0th parameter type to the message handler.</typeparam>
      <param name="t0">The 0th parameter to the message handler.</param>
      <typeparam name="T1">The 1th parameter type to the message handler.</typeparam>
      <param name="t1">The 1th parameter to the message handler.</param>
      <param name="handler">The message handler to invoke.</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.CcrServiceBase.Spawn``3(``0,``1,``2,Microsoft.Ccr.Core.Handler{``0,``1,``2})">
      <summary>
            Invoke a message handler asynchronously, supplying any arguments explicitly.
            </summary>
      <typeparam name="T0">The 0th parameter type to the message handler.</typeparam>
      <param name="t0">The 0th parameter to the message handler.</param>
      <typeparam name="T1">The 1th parameter type to the message handler.</typeparam>
      <param name="t1">The 1th parameter to the message handler.</param>
      <typeparam name="T2">The 2th parameter type to the message handler.</typeparam>
      <param name="t2">The 2th parameter to the message handler.</param>
      <param name="handler">The message handler to invoke.</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.CcrServiceBase.SpawnIterator``3(``0,``1,``2,Microsoft.Ccr.Core.IteratorHandler{``0,``1,``2})">
      <summary>
            Invoke an iterator-based message handler asynchronously, supplying any arguments explicitly.
            </summary>
      <typeparam name="T0">The 0th parameter type to the message handler.</typeparam>
      <param name="t0">The 0th parameter to the message handler.</param>
      <typeparam name="T1">The 1th parameter type to the message handler.</typeparam>
      <param name="t1">The 1th parameter to the message handler.</param>
      <typeparam name="T2">The 2th parameter type to the message handler.</typeparam>
      <param name="t2">The 2th parameter to the message handler.</param>
      <param name="handler">The message handler to invoke.</param>
    </member>
    <member name="P:Microsoft.Ccr.Core.CcrServiceBase.TaskQueue">
      <summary>
            Dispatcher port associated with this instance. Used by Activate() calls to schedule tasks
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Handler">
      <summary>
            Closure signature for message handler.
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.IteratorHandler">
      <summary>
            Closure signature for iterator-based message handler.
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Handler`1">
      <summary>
            Closure signature for message handler.
            </summary>
      <typeparam name="T0">The 0th parameter type to the message handler.</typeparam>
      <param name="parameter0">The 0th parameter to the message handler.</param>
    </member>
    <member name="T:Microsoft.Ccr.Core.IteratorHandler`1">
      <summary>
            Closure signature for iterator-based message handler.
            </summary>
      <typeparam name="T0">The 0th parameter type to the message handler.</typeparam>
      <param name="parameter0">The 0th parameter to the message handler.</param>
    </member>
    <member name="T:Microsoft.Ccr.Core.Handler`2">
      <summary>
            Closure signature for message handler.
            </summary>
      <typeparam name="T0">The 0th parameter type to the message handler.</typeparam>
      <param name="parameter0">The 0th parameter to the message handler.</param>
      <typeparam name="T1">The 1th parameter type to the message handler.</typeparam>
      <param name="parameter1">The 1th parameter to the message handler.</param>
    </member>
    <member name="T:Microsoft.Ccr.Core.IteratorHandler`2">
      <summary>
            Closure signature for iterator-based message handler.
            </summary>
      <typeparam name="T0">The 0th parameter type to the message handler.</typeparam>
      <param name="parameter0">The 0th parameter to the message handler.</param>
      <typeparam name="T1">The 1th parameter type to the message handler.</typeparam>
      <param name="parameter1">The 1th parameter to the message handler.</param>
    </member>
    <member name="T:Microsoft.Ccr.Core.Handler`3">
      <summary>
            Closure signature for message handler.
            </summary>
      <typeparam name="T0">The 0th parameter type to the message handler.</typeparam>
      <param name="parameter0">The 0th parameter to the message handler.</param>
      <typeparam name="T1">The 1th parameter type to the message handler.</typeparam>
      <param name="parameter1">The 1th parameter to the message handler.</param>
      <typeparam name="T2">The 2th parameter type to the message handler.</typeparam>
      <param name="parameter2">The 2th parameter to the message handler.</param>
    </member>
    <member name="T:Microsoft.Ccr.Core.IteratorHandler`3">
      <summary>
            Closure signature for iterator-based message handler.
            </summary>
      <typeparam name="T0">The 0th parameter type to the message handler.</typeparam>
      <param name="parameter0">The 0th parameter to the message handler.</param>
      <typeparam name="T1">The 1th parameter type to the message handler.</typeparam>
      <param name="parameter1">The 1th parameter to the message handler.</param>
      <typeparam name="T2">The 2th parameter type to the message handler.</typeparam>
      <param name="parameter2">The 2th parameter to the message handler.</param>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`3">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`3.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`3.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`3.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`3.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`3.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`3.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`3.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`3.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`3.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`3.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2})~`0">
      <summary>
            Invoke the Test method to extract an item of this type
            </summary>
      <param name="port">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`3.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2})~`1">
      <summary>
            Invoke the Test method to extract an item of this type
            </summary>
      <param name="port">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`3.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2})~`2">
      <summary>
            Invoke the Test method to extract an item of this type
            </summary>
      <param name="port">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`3.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`3.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`3.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`4">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`4.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`4.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`4.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`4.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`4.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`4.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`4.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`4.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`4.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`4.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`4.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`4.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`4.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`4.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`4.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`5">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`5.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`5.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`5.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`5.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`5.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`5.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`5.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`5.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`5.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`5.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`5.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`5.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`5.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`5.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`5.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`5.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`5.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`5.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`6">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`6.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`6.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`6.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`6.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`6.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`6.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`6.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`7">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5},Microsoft.Ccr.Core.Port{`6})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.Post(`6)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`7.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6})~Microsoft.Ccr.Core.Port{`6}">
      <summary>
            Convert to the 6th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`7.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`7.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`7.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`7.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`7.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`7.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`7.P6">
      <summary>
            Returns the port 6th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`8">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5},Microsoft.Ccr.Core.Port{`6},Microsoft.Ccr.Core.Port{`7})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.Post(`6)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.Post(`7)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7})~Microsoft.Ccr.Core.Port{`6}">
      <summary>
            Convert to the 6th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`8.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7})~Microsoft.Ccr.Core.Port{`7}">
      <summary>
            Convert to the 7th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`8.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`8.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`8.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`8.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`8.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`8.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`8.P6">
      <summary>
            Returns the port 6th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`8.P7">
      <summary>
            Returns the port 7th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`9">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5},Microsoft.Ccr.Core.Port{`6},Microsoft.Ccr.Core.Port{`7},Microsoft.Ccr.Core.Port{`8})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.Post(`6)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.Post(`7)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.Post(`8)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8})~Microsoft.Ccr.Core.Port{`6}">
      <summary>
            Convert to the 6th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8})~Microsoft.Ccr.Core.Port{`7}">
      <summary>
            Convert to the 7th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`9.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8})~Microsoft.Ccr.Core.Port{`8}">
      <summary>
            Convert to the 8th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`9.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`9.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`9.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`9.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`9.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`9.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`9.P6">
      <summary>
            Returns the port 6th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`9.P7">
      <summary>
            Returns the port 7th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`9.P8">
      <summary>
            Returns the port 8th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`10">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5},Microsoft.Ccr.Core.Port{`6},Microsoft.Ccr.Core.Port{`7},Microsoft.Ccr.Core.Port{`8},Microsoft.Ccr.Core.Port{`9})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.Post(`6)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.Post(`7)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.Post(`8)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.Post(`9)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})~Microsoft.Ccr.Core.Port{`6}">
      <summary>
            Convert to the 6th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})~Microsoft.Ccr.Core.Port{`7}">
      <summary>
            Convert to the 7th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})~Microsoft.Ccr.Core.Port{`8}">
      <summary>
            Convert to the 8th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`10.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})~Microsoft.Ccr.Core.Port{`9}">
      <summary>
            Convert to the 9th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`10.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`10.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`10.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`10.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`10.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`10.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`10.P6">
      <summary>
            Returns the port 6th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`10.P7">
      <summary>
            Returns the port 7th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`10.P8">
      <summary>
            Returns the port 8th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`10.P9">
      <summary>
            Returns the port 9th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`11">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5},Microsoft.Ccr.Core.Port{`6},Microsoft.Ccr.Core.Port{`7},Microsoft.Ccr.Core.Port{`8},Microsoft.Ccr.Core.Port{`9},Microsoft.Ccr.Core.Port{`10})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.Post(`6)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.Post(`7)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.Post(`8)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.Post(`9)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.Post(`10)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})~Microsoft.Ccr.Core.Port{`6}">
      <summary>
            Convert to the 6th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})~Microsoft.Ccr.Core.Port{`7}">
      <summary>
            Convert to the 7th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})~Microsoft.Ccr.Core.Port{`8}">
      <summary>
            Convert to the 8th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})~Microsoft.Ccr.Core.Port{`9}">
      <summary>
            Convert to the 9th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`11.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})~Microsoft.Ccr.Core.Port{`10}">
      <summary>
            Convert to the 10th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`11.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`11.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`11.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`11.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`11.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`11.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`11.P6">
      <summary>
            Returns the port 6th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`11.P7">
      <summary>
            Returns the port 7th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`11.P8">
      <summary>
            Returns the port 8th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`11.P9">
      <summary>
            Returns the port 9th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`11.P10">
      <summary>
            Returns the port 10th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`12">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5},Microsoft.Ccr.Core.Port{`6},Microsoft.Ccr.Core.Port{`7},Microsoft.Ccr.Core.Port{`8},Microsoft.Ccr.Core.Port{`9},Microsoft.Ccr.Core.Port{`10},Microsoft.Ccr.Core.Port{`11})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.Post(`6)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.Post(`7)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.Post(`8)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.Post(`9)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.Post(`10)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.Post(`11)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})~Microsoft.Ccr.Core.Port{`6}">
      <summary>
            Convert to the 6th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})~Microsoft.Ccr.Core.Port{`7}">
      <summary>
            Convert to the 7th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})~Microsoft.Ccr.Core.Port{`8}">
      <summary>
            Convert to the 8th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})~Microsoft.Ccr.Core.Port{`9}">
      <summary>
            Convert to the 9th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})~Microsoft.Ccr.Core.Port{`10}">
      <summary>
            Convert to the 10th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`12.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})~Microsoft.Ccr.Core.Port{`11}">
      <summary>
            Convert to the 11th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`12.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`12.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`12.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`12.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`12.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`12.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`12.P6">
      <summary>
            Returns the port 6th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`12.P7">
      <summary>
            Returns the port 7th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`12.P8">
      <summary>
            Returns the port 8th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`12.P9">
      <summary>
            Returns the port 9th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`12.P10">
      <summary>
            Returns the port 10th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`12.P11">
      <summary>
            Returns the port 11th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`13">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5},Microsoft.Ccr.Core.Port{`6},Microsoft.Ccr.Core.Port{`7},Microsoft.Ccr.Core.Port{`8},Microsoft.Ccr.Core.Port{`9},Microsoft.Ccr.Core.Port{`10},Microsoft.Ccr.Core.Port{`11},Microsoft.Ccr.Core.Port{`12})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.Post(`6)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.Post(`7)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.Post(`8)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.Post(`9)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.Post(`10)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.Post(`11)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.Post(`12)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})~Microsoft.Ccr.Core.Port{`6}">
      <summary>
            Convert to the 6th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})~Microsoft.Ccr.Core.Port{`7}">
      <summary>
            Convert to the 7th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})~Microsoft.Ccr.Core.Port{`8}">
      <summary>
            Convert to the 8th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})~Microsoft.Ccr.Core.Port{`9}">
      <summary>
            Convert to the 9th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})~Microsoft.Ccr.Core.Port{`10}">
      <summary>
            Convert to the 10th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})~Microsoft.Ccr.Core.Port{`11}">
      <summary>
            Convert to the 11th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`13.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})~Microsoft.Ccr.Core.Port{`12}">
      <summary>
            Convert to the 12th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`13.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`13.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`13.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`13.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`13.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`13.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`13.P6">
      <summary>
            Returns the port 6th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`13.P7">
      <summary>
            Returns the port 7th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`13.P8">
      <summary>
            Returns the port 8th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`13.P9">
      <summary>
            Returns the port 9th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`13.P10">
      <summary>
            Returns the port 10th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`13.P11">
      <summary>
            Returns the port 11th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`13.P12">
      <summary>
            Returns the port 12th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`14">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5},Microsoft.Ccr.Core.Port{`6},Microsoft.Ccr.Core.Port{`7},Microsoft.Ccr.Core.Port{`8},Microsoft.Ccr.Core.Port{`9},Microsoft.Ccr.Core.Port{`10},Microsoft.Ccr.Core.Port{`11},Microsoft.Ccr.Core.Port{`12},Microsoft.Ccr.Core.Port{`13})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.Post(`6)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.Post(`7)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.Post(`8)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.Post(`9)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.Post(`10)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.Post(`11)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.Post(`12)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.Post(`13)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})~Microsoft.Ccr.Core.Port{`6}">
      <summary>
            Convert to the 6th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})~Microsoft.Ccr.Core.Port{`7}">
      <summary>
            Convert to the 7th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})~Microsoft.Ccr.Core.Port{`8}">
      <summary>
            Convert to the 8th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})~Microsoft.Ccr.Core.Port{`9}">
      <summary>
            Convert to the 9th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})~Microsoft.Ccr.Core.Port{`10}">
      <summary>
            Convert to the 10th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})~Microsoft.Ccr.Core.Port{`11}">
      <summary>
            Convert to the 11th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})~Microsoft.Ccr.Core.Port{`12}">
      <summary>
            Convert to the 12th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`14.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})~Microsoft.Ccr.Core.Port{`13}">
      <summary>
            Convert to the 13th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`14.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`14.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`14.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`14.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`14.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`14.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`14.P6">
      <summary>
            Returns the port 6th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`14.P7">
      <summary>
            Returns the port 7th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`14.P8">
      <summary>
            Returns the port 8th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`14.P9">
      <summary>
            Returns the port 9th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`14.P10">
      <summary>
            Returns the port 10th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`14.P11">
      <summary>
            Returns the port 11th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`14.P12">
      <summary>
            Returns the port 12th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`14.P13">
      <summary>
            Returns the port 13th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`15">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5},Microsoft.Ccr.Core.Port{`6},Microsoft.Ccr.Core.Port{`7},Microsoft.Ccr.Core.Port{`8},Microsoft.Ccr.Core.Port{`9},Microsoft.Ccr.Core.Port{`10},Microsoft.Ccr.Core.Port{`11},Microsoft.Ccr.Core.Port{`12},Microsoft.Ccr.Core.Port{`13},Microsoft.Ccr.Core.Port{`14})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`6)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`7)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`8)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`9)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`10)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`11)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`12)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`13)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.Post(`14)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`6}">
      <summary>
            Convert to the 6th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`7}">
      <summary>
            Convert to the 7th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`8}">
      <summary>
            Convert to the 8th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`9}">
      <summary>
            Convert to the 9th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`10}">
      <summary>
            Convert to the 10th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`11}">
      <summary>
            Convert to the 11th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`12}">
      <summary>
            Convert to the 12th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`13}">
      <summary>
            Convert to the 13th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`15.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})~Microsoft.Ccr.Core.Port{`14}">
      <summary>
            Convert to the 14th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P6">
      <summary>
            Returns the port 6th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P7">
      <summary>
            Returns the port 7th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P8">
      <summary>
            Returns the port 8th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P9">
      <summary>
            Returns the port 9th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P10">
      <summary>
            Returns the port 10th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P11">
      <summary>
            Returns the port 11th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P12">
      <summary>
            Returns the port 12th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P13">
      <summary>
            Returns the port 13th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`15.P14">
      <summary>
            Returns the port 14th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`16">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5},Microsoft.Ccr.Core.Port{`6},Microsoft.Ccr.Core.Port{`7},Microsoft.Ccr.Core.Port{`8},Microsoft.Ccr.Core.Port{`9},Microsoft.Ccr.Core.Port{`10},Microsoft.Ccr.Core.Port{`11},Microsoft.Ccr.Core.Port{`12},Microsoft.Ccr.Core.Port{`13},Microsoft.Ccr.Core.Port{`14},Microsoft.Ccr.Core.Port{`15})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`6)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`7)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`8)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`9)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`10)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`11)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`12)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`13)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`14)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.Post(`15)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`6}">
      <summary>
            Convert to the 6th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`7}">
      <summary>
            Convert to the 7th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`8}">
      <summary>
            Convert to the 8th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`9}">
      <summary>
            Convert to the 9th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`10}">
      <summary>
            Convert to the 10th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`11}">
      <summary>
            Convert to the 11th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`12}">
      <summary>
            Convert to the 12th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`13}">
      <summary>
            Convert to the 13th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`14}">
      <summary>
            Convert to the 14th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`16.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})~Microsoft.Ccr.Core.Port{`15}">
      <summary>
            Convert to the 15th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P6">
      <summary>
            Returns the port 6th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P7">
      <summary>
            Returns the port 7th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P8">
      <summary>
            Returns the port 8th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P9">
      <summary>
            Returns the port 9th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P10">
      <summary>
            Returns the port 10th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P11">
      <summary>
            Returns the port 11th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P12">
      <summary>
            Returns the port 12th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P13">
      <summary>
            Returns the port 13th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P14">
      <summary>
            Returns the port 14th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`16.P15">
      <summary>
            Returns the port 15th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`17">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5},Microsoft.Ccr.Core.Port{`6},Microsoft.Ccr.Core.Port{`7},Microsoft.Ccr.Core.Port{`8},Microsoft.Ccr.Core.Port{`9},Microsoft.Ccr.Core.Port{`10},Microsoft.Ccr.Core.Port{`11},Microsoft.Ccr.Core.Port{`12},Microsoft.Ccr.Core.Port{`13},Microsoft.Ccr.Core.Port{`14},Microsoft.Ccr.Core.Port{`15},Microsoft.Ccr.Core.Port{`16})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`6)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`7)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`8)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`9)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`10)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`11)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`12)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`13)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`14)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`15)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.Post(`16)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`6}">
      <summary>
            Convert to the 6th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`7}">
      <summary>
            Convert to the 7th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`8}">
      <summary>
            Convert to the 8th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`9}">
      <summary>
            Convert to the 9th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`10}">
      <summary>
            Convert to the 10th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`11}">
      <summary>
            Convert to the 11th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`12}">
      <summary>
            Convert to the 12th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`13}">
      <summary>
            Convert to the 13th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`14}">
      <summary>
            Convert to the 14th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`15}">
      <summary>
            Convert to the 15th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`17.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})~Microsoft.Ccr.Core.Port{`16}">
      <summary>
            Convert to the 16th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P6">
      <summary>
            Returns the port 6th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P7">
      <summary>
            Returns the port 7th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P8">
      <summary>
            Returns the port 8th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P9">
      <summary>
            Returns the port 9th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P10">
      <summary>
            Returns the port 10th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P11">
      <summary>
            Returns the port 11th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P12">
      <summary>
            Returns the port 12th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P13">
      <summary>
            Returns the port 13th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P14">
      <summary>
            Returns the port 14th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P15">
      <summary>
            Returns the port 15th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`17.P16">
      <summary>
            Returns the port 16th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`18">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5},Microsoft.Ccr.Core.Port{`6},Microsoft.Ccr.Core.Port{`7},Microsoft.Ccr.Core.Port{`8},Microsoft.Ccr.Core.Port{`9},Microsoft.Ccr.Core.Port{`10},Microsoft.Ccr.Core.Port{`11},Microsoft.Ccr.Core.Port{`12},Microsoft.Ccr.Core.Port{`13},Microsoft.Ccr.Core.Port{`14},Microsoft.Ccr.Core.Port{`15},Microsoft.Ccr.Core.Port{`16},Microsoft.Ccr.Core.Port{`17})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`6)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`7)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`8)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`9)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`10)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`11)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`12)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`13)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`14)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`15)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`16)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.Post(`17)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`6}">
      <summary>
            Convert to the 6th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`7}">
      <summary>
            Convert to the 7th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`8}">
      <summary>
            Convert to the 8th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`9}">
      <summary>
            Convert to the 9th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`10}">
      <summary>
            Convert to the 10th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`11}">
      <summary>
            Convert to the 11th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`12}">
      <summary>
            Convert to the 12th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`13}">
      <summary>
            Convert to the 13th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`14}">
      <summary>
            Convert to the 14th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`15}">
      <summary>
            Convert to the 15th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`16}">
      <summary>
            Convert to the 16th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`18.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})~Microsoft.Ccr.Core.Port{`17}">
      <summary>
            Convert to the 17th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P6">
      <summary>
            Returns the port 6th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P7">
      <summary>
            Returns the port 7th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P8">
      <summary>
            Returns the port 8th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P9">
      <summary>
            Returns the port 9th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P10">
      <summary>
            Returns the port 10th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P11">
      <summary>
            Returns the port 11th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P12">
      <summary>
            Returns the port 12th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P13">
      <summary>
            Returns the port 13th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P14">
      <summary>
            Returns the port 14th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P15">
      <summary>
            Returns the port 15th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P16">
      <summary>
            Returns the port 16th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`18.P17">
      <summary>
            Returns the port 17th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`19">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5},Microsoft.Ccr.Core.Port{`6},Microsoft.Ccr.Core.Port{`7},Microsoft.Ccr.Core.Port{`8},Microsoft.Ccr.Core.Port{`9},Microsoft.Ccr.Core.Port{`10},Microsoft.Ccr.Core.Port{`11},Microsoft.Ccr.Core.Port{`12},Microsoft.Ccr.Core.Port{`13},Microsoft.Ccr.Core.Port{`14},Microsoft.Ccr.Core.Port{`15},Microsoft.Ccr.Core.Port{`16},Microsoft.Ccr.Core.Port{`17},Microsoft.Ccr.Core.Port{`18})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`6)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`7)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`8)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`9)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`10)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`11)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`12)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`13)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`14)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`15)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`16)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`17)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.Post(`18)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`6}">
      <summary>
            Convert to the 6th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`7}">
      <summary>
            Convert to the 7th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`8}">
      <summary>
            Convert to the 8th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`9}">
      <summary>
            Convert to the 9th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`10}">
      <summary>
            Convert to the 10th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`11}">
      <summary>
            Convert to the 11th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`12}">
      <summary>
            Convert to the 12th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`13}">
      <summary>
            Convert to the 13th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`14}">
      <summary>
            Convert to the 14th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`15}">
      <summary>
            Convert to the 15th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`16}">
      <summary>
            Convert to the 16th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`17}">
      <summary>
            Convert to the 17th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`19.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})~Microsoft.Ccr.Core.Port{`18}">
      <summary>
            Convert to the 18th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P6">
      <summary>
            Returns the port 6th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P7">
      <summary>
            Returns the port 7th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P8">
      <summary>
            Returns the port 8th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P9">
      <summary>
            Returns the port 9th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P10">
      <summary>
            Returns the port 10th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P11">
      <summary>
            Returns the port 11th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P12">
      <summary>
            Returns the port 12th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P13">
      <summary>
            Returns the port 13th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P14">
      <summary>
            Returns the port 14th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P15">
      <summary>
            Returns the port 15th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P16">
      <summary>
            Returns the port 16th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P17">
      <summary>
            Returns the port 17th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`19.P18">
      <summary>
            Returns the port 18th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.PortSet`20">
      <summary>
            Multiple Queue Port composed out of multiple Port&lt;T&gt; instances, one for each type
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /><remarks>For each generic type argument T, an instance of Port&lt;T&gt; is used to store messages of that type
            Each Port&lt;T&gt; instance is independent of the others and there are non ordering guarantees across ports under the same
            multiple port wrapper. To get access to the individual ports use the P0,P1,...,PN accessors
            </remarks></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.#ctor">
      <summary>
            Constructs a PortSet using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.#ctor(Microsoft.Ccr.Core.Arbiters.PortSetMode)">
      <summary>
            Constructs a PortSet using the specified mode of operation
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.#ctor(Microsoft.Ccr.Core.Port{`0},Microsoft.Ccr.Core.Port{`1},Microsoft.Ccr.Core.Port{`2},Microsoft.Ccr.Core.Port{`3},Microsoft.Ccr.Core.Port{`4},Microsoft.Ccr.Core.Port{`5},Microsoft.Ccr.Core.Port{`6},Microsoft.Ccr.Core.Port{`7},Microsoft.Ccr.Core.Port{`8},Microsoft.Ccr.Core.Port{`9},Microsoft.Ccr.Core.Port{`10},Microsoft.Ccr.Core.Port{`11},Microsoft.Ccr.Core.Port{`12},Microsoft.Ccr.Core.Port{`13},Microsoft.Ccr.Core.Port{`14},Microsoft.Ccr.Core.Port{`15},Microsoft.Ccr.Core.Port{`16},Microsoft.Ccr.Core.Port{`17},Microsoft.Ccr.Core.Port{`18},Microsoft.Ccr.Core.Port{`19})">
      <summary>
            Constructs a Multiple Queue Port using individual Port&lt;T&gt; instances
            <seealso cref="T:Microsoft.Ccr.Core.Port`1" /></summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`0)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`1)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`2)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`3)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`4)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`5)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`6)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`7)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`8)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`9)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`10)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`11)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`12)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`13)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`14)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`15)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`16)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`17)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`18)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.Post(`19)">
      <summary>
            Enqueues a message instance
            </summary>
      <exception cref="T:Microsoft.Ccr.Core.PortNotFoundException">
            Thrown if the message type is not compatible with the port
            </exception>
      <param name="item">Object instance to enqueue</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`0}">
      <summary>
            Convert to the 0th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`1}">
      <summary>
            Convert to the 1th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`2}">
      <summary>
            Convert to the 2th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`3}">
      <summary>
            Convert to the 3th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`4}">
      <summary>
            Convert to the 4th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`5}">
      <summary>
            Convert to the 5th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`6}">
      <summary>
            Convert to the 6th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`7}">
      <summary>
            Convert to the 7th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`8}">
      <summary>
            Convert to the 8th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`9}">
      <summary>
            Convert to the 9th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`10}">
      <summary>
            Convert to the 10th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`11}">
      <summary>
            Convert to the 11th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`12}">
      <summary>
            Convert to the 12th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`13}">
      <summary>
            Convert to the 13th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`14}">
      <summary>
            Convert to the 14th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`15}">
      <summary>
            Convert to the 15th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`16}">
      <summary>
            Convert to the 16th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`17}">
      <summary>
            Convert to the 17th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`18}">
      <summary>
            Convert to the 18th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.PortSet`20.op_Implicit(Microsoft.Ccr.Core.PortSet{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})~Microsoft.Ccr.Core.Port{`19}">
      <summary>
            Convert to the 19th PortSet&lt;T&gt; instance.
            </summary>
      <param name="port">PortSet to convert.</param>
      <returns>Null if <paramref name="port" /> was null; the instance otherwise.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P0">
      <summary>
            Returns the port 0th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P1">
      <summary>
            Returns the port 1th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P2">
      <summary>
            Returns the port 2th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P3">
      <summary>
            Returns the port 3th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P4">
      <summary>
            Returns the port 4th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P5">
      <summary>
            Returns the port 5th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P6">
      <summary>
            Returns the port 6th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P7">
      <summary>
            Returns the port 7th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P8">
      <summary>
            Returns the port 8th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P9">
      <summary>
            Returns the port 9th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P10">
      <summary>
            Returns the port 10th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P11">
      <summary>
            Returns the port 11th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P12">
      <summary>
            Returns the port 12th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P13">
      <summary>
            Returns the port 13th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P14">
      <summary>
            Returns the port 14th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P15">
      <summary>
            Returns the port 15th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P16">
      <summary>
            Returns the port 16th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P17">
      <summary>
            Returns the port 17th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P18">
      <summary>
            Returns the port 18th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.PortSet`20.P19">
      <summary>
            Returns the port 19th port in this collection.
            <remarks>Index is 0-based.</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.IterativeTask`1">
      <summary>
            Container for iterator handlers and their arguments
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`1.#ctor(Microsoft.Ccr.Core.IteratorHandler{`0})">
      <summary>
            Constructs a typed task instance associated with an iterator delegate
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`1.PartialClone">
      <summary>
            Shallow clone of the task instance
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`1.#ctor(`0,Microsoft.Ccr.Core.IteratorHandler{`0})">
      <summary>
            Constructs a typed task instance associated with an iterator delegate given some arguments
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`1.ToString">
      <summary>
            Human readable description of the handler associated with the task
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`1.Execute">
      <summary>
            Invoked by the dispatcher to execute the Handler associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.IterativeTask`1.Item(System.Int32)">
      <summary>
            Indexer for arguments associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.IterativeTask`1.PortElementCount">
      <summary>
            Number of valid arguments associated with this task
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Task`1">
      <summary>
            Container for typed, non-iterator handlers and their arguments
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Task`1.Param0">
      <summary>
            Typed parameter passed to user delegate on task execution
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`1.#ctor(Microsoft.Ccr.Core.Handler{`0})">
      <summary>
            Constructs a typed task instance associated with a delegate
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`1.ToString">
      <summary>
            Human readable description of the handler associated with the task
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`1.PartialClone">
      <summary>
            Shallow clone of this task instance
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`1.#ctor(`0,Microsoft.Ccr.Core.Handler{`0})">
      <summary>
            Constructs a typed task instance associated with a delegate given some arguments
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`1.Execute">
      <summary>
            Invoked by the dispatcher to execute the Handler associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Task`1.Item(System.Int32)">
      <summary>
            Indexer for arguments associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Task`1.PortElementCount">
      <summary>
            Number of valid arguments associated with this task
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.IterativeTask`2">
      <summary>
            Container for iterator handlers and their arguments
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`2.#ctor(Microsoft.Ccr.Core.IteratorHandler{`0,`1})">
      <summary>
            Constructs a typed task instance associated with an iterator delegate
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`2.PartialClone">
      <summary>
            Shallow clone of the task instance
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`2.#ctor(`0,`1,Microsoft.Ccr.Core.IteratorHandler{`0,`1})">
      <summary>
            Constructs a typed task instance associated with an iterator delegate given some arguments
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`2.ToString">
      <summary>
            Human readable description of the handler associated with the task
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`2.Execute">
      <summary>
            Invoked by the dispatcher to execute the Handler associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.IterativeTask`2.Item(System.Int32)">
      <summary>
            Indexer for arguments associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.IterativeTask`2.PortElementCount">
      <summary>
            Number of valid arguments associated with this task
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Task`2">
      <summary>
            Container for typed, non-iterator handlers and their arguments
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Task`2.Param0">
      <summary>
            Typed parameter passed to user delegate on task execution
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Task`2.Param1">
      <summary>
            Typed parameter passed to user delegate on task execution
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`2.#ctor(Microsoft.Ccr.Core.Handler{`0,`1})">
      <summary>
            Constructs a typed task instance associated with a delegate
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`2.ToString">
      <summary>
            Human readable description of the handler associated with the task
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`2.PartialClone">
      <summary>
            Shallow clone of this task instance
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`2.#ctor(`0,`1,Microsoft.Ccr.Core.Handler{`0,`1})">
      <summary>
            Constructs a typed task instance associated with a delegate given some arguments
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`2.Execute">
      <summary>
            Invoked by the dispatcher to execute the Handler associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Task`2.Item(System.Int32)">
      <summary>
            Indexer for arguments associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Task`2.PortElementCount">
      <summary>
            Number of valid arguments associated with this task
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.IterativeTask`3">
      <summary>
            Container for iterator handlers and their arguments
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`3.#ctor(Microsoft.Ccr.Core.IteratorHandler{`0,`1,`2})">
      <summary>
            Constructs a typed task instance associated with an iterator delegate
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`3.PartialClone">
      <summary>
            Shallow clone of the task instance
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`3.#ctor(`0,`1,`2,Microsoft.Ccr.Core.IteratorHandler{`0,`1,`2})">
      <summary>
            Constructs a typed task instance associated with an iterator delegate given some arguments
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`3.ToString">
      <summary>
            Human readable description of the handler associated with the task
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.IterativeTask`3.Execute">
      <summary>
            Invoked by the dispatcher to execute the Handler associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.IterativeTask`3.Item(System.Int32)">
      <summary>
            Indexer for arguments associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.IterativeTask`3.PortElementCount">
      <summary>
            Number of valid arguments associated with this task
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Task`3">
      <summary>
            Container for typed, non-iterator handlers and their arguments
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Task`3.Param0">
      <summary>
            Typed parameter passed to user delegate on task execution
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Task`3.Param1">
      <summary>
            Typed parameter passed to user delegate on task execution
            </summary>
    </member>
    <member name="F:Microsoft.Ccr.Core.Task`3.Param2">
      <summary>
            Typed parameter passed to user delegate on task execution
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`3.#ctor(Microsoft.Ccr.Core.Handler{`0,`1,`2})">
      <summary>
            Constructs a typed task instance associated with a delegate
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`3.ToString">
      <summary>
            Human readable description of the handler associated with the task
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`3.PartialClone">
      <summary>
            Shallow clone of this task instance
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`3.#ctor(`0,`1,`2,Microsoft.Ccr.Core.Handler{`0,`1,`2})">
      <summary>
            Constructs a typed task instance associated with a delegate given some arguments
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Task`3.Execute">
      <summary>
            Invoked by the dispatcher to execute the Handler associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Task`3.Item(System.Int32)">
      <summary>
            Indexer for arguments associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.Task`3.PortElementCount">
      <summary>
            Number of valid arguments associated with this task
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.Tuple`1">
      <summary>
            A type-safe, type-heterogeneous, item collection used for joins.
            </summary>
      <typeparam name="ITEM0">The type of the 0th item.</typeparam>
      <remarks>Indicies are 0-based.</remarks>
    </member>
    <member name="M:Microsoft.Ccr.Core.Tuple`1.#ctor">
      <summary>
            Construct an empty Tuple.
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Tuple`1.#ctor(`0)">
      <summary>
            Construct a Tuple, supplying the initial values.
            </summary>
      <remarks>Indicies are 0-based.</remarks>
      <param name="item0">The 0th item in the collection to construct.</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Tuple`1.op_Implicit(Microsoft.Ccr.Core.Tuple{`0})~`0">
      <summary>
            Implicit conversion to 0th item.
            </summary>
      <remarks>Indicies are 0-based.</remarks>
      <param name="tuple">Tuple from which to access item.=.</param>
      <returns>Accessed item.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Tuple`1.ToItem0">
      <summary>
            Implicit conversion to 0th item.
            </summary>
      <remarks>Indicies are 0-based.</remarks>
      <returns>Accessed item.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.Tuple`1.Item0">
      <summary>
            The 0th item in the collection.
            </summary>
      <remarks>Indicies are 0-based.</remarks>
    </member>
    <member name="T:Microsoft.Ccr.Core.Tuple`2">
      <summary>
            A type-safe, type-heterogeneous, item collection used for joins.
            </summary>
      <typeparam name="ITEM0">The type of the 0th item.</typeparam>
      <typeparam name="ITEM1">The type of the 1th item.</typeparam>
      <remarks>Indicies are 0-based.</remarks>
    </member>
    <member name="M:Microsoft.Ccr.Core.Tuple`2.#ctor">
      <summary>
            Construct an empty Tuple.
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.Tuple`2.#ctor(`0,`1)">
      <summary>
            Construct a Tuple, supplying the initial values.
            </summary>
      <remarks>Indicies are 0-based.</remarks>
      <param name="item0">The 0th item in the collection to construct.</param>
      <param name="item1">The 1th item in the collection to construct.</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.Tuple`2.op_Implicit(Microsoft.Ccr.Core.Tuple{`0,`1})~`0">
      <summary>
            Implicit conversion to 0th item.
            </summary>
      <remarks>Indicies are 0-based.</remarks>
      <param name="tuple">Tuple from which to access item.=.</param>
      <returns>Accessed item.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Tuple`2.ToItem0">
      <summary>
            Implicit conversion to 0th item.
            </summary>
      <remarks>Indicies are 0-based.</remarks>
      <returns>Accessed item.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Tuple`2.op_Implicit(Microsoft.Ccr.Core.Tuple{`0,`1})~`1">
      <summary>
            Implicit conversion to 1th item.
            </summary>
      <remarks>Indicies are 0-based.</remarks>
      <param name="tuple">Tuple from which to access item.=.</param>
      <returns>Accessed item.</returns>
    </member>
    <member name="M:Microsoft.Ccr.Core.Tuple`2.ToItem1">
      <summary>
            Implicit conversion to 1th item.
            </summary>
      <remarks>Indicies are 0-based.</remarks>
      <returns>Accessed item.</returns>
    </member>
    <member name="P:Microsoft.Ccr.Core.Tuple`2.Item0">
      <summary>
            The 0th item in the collection.
            </summary>
      <remarks>Indicies are 0-based.</remarks>
    </member>
    <member name="P:Microsoft.Ccr.Core.Tuple`2.Item1">
      <summary>
            The 1th item in the collection.
            </summary>
      <remarks>Indicies are 0-based.</remarks>
    </member>
    <member name="T:Microsoft.Ccr.Core.VariableArgumentHandler`1">
      <summary>
            A typed delegate with a variable number of typed arguments preceding an array of instances of the same type.
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.VariableArgumentTask`1">
      <summary>
            A Task container with a variable number of typed arguments.
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.VariableArgumentTask`1.#ctor(System.Int32,Microsoft.Ccr.Core.VariableArgumentHandler{`0})">
      <summary>
            Constructs a Task container with a variable number of typed arguments.
            </summary>
      <param name="varArgSize">Number of typed arguments</param>
      <param name="handler">The typed user delegate associated with the task.</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.VariableArgumentTask`1.PartialClone">
      <summary>
            Shallow clone of this task instance
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.VariableArgumentTask`1.ToString">
      <summary>
            Human readable description of the handler associated with the task
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.VariableArgumentTask`1.Execute">
      <summary>
            Invoked by the dispatcher to execute the Handler associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.VariableArgumentTask`1.ArbiterCleanupHandler">
      <summary>
            Set by a top level arbiter so it can execute logic on task completion
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.VariableArgumentTask`1.LinkedIterator">
      <summary>
            Iterator that needs to be processed once current task completes
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.VariableArgumentTask`1.TaskQueue">
      <summary>
            Dispatcher queue to use for scheduling any tasks 
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.VariableArgumentTask`1.Item(System.Int32)">
      <summary>
            Indexer for arguments associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.VariableArgumentTask`1.PortElementCount">
      <summary>
            Number of valid arguments associated with this task
            </summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.VariableArgumentHandler`2">
      <summary>
            A typed delegate with a variable number of typed arguments preceding an array of instances of the same type.
            <remarks>Used as the continuation to join variable and joinarray</remarks></summary>
    </member>
    <member name="T:Microsoft.Ccr.Core.VariableArgumentTask`2">
      <summary>
            A Task container with a variable number of typed arguments.
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.VariableArgumentTask`2.#ctor(System.Int32,Microsoft.Ccr.Core.VariableArgumentHandler{`0,`1})">
      <summary>
            Constructs a Task container with a variable number of typed arguments.
            </summary>
      <param name="varArgSize">Number of typed arguments</param>
      <param name="handler">The typed user delegate associated with the task.</param>
    </member>
    <member name="M:Microsoft.Ccr.Core.VariableArgumentTask`2.PartialClone">
      <summary>
            Shallow clone of this task instance
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.VariableArgumentTask`2.ToString">
      <summary>
            Human readable description of the handler associated with the task
            </summary>
    </member>
    <member name="M:Microsoft.Ccr.Core.VariableArgumentTask`2.Execute">
      <summary>
            Invoked by the dispatcher to execute the Handler associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.VariableArgumentTask`2.ArbiterCleanupHandler">
      <summary>
            Set by a top level arbiter so it can execute logic on task completion
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.VariableArgumentTask`2.LinkedIterator">
      <summary>
            Iterator that needs to be processed once current task completes
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.VariableArgumentTask`2.TaskQueue">
      <summary>
            Dispatcher queue to use for scheduling any tasks 
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.VariableArgumentTask`2.Item(System.Int32)">
      <summary>
            Indexer for arguments associated with the task
            </summary>
    </member>
    <member name="P:Microsoft.Ccr.Core.VariableArgumentTask`2.PortElementCount">
      <summary>
            Number of valid arguments associated with this task
            </summary>
    </member>
  </members>
</doc>